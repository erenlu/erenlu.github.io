<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>音视频笔记｜运动估计 ME 源码简要分析（上）</title>
    <link href="/posts/49d0.html"/>
    <url>/posts/49d0.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>运动估计在分别会在 lookahead 阶段和后续编码阶段被使用，但两者使用的方法并不相同。本文将介绍编码阶段的 ME 进行讨论，下文将对 lookahead 阶段的 ME 进行介绍。</p></blockquote><p>运动估计是帧间预测阶段的核心部分，它通过比较当前帧与先前帧之间的相似性，来确定宏块（Macroblock）或子宏块（Sub-macroblock）之间的运动矢量。运动估计可以有效地消除时间冗余，从而降低编码后的比特率，提高编码效率。x264中的运动估计算法有很多种，包括钻石搜索（Diamond Search），六边形搜索（Hexagon Search）和不对称交叉多六边形搜索（Uneven Multi-Hexagon Search）等。</p><h2 id="ME-相关知识"><a href="#ME-相关知识" class="headerlink" title="ME 相关知识"></a>ME 相关知识</h2><h3 id="宏块的运动补偿"><a href="#宏块的运动补偿" class="headerlink" title="宏块的运动补偿"></a>宏块的运动补偿</h3><p>宏块（Macroblock）是帧中 16x16 大小的区域，它是包括 MPEG-1、MPEG-2、MPEG-4 Visual、H.261、H.262、H,264 在内的很多视频编码标准的运动补偿预测的基本单元。</p><p>在常见的 YUV 4:2:0 图像编码格式中，一个宏块由：</p><ol><li><p>64 个红色色差采样构成，这些采样组成 1 个 8x8 的采样块；</p></li><li><p>64 个红色色差采样构成，这些采样组成 1 个 8x8 的采样块；</p></li><li><p>64 个蓝色色差采样构成，这些采样组成 1 个 8x8 的采样块；</p></li></ol><p>即一共 6 个采样块，示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202304092038902.png"></p><p>宏块的运动估计，主要是寻找参考帧中和当前宏块匹配的 16x16 采样区域。参考帧是先前就编码好的一个帧，在时间维上，参考帧可以在过去或者未来。参考帧中以当前宏块为中心的区域被搜索，寻找最佳匹配。</p><p>最佳匹配的照度、色差采样，被从当前宏块中减去，这样就产生了一个残余宏块。残余宏块与标示了最佳匹配区域和当前宏块的相对位移的 <strong>移动向量</strong> 一起编码并传输。</p><p>在上述基本的运动估计、运动补偿的基础上，有很多变体的算法：</p><ol><li>如果使用了未来的帧作为参考帧，则未来的帧必须在当前帧之前编码，也就是帧的编码必须是乱序的；</li><li>当参考帧和当前帧的差异非常大时，不使用运动补偿可能更加高效，编码器可能选择使用帧内预测；</li><li>视频中的移动物体很少能恰恰匹配16x16的边缘，因此使用可变大小的块往往更加高效；</li><li>物体移动的距离可能不是整像素，例如物体可能在水平方向移动3.83像素的距离。因此一个好的预测算法会在搜索最佳匹配之前在参考帧中，在次像素级别进行插值。</li></ol><h2 id="Preset-与-ME"><a href="#Preset-与-ME" class="headerlink" title="Preset 与 ME"></a>Preset 与 ME</h2><p>笔者本以为在 ultrafast 等较快的 Preset 模式下 ME 是不会开启的，但后来翻看源码发现：在所有 Preset 模式下都会启用，同时会根据 Preset 档次来选择对应的 ME 算法（diamon，haxgon，umh 等）</p><p>AQ（Adopt Quatinazation, 自适应量化） 在除 ultrafast （禁用 AQ 降低复杂度） 以外的所有 Preset 下都会开启。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202304092039639.png"></p><h2 id="源码中调用位置"><a href="#源码中调用位置" class="headerlink" title="源码中调用位置"></a>源码中调用位置</h2><aside> 💡 ME 在源码中代码调用顺序（真正的编码阶段） encode_frame() → x264_encoder_encode() → slices_write() → slice_write() → x264_macroblock_analyse() → mb_analyse_inter_p16x16() → x264_me_search_ref()</aside><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202304092041548.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202304092041568.png"></p><ul><li><strong>slices_write()</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202304092042242.png"></p><ul><li>**slice_write()**（主要是slice，不是复数）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202304092042266.png"></p><ul><li><strong>x264_macroblock_analyse() - 【slice_write() &#x2F; analyse.c】</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202304092042280.png"></p><ul><li><strong>mb_analyse_inter_p16x16()【P 帧为例】</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202304092042294.png"></p><ul><li><strong>x264_me_search_ref【mb_analyse_inter_b16x16】</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202304092042306.png"></p><p>以上便是ME在源码中的函数调用位置。</p><p>由于笔者在此阶段也只是简略进行分析，如有疏漏请欢迎指正！</p>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>x264</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音视频笔记｜H264 基础原理介绍</title>
    <link href="/posts/1db7.html"/>
    <url>/posts/1db7.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、视频压缩基础"><a href="#一、视频压缩基础" class="headerlink" title="一、视频压缩基础"></a>一、视频压缩基础</h2><h3 id="1-1-压缩基本概念"><a href="#1-1-压缩基本概念" class="headerlink" title="1.1 压缩基本概念"></a>1.1 压缩基本概念</h3><ul><li><p>编码的目的是为了压缩，编码是一种压缩技术方法；</p></li><li><p>编码的作用就是压缩数据和统一格式；</p></li><li><p>视频压缩原理——数据冗余</p><ul><li>空间冗余：图像相邻像素之间有较强的相关性</li><li>时间冗余：相邻前后帧图像内容相似</li><li>视觉冗余：人眼对某些细节不敏感，对图像中高频信息的敏感度小于低频信息，故可以适当剔除高频信息</li><li>编码冗余（信息熵冗余）：一幅图像中不同像素出现的概率不同，对出现次数较多的像素用少的位数编码以此来减小编码大小（哈夫曼编码）</li></ul></li></ul><h3 id="1-2-封装格式"><a href="#1-2-封装格式" class="headerlink" title="1.2 封装格式"></a>1.2 封装格式</h3><ul><li>封装格式也叫容器，就是将已经编码压缩好的视频轨和音频轨按照一定的格式放到一个文件中；</li><li>他是一个外壳容器，常见的格式（后缀名）有 mp4、mov、avi、mkv 等；</li></ul><h3 id="1-3-常见视频压缩算法"><a href="#1-3-常见视频压缩算法" class="headerlink" title="1.3 常见视频压缩算法"></a>1.3 常见视频压缩算法</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111600783.png"></p><h2 id="二、H264-编码概述"><a href="#二、H264-编码概述" class="headerlink" title="二、H264 编码概述"></a>二、H264 编码概述</h2><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111605703.png"></p><h3 id="2-1-YUV-图像"><a href="#2-1-YUV-图像" class="headerlink" title="2.1 YUV 图像"></a>2.1 <strong>YUV 图像</strong></h3><p>YUV 是一种色彩编码模型，也叫做 YCbCr，其中 “Y” 表示明亮度（Luminance），“U” 和 “V” 分别表示色度（Chrominance）和浓度（Chroma）</p><p>其实亮度 Y 也可以理解成 RGB 图像中的灰度值。YUV 颜色空间主要在多媒体流中使用较多。YUV 空间最大的特点就是图像的亮度 Y 和色度 UV 是分离的。通常人对色度 UV 的敏感性要小于对亮度 Y 的敏感性。所以通常都会对 UV 进行压缩，甚至没有UV分量一样可以显示完整的图像。当只有 Y 分量的时候，图像表示为灰度图。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111600892.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111605779.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111605795.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111600780.png"></p><h3 id="2-2-I-帧-P-帧-B-帧"><a href="#2-2-I-帧-P-帧-B-帧" class="headerlink" title="2.2 I 帧 P 帧 B 帧"></a>2.2 I 帧 P 帧 B 帧</h3><p>在 H264 协议中定义了三类帧</p><p>I 帧：关键帧（包含完整的画面数据），仅由帧内预测的宏块组成，采用 <strong>帧内压缩</strong> 技术。<br>P 帧：预测帧，向前参考帧，在压缩时，只参考前面已经处理的帧。<br>B 帧：双向参考帧，在压缩时，它即参考前而的帧，又参考它后面的帧。采用帧间压缩技术。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111607020.png"></p><h3 id="2-3-GOP-图像组"><a href="#2-3-GOP-图像组" class="headerlink" title="2.3 GOP 图像组"></a>2.3 GOP 图像组</h3><p>GOP（Group of picture）是指两个 IDR 帧之间的一组画面组。</p><p>两个 I 帧之间是一个图像序列，在一个图像序列中只有一个I帧。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111607297.png"></p><h3 id="2-4-IDR-立即刷新图像"><a href="#2-4-IDR-立即刷新图像" class="headerlink" title="2.4 IDR 立即刷新图像"></a>2.4 IDR 立即刷新图像</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111608950.png"></p><p>在 H.264 中，图像以序列为单位进行组织。<strong>一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。</strong>这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR 图像之后的图像永远不会使用IDR之前的图像的数据来解码。<strong>IDR 图像一定是 I 图像，但 I 图像不一定是 IDR 图像</strong>。I 帧之后的图像有可能会使用I帧之前的图像做运动参考。</p><p>IDR 帧的性质是，比如第 1000 帧是 IDR 帧，那么这一帧相当于一个分水岭，从 1001 帧开始，所有的帧都不能再参照1000帧之前的帧。</p><p>视频开头的 I 帧一定是 IDR 帧</p><p>GOP 越大，编码的 I 帧就越少，相对而言 P、B 帧的压缩效率就越高。</p><h3 id="2-5-H264-画质级别"><a href="#2-5-H264-画质级别" class="headerlink" title="2.5 H264 画质级别"></a>2.5 H264 画质级别</h3><p>H.264有四种画质级别,分别是baseline, extended, main, high：<br>　　1、Baseline Profile：基本画质。支持I&#x2F;P 帧，只支持无交错（Progressive）和CAVLC；<br>　　2、Extended profile：进阶画质。支持I&#x2F;P&#x2F;B&#x2F;SP&#x2F;SI 帧，只支持无交错（Progressive）和CAVLC；(用的少)<br>　　3、Main profile：主流画质。提供I&#x2F;P&#x2F;B 帧，支持无交错（Progressive）和交错（Interlaced），<br>　　　 也支持CAVLC 和CABAC 的支持；<br>　　4、High profile：高级画质。在main Profile 的基础上增加了8x8内部预测、自定义量化、 无损视频编码和更多的YUV 格式；<br>H.264 Baseline profile、Extended profile和Main profile都是针对8位样本数据、4:2:0格式(YUV)的视频序列。在相同配置情况下，High profile（HP）可以比Main profile（MP）降低10%的码率。<br>根据应用领域的不同，Baseline profile多应用于实时通信领域，Main profile多应用于流媒体领域，High profile则多应用于广电和存储领域。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111608540.png"></p><h2 id="三、H264-编码流程"><a href="#三、H264-编码流程" class="headerlink" title="三、H264 编码流程"></a>三、H264 编码流程</h2><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111608684.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111608406.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111609032.png"></p><h3 id="3-1-宏块划分-x2F-扫描"><a href="#3-1-宏块划分-x2F-扫描" class="headerlink" title="3.1 宏块划分&#x2F; 扫描"></a>3.1 宏块划分&#x2F; 扫描</h3><ul><li>视频以宏块为单元，宏块越大视频文件越小；</li><li>视频的本质是宏块的运动；</li><li>在H.264 中，句法元素共被组织成 序列、图像、片、宏块、子宏块五个层次</li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111609781.png"></p><p>对一个 YUV 图像来说，可以划分为一个个 16x16 的宏块。</p><p>H264 默认是使用 16X16 大小的区域作为一个宏块，也可以划分成 8X8 大小。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111609744.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111609472.png"></p><p><strong>划分好宏块后，计算宏块的象素值</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111610619.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111610376.png"></p><p><strong>划分子块</strong></p><p>H264对比较平坦的图像使用 16X16 大小的宏块。但为了更高的压缩率，还可以在 16X16 的宏块上更划分出更小的子块。子块的大小可以是 8X16､ 16X8､ 8X8､ 4X8､ 8X4､ 4X4非常的灵活。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111611117.png"></p><h3 id="3-2-帧分组"><a href="#3-2-帧分组" class="headerlink" title="3.2 帧分组"></a>3.2 帧分组</h3><p>1、分组：把几帧图像分为一组（GOP，也就是一个序列），为防止运动变化，帧数不宜取多<br>2、定义帧：将每组内各帧图像定义为三种类型，即 I 帧、B帧和P帧<br>3、预测帧：以帧作为基础帧，以帧预测P帧，再由 I 帧和P帧预测B帧<br>4、数据传输：最后将 I 帧数据与预测的差值信息进行存储和传输</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111611732.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111611794.png"></p><p>通过宏块扫描与宏块搜索可以发现这两个帧的关联度是非常高的。进而发现这一组帧的关联度都是非常高的。因此，上面这几帧就可以划分为一组。其算法是：<strong>在相邻几幅图像画面中，一般有差别的像素只有10%以内的点,亮度差值变化不超过2%，而色度差值的变化只有1%以内，我们认为这样的图可以分到一组。</strong></p><p>在这样一组帧中，经过编码后，<strong>我们只保留第一帖的完整数据</strong>，其它帧都通过参考上一帧计算出来。我们称第一帧为<strong>IDR／I帧</strong>，其它帧我们称为<strong>P／B帧</strong>，这样编码后的数据帧组我们称为 <strong>GOP</strong>。</p><h3 id="3-3-帧间压缩（运动估计与补偿）"><a href="#3-3-帧间压缩（运动估计与补偿）" class="headerlink" title="3.3 帧间压缩（运动估计与补偿）"></a>3.3 帧间压缩（运动估计与补偿）</h3><p>帧间压缩(Interframe compression)也称为时间压缩(Temporal_compression)，是基于许多视频或动画的连续前后两帧具有很大的相关性(即连续的视频其相邻帧之间具有冗余信息)的特点来实现的；通过比较时间轴上不同帧之间的数据实施压缩，进一步提高压缩比。</p><p>在视频中，帧内压缩就是压缩 GOP 图像组中的 B 帧与 P 帧。</p><p>H264 编码器首先按顺序从缓冲区头部取出两帧视频数据，然后进行宏块扫描。当发现其中一幅图片中有物体时，就在另一幅图的邻近位置（搜索窗口中）进行搜索。如果此时在另一幅图中找到该物体，那么就可以计算出物体的运动矢量了。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111612969.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111612601.png"></p><p>运动矢量计算出来后，将相同部分（也就是绿色部分）减去，就得到了补偿数据。我们最终只需要将补偿数据进行压缩保存，以后在解码时就可以恢复原图了。压缩补偿后的数据只需要记录很少的一点数据。</p><p>我们把运动矢量与补偿称为<strong>帧间压缩技术</strong>，它解决的是视频帧在时间上的数据冗余。除了帧间压缩，帧内也要进行数据压缩，帧内数据压缩解决的是空间上的数据冗余。</p><p>帧间压缩的主要过程先进行宏块查找，寻找出残差值，进行运动矢量计算，最后通过残差值和运动矢量推算出下一帧的数据。</p><p>残差值是指帧之间有差别的部分；</p><p>帧间压缩 (Interframe compression) 也称为时间压缩 (Temporal_compression)，是基于许多视频或动画的连续前后两帧具有很大的相关性(即连续的视频其相邻帧之间具有冗余信息)的特点来实现的；通过比较时间轴上不同帧之间的数据实施压缩，进一步提高压缩比。</p><h3 id="3-4-帧内预测"><a href="#3-4-帧内预测" class="headerlink" title="3.4 帧内预测"></a>3.4 帧内预测</h3><p>人眼对图象都有一个识别度，对低频的亮度很敏感，对高频的亮度不太敏感。所以基于一些研究，可以将一幅图像中人眼不敏感的数据去除掉。这样就提出了帧内预测技术。</p><p>H264的帧内压缩与JPEG很相似。一幅图像被划分好宏块后，对每个宏块可以进行 9 种模式的预测。找出与原图最接近的一种预测模式。</p><p>帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，达不到很高的压缩比。</p><p>在视频中，帧内压缩就是压缩 GOP 图像组中的 I 帧&#x2F; IDR帧(属于I帧)。</p><p>帧内压缩是空域， 在空间XY轴进行压缩，进行压缩参考本帧数据，压缩率较小。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111612830.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111612901.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111612511.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111613081.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111613600.png"></p><p>帧内预测后的图像与原始图像的对比如下：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111613674.png"></p><p>然后，将原始图像与帧内预测后的图像相减得残差值。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111613101.png"></p><p>再将我们之前得到的预测模式信息一起保存起来，这样我们就可以在解码时恢复原图了。效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111613601.png"></p><p>经过帧内与帧间的压缩后，虽然数据有大幅减少，但还有优化的空间。</p><blockquote><p>帧内压缩与帧间压缩都属于有损压缩。</p><p>视频花屏的产生原因：一组 GOP 中有帧丢失，主要是 P 帧和 B 帧的丢失，这样残差值和运动矢量也会丢失，造成了当前帧解码失败，就会出现花屏。</p><p>视频卡顿的原因：当有帧丢失，就丢弃 GOP 内所有帧，直到下一个 I 帧出现，重新刷新图像。I 帧是 GOP 的第一帧，时间周期可能长，等待下一个 I 帧来之前的这段时间，就会出现卡顿。</p><p>这两者是不能同时兼顾的，比如微信视频通话没有花屏，但是会出现卡顿。一般视频录制的时候一般会有花屏，但不会出现卡顿。</p></blockquote><h3 id="3-5-DCT-和量化"><a href="#3-5-DCT-和量化" class="headerlink" title="3.5 DCT 和量化"></a>3.5 DCT 和量化</h3><p>对残差数据做 DCT</p><p>可以将残差数据做整数离散余弦变换，去掉数据的相关性，进一步压缩数据</p><p>将残差数据宏块进行 DCT 转换。</p><p>变换是视频、图像编码的核心部分。目前所采用的变换算法都是从傅里叶变换演变而来。</p><p>单纯的变换并不会导致视频（图像）的码率变小，反而会增大。</p><p>但是非常巧妙的一点是：变换把图像从空域转换成的时域，把由色块组成的图像变为由基准色调与图像细节组成；低频代表图片的基准色调，高频代表图像细节，类比电路中的基频与谐波。变换会使得图像的低频系数集中于某一点（左上角），频率向右下角递增。</p><p>一般来说，4x4大小的图像大多只是颜色平缓的色块，不会有太多的细节，因此低频系数会较大，而高频系数较小。另外，人的眼睛对于高频系数，即图像细节，并不会特别敏感。因此，通过量化可以去掉很大一部分小的高频系数。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111614106.png"></p><p>量化是使数据比特率下降的有效工具。量化过程的输入值动态范围很大，需要较多的比特才能表示一个数值，量化后的输出则只需要较小比特表示。<br>量化是不可逆过程，处理过程中有信息丢失，存在量化误差。</p><p>H.264采用标量量化技术，它将每个图像样点编码映射成较小的数值。一般标量量化器的原理为：<br>F Q &#x3D; r o u n d ( y &#x2F; Q P ) FQ&#x3D;round(y&#x2F;QP)FQ&#x3D;round(y&#x2F;QP)<br>其中，y 为输入样本点编码，QP 为量化步长，FQ 为 y 的量化值，round()为取整函数（其输出为与输入实数最近的整数）</p><p>在量化和反量化过程中，量化步长 QP 决定量化器的编码压缩率及图像精度。如果 QP 比较大，则量化值 FQ 动态范围较小，其相应的编码长度较小，数据压缩率高但会损失较多的图像细节信息；如果QP 比较小，则 FQ 动态范围较大，相应的编码长度也较大，但图像细节信息损失较少。编码器根据图像值实际动态范围自动改变 QP 值，在编码码率和图像精度之间折衷，达到整体最佳效果。</p><h3 id="3-6-熵编码"><a href="#3-6-熵编码" class="headerlink" title="3.6 熵编码"></a>3.6 熵编码</h3><p>经过 ZigZag 扫描后，一连串的数字的最后大部分为 0，以及一些 +1,-1。针对这一系列的数字，从概率的角度，再进行一次编码，这个过程称之为熵编码。</p><p>熵编码主要分为 CAVLC，和 CABAC，分别代表基于上下文的自适应可变长编码和基于上下文的自适应二进制算术编码。</p><h4 id="3-6-1-CAVLC"><a href="#3-6-1-CAVLC" class="headerlink" title="3.6.1 CAVLC"></a>3.6.1 CAVLC</h4><p>请参考下述文章</p><blockquote><p><a href="https://cloud.tencent.com/developer/article/1612331?from=article.detail.1612330">编码原理（五）–熵编码–CAVLC</a></p></blockquote><ul><li>非零系数的数目（TotalCoeffs）: 代表 ZigZag 扫描后序列中非 0 值的个数；         </li><li>拖尾系数的数目（TrailingOnes）:指 Z 扫描后，末尾高频信号中出现连续1或-1的个数（中间可以隔任意多个0），拖尾系数最多有5个。当连续1或-1的个数超过3个，只有最后3个1或-1是拖尾系数，其他的当作普通的非零系数。</li><li>TotalZeros: 最后一个非零系数前零的数目；        </li><li>nC：用来决策 coeff 如何编码的变量；        </li><li>ZerosLeft: 当前系数之前所有的 0 的个数；        </li><li>RunBefore: 紧邻当前系数的0的个数；</li></ul><hr><p>利用相邻已编码符号所提供的相关性，为索要编码的符号选择合适的上下文模型。</p><p>利用合适的上下文模型，就可以大大降低符号间的冗余度。</p><p>TotalCoeffs 和 TrailingOnes 通过查表方式进行编码，H.264 针对 TotalCoeffs 和 TrailingOnes，提供了 4 张变长表和 1 张定长表（部分见附表9-5）。</p><p>编码表的选择是由NC确定的，NC的值是由上下文信息确定的。对于色度直流信号，NC&#x3D;-1；对于其他的NC，根据当前块左边4x4块和上面4x4块的非零系数的个数A和B决定。如表一：其中X表示该块与当前块属于同一slice且可用。根据NC选择编码表的策略如表二：</p><blockquote><p>非零系数主要集中在低频部分，高频系数大部分为零，量化后经过 zig-zag 编码。</p><p>非零系数的幅值通常在靠近DC（即直流分量）部分较大，而在高频部分较小；</p><p>上下文模型主要体现在：非零系数编码所需表格和拖尾系数后缀长度的更新。</p><p>CAVLC 以 zig-zag 顺序用于对变换后的残差块进行编码。</p><p>CAVLC 是 CABAC 的替代品，虽然其压缩效率不如 CABAC，但 CAVLC 实现简单，并且在所有的 H.264 profile 中都支持。</p><p>通过 根据已编码句法元素的情况动态调整编码中使用的码表，取得了极高的压缩比。</p></blockquote><h4 id="3-6-2-CABAC"><a href="#3-6-2-CABAC" class="headerlink" title="3.6.2 CABAC"></a>3.6.2 CABAC</h4><ul><li><a href="http://lazybing.github.io/blog/2017/09/12/video-coding/">http://lazybing.github.io/blog/2017/09/12/video-coding/</a></li></ul><h2 id="四、H-264-码流分层"><a href="#四、H-264-码流分层" class="headerlink" title="四、H.264 码流分层"></a>四、H.264 码流分层</h2><h3 id="4-1-VCL-amp-NAL"><a href="#4-1-VCL-amp-NAL" class="headerlink" title="4.1 VCL &amp; NAL"></a>4.1 VCL &amp; NAL</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111614098.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111614769.png"></p><ul><li><p>H.264 的功能分为两层，即视频编码层（VCL）和网络提取层（NAL，Network Abstraction </p><p>Layer）。</p></li><li><p>VCL Layer 將 vidoe image 分割為許多的 slices，這此slice在分成許多的NALU傳送出去</p></li><li><p>VCL 数据即编码处理的输出，它表示被压缩编码后的视频数据序列。在 VCL 数据传输或存</p><p>储之前，这些编码的 VCL 数据，先被映射或封装进 NAL 单元中。</p><p>每个 NAL 单元包括一个原始字节序列负荷（RBSP）、一组对应于视频编码数据的 NAL 头信息。</p><p>NAL 单元序列的结构见图 6.6 </p></li><li><p><strong>切片头</strong>：包含了一组片的信息，比如片的数量，顺序等等</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111615356.png"></p><p>H.264从层次来看分为两层：视频编码层（VCL， Video Coding Layer）和网络提取层（NAL，Network Abstraction Layer）。VCL输出的是原始数据比特流（SODB，String of data bits），表示H.264的语法元素编码完成后的实际的原始二进制码流。</p><p>SODB通常不能保证字节对齐,故需要补齐为原始字节序列负荷（RBSP，Raw Byte Sequence Payload）。NAL层实际上就是最终输出的H.264码流，它是由一个个NALU组成的，每个NALU包括一组对应于视频编码数据的NAL头信息和一个原始字节序列负荷（RBSP，Raw Byte Sequence Payload）。以上名词之间的关系如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">RBSP</span> = SODB + RBSP trailing bits<br><span class="hljs-attr">NALU</span> = NAL header(<span class="hljs-number">1</span> byte) + RBSP<br><span class="hljs-attr">H.264</span> = Start Code Prefix(<span class="hljs-number">3</span> bytes) + NALU + Start Code Prefix(<span class="hljs-number">3</span> bytes) + NALU +…<br></code></pre></td></tr></table></figure><p>所以H.264码流的结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111615200.png"></p><p>NALU (Nal Unit) &#x3D; NALU头 + RBSP 在 VCL</p><p>数据传输或存储之前，这些编码的 VCL 数据，先被映射或封装进 NAL 单元(以下简称 NALU，Nal Unit) 中。每个 NALU 包括一个原始字节序列负荷(RBSP, Raw Byte Sequence Payload)、一组 对应于视频编码的 NALU 头部信息。RBSP 的基本结构是:在原始编码数据的后面填加了结尾 比特。一个 bit“1”若干比特“0”，以便字节对齐。</p><p>一个原始的 H.264 NALU 单元常由 [StartCode] [NALU Header] [NALU Payload] 三部分组成。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111615327.png"></p><ul><li>StartCode : Start Code 用于标示这是一个NALU 单元的开始，必须是”00 00 00 01” 或”00 00 01”（Annex B码流格式才必须是”00 00 00 01” 或”00 00 01”）</li></ul><p><strong>下表为 NAL Header Type</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211111615707.png"></p><h3 id="4-2-码流格式"><a href="#4-2-码流格式" class="headerlink" title="4.2 码流格式"></a>4.2 码流格式</h3><p>H.264 标准中指定了视频如何编码成独立的包，但如何存储和传输这些包却未作规范，虽然标准中包含了一个 Annex 附件，里面描述了一种可能的格式 Annex B，但这并不是一个必须要求的格式。<br>为了针对不同的存储传输需求，出现了两种打包方法。一种即 Annex B 格式，另一种称为 AVCC 格式。</p><ul><li>Annex B<br>从上文可知，一个 NALU 中的数据并未包含他的大小（长度）信息，因此我们并不能简单的将一个个 NALU 连接起来生成一个流，因为数据流的接收端并不知道一个 NALU 从哪里结束，另一个 NALU 从哪里开始。<br>Annex B格式用起始码（Start Code）来解决这个问题，它在每个 NALU 的开始处添加三字节或四字节的起始码 0x000001 或 0x00000001。通过定位起始码，解码器就可以很容易的识别NALU的边界。<br>当然，用起始码定位NALU边界存在一个问题，即NALU中可能存在与起始码相同的数据。为了防止这个问题，在构建 NALU时，需要将数据中的0x000000，0x000001,0x000002,0x000003 中插入防竞争字节（Emulation Prevention Bytes) 0x03，使其变为：<br>0x000000 &#x3D; 0x0000 03 00<br>0x000001 &#x3D; 0x0000 03 01<br>0x000002 &#x3D; 0x0000 03 02<br>0x000003 &#x3D; 0x0000 03 03<br>解码器在检测到 0x000003 时，将 0x03 抛弃，恢复原始数据。</li></ul><p>由于 Annex B 格式每个 NALU 都包含起始码，所以解码器可以从视频流随机点开始进行解码，常用于实时的流格式。在这种格式中通常会周期性的重复 SPS 和PPS，并且经常时在每一个关键帧之前。</p><h3 id="4-3-H264的传输"><a href="#4-3-H264的传输" class="headerlink" title="4.3 H264的传输"></a>4.3 H264的传输</h3><p> <strong>H264是一种码流</strong> 类似与一种不见头，也不见尾的一条<strong>河流</strong>。如何从和流中取到自己想要的<strong>数据</strong>呢，</p><p>在H264的标砖中有这样的一个封装格式叫做”Annex-B”的字节流格式。 它是H264编码的主要字节流格式。</p><p>几乎市面上的编码器是以这种格式进行输出的。<strong>起始码 0x 00 00 00 01 或者 0x 00 00 01</strong> 作为<strong>分隔符</strong>。</p><p>两个 0x 00 00 00 01之间的字节数据 是表示一个NAL Unit</p><p>宏快作为压缩视频的最小的一部分，需要被组织，然后在网络之间做相互传输。</p><p> 如果单纯的用 <strong>宏快</strong> 来发送数据是 <strong>杂乱无章</strong> 的，就好像在没有 <strong>集装箱</strong> 出现之前，货物总是随意被堆放到船上。</p><p>上货（编码），下货是非常痛苦的。 当集装箱出现之后，一切都发生了改变，传输效率大大增高。</p><p> 集装箱可以理解成 <strong>H264编码标准</strong>，他制定了相互传输的格式，将宏快 有组织，有结构，有顺序的形成一系列的码流。这种码流既可 通过 InputStream 网络流的数据进行传输，也可以封装成一个文件进行保存。</p><h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><p>[1] <a href="https://blog.csdn.net/LuohenYJ/article/details/84957101">YUV图像处理入门1</a></p><p>[2] <a href="https://blog.51cto.com/u_15375308/4010325">H264编码(帧内预测)</a></p><p>[3] <a href="https://www.cnblogs.com/Lxk0825/p/9927757.html">H.264编码profile &amp; level控制</a></p><p>[4] <a href="https://blog.csdn.net/wuqingsen1/article/details/118030223">帧内压缩与帧间压缩</a></p><p>[5] <a href="https://www.cnblogs.com/Lxk0825/p/9925064.html">H.264分层结构与码流结构</a></p><p>[6] <a href="https://blog.csdn.net/Liu1314you/article/details/77185215">H.264中普通I帧和IDR帧究竟有什么区别</a></p><p>[7] <a href="https://www.cnblogs.com/AndyJee/p/3724917.html">运动补偿与运动估计</a></p><p>[8] <a href="http://www.elkpi.com/topics/2016/04/color-formats-equasys-gmbh.html">Color Formats – equasys GmbH</a></p><p>[9] <a href="http://blog.gitdns.org/2017/03/14/h264/">h264</a></p><p>[10] <a href="https://yumichan.net/video-processing/video-compression/introduction-to-h264-2-sodb-vs-rbsp-vs-ebsp/">Introduction to H.264: (2) SODB vs RBSP vs EBSP</a></p><p>[11] <a href="https://www.cnblogs.com/Lxk0825/p/9925041.html">H.264基本原理与编码流程</a></p><p>[12] <a href="https://blog.51cto.com/u_15077549/3366546">【知识点】H264, H265硬件编解码基础及码流分析</a></p><p>[13] <a href="https://pjchender.dev/webdev/webrtc-media-basic/#%E4%BB%80%E9%BA%BC%E6%98%AF%E7%B7%A8%E8%A7%A3%E7%A2%BC%E5%99%A8">[Media] 影音傳輸-基礎知識_GOP&#x2F;视频基础</a></p><p>[14] <a href="https://blog.51cto.com/u_15375308/5073333">深入讲解音视频编码原理，H264码流详解——手写H264编码器</a></p><p>[15] <a href="https://cloud.tencent.com/developer/article/1612330">编码原理（四）—ZIGZAG扫描</a></p><p>[16] <a href="https://blog.csdn.net/qq_42139383/article/details/118334630">一文搞懂H264量化原理以及计算过程</a></p>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>H264</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DSP 学习笔记｜（七）HiFi 汇编说明</title>
    <link href="/posts/ekff.html"/>
    <url>/posts/ekff.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、储备知识"><a href="#一、储备知识" class="headerlink" title="一、储备知识"></a>一、储备知识</h2><h3 id="汇编构成"><a href="#汇编构成" class="headerlink" title="汇编构成"></a>汇编构成</h3><p>基本上 assembly source 由以下三个部分組成，</p><ul><li>instruction set</li><li>assembler syntax</li><li>directive</li></ul><p>Instruction set 基本上对于相同的 CPU 来说是固定的，比较不会随着 assembler 不同。</p><p>每個 CPU 可能會有不同 version 的 <a href="http://en.wikipedia.org/wiki/List_of_instruction_sets">instruction set architecture (ISA) </a>如，</p><ul><li>ARMv6</li><li>ARMv7-A</li><li>ARMv7-M</li><li>MIPS32r2 等等，及每一個 version 可能有不同的 extension 如，</li><li>Thumb2</li><li>Neon</li></ul><p>Assembler syntax 每個不同的 assembler 會有一些自訂的語法，如 symbol 的標記方式、 include header 、如何宣告資料、 註解格式等，請參閱各自的 toolchain 的說明文件。</p><h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><p>理解汇编首先且最重要的事就是明白汇编代码与代码之间是如何交互的。函数如何调用其他函数。包括参数是如何传递给函数，及函数返回值是如何返回的。</p><p>这些事情执行的过程与实现被称为调用约定（Calling Conventions）。编译器必须遵循它预定义的标准，这样才能让编译后的代码能和其他不同编译器编译出的代码能够交互。没有标准，编译器能编译出不相配的代码。</p><p>如上讨论，寄存器是和 CPU 联系非常紧密的一小块内存，经常用于存储一些正在使用的数据。</p><blockquote><p>函数的调用过程中有两个参与者，一个是调用方 caller，另一个是被调用方 callee。</p><p>调用约定规定了 caller 和 callee 之间如何相互配合来实现函数调用，具体包括的内容如下：</p><p>函数的参数存放在哪的问题。是放在寄存器中？还是放在栈中？放在哪个寄存器中？放在栈中的哪个位置？<br>函数的参数按何种顺序传递的问题。是从左到右将参数入栈，还是从右到左将参数入栈？<br>返回值如何传递给 caller 的问题。是放在寄存器里面，还是放在其他地方？</p></blockquote><p>ARM处理器有16个寄存器，从r0到r15，每一个都是32位比特。调用约定指定他们其中的一些寄存器有特殊的用途，例如：</p><ul><li>r0-r3：用于存放传递给函数的参数；</li><li>r4-r11：用于存放函数的本地参数；</li><li>r12：是内部程序调用暂时寄存器。这个寄存器很特别是因为可以通过函数调用来改变它；</li><li>r13：栈指针sp(stack pointer)。在计算机科学内栈是非常重要的术语。寄存器存放了一个指向栈顶的指针。看这里了解更多关于栈的信息；</li><li>r14：是链接寄存器lr(link register)。它保存了当目前函数返回时下一个函数的地址；</li><li>r15：是程序计数器pc(program counter)。它存放了当前执行指令的地址。在每个指令执行完成后会自动增加；</li></ul><p>你可以在 ARM 文档里了解更多关于 ARM 调用约定的信息。苹果也在文档【iOS开发调用约定】内有做过详细描述。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062022892.png" alt="image-20220818201922094"></p><h2 id="二、汇编指示（assembly-directive）"><a href="#二、汇编指示（assembly-directive）" class="headerlink" title="二、汇编指示（assembly directive）"></a>二、汇编指示（assembly directive）</h2><ul><li>类似 <code>_main:</code> 或<code>Ltmp0: </code> 的形式被称之为标签（label）, 用于辅助定位代码或者资源地址, 便于开发者理解和记忆；</li><li>类似 <code>pushq </code>或 <code>movq</code>的形式被称之为汇编指令, 它们会被汇编器编译为机器代码, 最终被 CPU 所执行；</li><li>类似 <code>.section</code> 或 <code>.globl </code> 等以 <code>.</code> 开头的形式被称之为编译器指令（assembly directive）, 用于告知编译器相关的信息或者进行特定操作。他们不是汇编指令而是作用于汇编器的，可以忽略所有这样的代码；</li><li>关于 directive 和 instruction 这两个词的区别，前者翻译为指示，后者翻译成指令。因为一般 directive 并不会产生代码而是指示编译器的一些行为，而 instruction 则会产生实际的代码；</li></ul><h3 id="loc-5-76-49"><a href="#loc-5-76-49" class="headerlink" title=".loc 5 76 49"></a>.loc 5 76 49</h3><p>**eg. **</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062024593.png" alt="image-20221106202447549"></p><p><strong>说明：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062025851.png" alt="image-20221106202535805"></p><ul><li>fileno : 文件描述符</li><li>lineno : 行号</li><li>colum：列数（操作符的位置）</li></ul><h3 id="literal-position"><a href="#literal-position" class="headerlink" title=".literal_position"></a>.literal_position</h3><p><strong>eg.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062026045.png" alt="image-20221106202654001"></p><p><strong>说明：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062027133.png" alt="image-20221106202729103"></p><h3 id="p2align"><a href="#p2align" class="headerlink" title=".p2align"></a>.p2align</h3><p><strong>eg.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062027550.png" alt="image-20221106202759522"></p><p><strong>说明：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062028692.png" alt="image-20221106202825671"></p><p>p2align 3 表示 2 的 3 次幂 &#x3D; 8</p><p>p2align 2 表示 2 的  2 次幂 &#x3D; 4</p><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名_"></a><em>函数名</em>_</h3><p><strong>eg.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062028708.png" alt="image-20221106202846674"></p><p>编译器通常在函数名的前面添加一个下划线。</p><h3 id="cfi-startproc"><a href="#cfi-startproc" class="headerlink" title=".cfi_startproc"></a>.cfi_startproc</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062029324.png" alt="image-20221106202911293"></p><p><strong>eh_frame：</strong>GCC Exception <a href="https://so.csdn.net/so/search?q=Frame&spm=1001.2101.3001.7020">Frame</a>，也就是eh_frame。这里提到 eh_frame 是 dwarf 调试信息的变体（variant）。eh_frame 段中存储着跟函数入栈相关的关键数据。当函数执行入栈指令后，在该段会保存跟入栈指令一一对应的编码数据，根据这些编码数据，就能计算出当前函数栈大小和cpu的哪些寄存器入栈了，在栈中什么位置。</p><h3 id="cfi-def-cfa"><a href="#cfi-def-cfa" class="headerlink" title=".cfi_def_cfa"></a>.cfi_def_cfa</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062029324.png"></p><h3 id="cfi-def-cfa-offset"><a href="#cfi-def-cfa-offset" class="headerlink" title=".cfi_def_cfa_offset"></a>.cfi_def_cfa_offset</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062029935.png" alt="image-20221106202947900"></p><h3 id="prologue-end"><a href="#prologue-end" class="headerlink" title="prologue_end"></a>prologue_end</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062030883.png" alt="image-20221106203003854"></p><h3 id="type"><a href="#type" class="headerlink" title=".type"></a>.type</h3><p><strong>eg.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062030101.png" alt="image-20221106203029065"></p><p>汇编里面所有以 <code>:</code> 结尾的都会视为标签 ( <code>label</code> )，在这里我们定义一个叫做 <code>main</code> 的标签，并且使用 <code>.type</code> 伪指令定义这个标签的类型是一个函数(<code>function</code>)，到此我们就定义了我们的 <code>main</code> 函数。</p><p><strong>说明：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062030010.png" alt="image-20221106203044974"></p><h3 id="Ltmp："><a href="#Ltmp：" class="headerlink" title=".Ltmp："></a>.Ltmp：</h3><p>标签，不是指令。是这部分的汇编代码名字。</p><h3 id="is-stmt"><a href="#is-stmt" class="headerlink" title="is_stmt"></a>is_stmt</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062031682.png" alt="image-20221106203108647"></p><p>此选项会将 .debug_line 状态机中的 is_stmt 寄存器设置为 value，该值必须为 0 或 1。</p><h3 id="L32R"><a href="#L32R" class="headerlink" title="L32R"></a>L32R</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062031375.png" alt="image-20221106203139344"></p><p>L32R 指令从指定地址加载 32 位值。因此，“l32r a2，2ec8” 将地址 0x2ec8 处的 32 位值加载到寄存器 a2 中。</p><h3 id="L-本地标签"><a href="#L-本地标签" class="headerlink" title="L. 本地标签"></a>L. 本地标签</h3><p><strong>eg.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062032854.png" alt="image-20221106203207817"></p><p>所有以 <code>L.</code> 开头的都为本地标签，这些标签只能用于函数内部。</p><h3 id="Ⅱ-1-0"><a href="#Ⅱ-1-0" class="headerlink" title="[Ⅱ *1+0]"></a>[Ⅱ *1+0]</h3><p><strong>eg.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062033476.png" alt="image-20221106203305432"></p><p>[Ⅱ * 1 + 0]</p><p><strong>Ⅱ</strong>：数字乘以 II 符号表示正在执行的迭代；</p><p><strong>1</strong>：乘 1 代表在第二次迭代中的运算，乘 0 就代表在第一次迭代中的运算；</p><p><strong>0</strong>：最后的数字代表该指令处于第几个 cycle 中。</p><h3 id="指示参考表（节选）"><a href="#指示参考表（节选）" class="headerlink" title="指示参考表（节选）"></a>指示参考表（节选）</h3><table><thead><tr><th>GNU Assembler Directive</th><th align="center">Note</th></tr></thead><tbody><tr><td>.text</td><td align="center">Tells <code>as</code> to assemble the following statements onto the end of the text subsection numbered subsection, which is an absolute expression. If subsection is omitted, subsection number zero is used.</td></tr><tr><td>.file</td><td align="center"><code>.file</code> (which may also be spelled <code>.app-file&#39;) tells </code>as<code>that we are about to start a new logical file. string is the new file name. In general, the filename is recognized whether or not it is surrounded by quotes</code>“‘;</td></tr><tr><td>.globl</td><td align="center"><code>.global</code> makes the symbol visible to <code>ld</code>. If you define symbol in your partial program, its value is made available to other partial programs that are linked with it. Otherwise, symbol takes its attributes from a symbol of the same name from another file linked into the same program.</td></tr><tr><td>.p2align</td><td align="center">Pad the location counter (in the current subsection) to a particular storage boundary. The first expression (which must be absolute) is the number of low-order zero bits the location counter must have after advancement. For example &#96;.p2align 3’ advances the location counter until it a multiple of 8. If the location counter is already a multiple of 8, no change is needed.</td></tr><tr><td>.section</td><td align="center">Use the <code>.section</code> directive to assemble the following code into a section named name.</td></tr><tr><td>.asciz</td><td align="center"><code>.asciz</code> is just like <code>.ascii</code>, but each string is followed by a zero byte. The “z” in &#96;.asciz’ stands for “zero”.</td></tr></tbody></table><h2 id="三、调用约定"><a href="#三、调用约定" class="headerlink" title="三、调用约定"></a>三、调用约定</h2><blockquote><p>调用约定，即调用 Call0 ABI 和窗口 ABI，在 <em>Xtensa Instruction Set Architecture (ISA) Reference Manual</em> 中进行了更广泛的描述。</p></blockquote><ul><li><p>Application Binary Interface (ABI) 应用程序二进制接口；</p></li><li><p>对于窗口 ABI，入口点上的第一个指令是一个入口指令，它被一个 CALL<em>N</em> 或 CALLX<em>N</em> 指令调用（其中 N 是 4、8 或 12）；</p></li><li><p>第二个入口点总是实现调用 call0 ABI，入口点将用 CALL0 指令调用，并将使用 RET 指令返回。</p></li></ul><p><strong>eg.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062033682.png" alt="image-20221106203349642"></p><p><strong>👇 call4，call8，call12 列对应窗口 ABI</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202211062034087.png" alt="image-20221106203416052"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] Optimizing Code for HiFi Audio Engines</p><p>[2] Using as（The GNU Assembler）</p><p>[3] Xtensa® System Software Reference Manual</p><p>[4] <a href="https://blog.csdn.net/weixin_39822728/article/details/111197567?utm_term=%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81Ltmp%E6%A0%87%E7%AD%BE&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-111197567-null-null&spm=3001.4430">arm汇编指令_iOS汇编ARM教程</a></p><p>[5] <a href="https://blog.csdn.net/W15242345526/article/details/126127334?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166080560516781685398459%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166080560516781685398459&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-126127334-null-null.142%5Ev41%5Econtrol,185%5Ev2%5Econtrol&utm_term=%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81Ltmp%E6%A0%87%E7%AD%BE&spm=1018.2226.3001.4187">C程序设计语言的汇编解释（第一章节，一些实例）</a></p><p>[6] <a href="https://zhuanlan.zhihu.com/p/388683540">ARM汇编入门指南</a></p><p>[7] <a href="https://www.quora.com/What-is-the-difference-between-an-instruction-and-a-directive-in-assembly-language">What is the difference between an instruction and a directive in assembly language?</a></p><p>[8] <a href="https://www.cntofu.com/book/46/assembly/yue_du_assembly_code.md">Reading assembly code</a></p><p>[9] <a href="https://blog.csdn.net/qq_29328443/article/details/107232025">x86_64汇编之四：函数调用、调用约定</a></p><p>[10] <a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODUxNDMxMA==&mid=2247488571&idx=1&sn=452d68c7a3ea182666e1f913e2f3e62d&chksm=c06038d2f717b1c4b078784ca0d911ac97cc0b75539755c00a4ccc7c74e1b6d5336289ae9989&token=570592262&lang=zh_CN#rd">函数调用时栈是如何变化的？</a></p>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DSP 学习笔记｜（六）DSP 中的定点 &amp; 浮点</title>
    <link href="/posts/awfs.html"/>
    <url>/posts/awfs.html</url>
    
    <content type="html"><![CDATA[<h2 id="DSP-中的定点与浮点转换"><a href="#DSP-中的定点与浮点转换" class="headerlink" title="DSP 中的定点与浮点转换"></a>DSP 中的定点与浮点转换</h2><p>​许多 DSP 都是定点 DSP，处理定点数据会相当快，但是处理浮点数据就会非常慢。可以利用 Q 格式进行浮点数据到定点的转化，节约 CPU 时间。实际应用中，浮点运算大都时候都是既有整数部分，也有小数部分的。所以要选择一个适当的定标格式才能更好的处理运算。</p><p>​Q 格式表示为：Qm.n，表示数据用 m 比特表示整数部分，n 比特表示小数部分，共需要 m+n+1 位来表示这个数据，多余的一位用作符合位。假设小数点在 n位的左边（从右向左数），从而确定小数的精度</p><p>​例如 Q15 表示小数部分有 15 位，一个 short 型数据，占 2 个字节，最高位是符号位，后面 15 位是小数位，就假设小数点在第 15 位左边，表示的范围是：-1 &lt; X &lt; 0.9999695 。</p><p>​浮点数据转化为 Q15，将数据乘以 2^15；Q15 数据转化为浮点数据，将数据除以 2^15。</p><p>​例如：假设数据存储空间为 2 个字节，0.333×2^15&#x3D;10911&#x3D;0x2A9F，0.333 的所有运算就可以用 0x2A9F 表示，同理 10911×2^(-15)&#x3D;0.332977294921875，可以看出浮点数据通过 Q 格式转化后是有误差的。</p><p>​例：两个小数相乘，0.333*0.414&#x3D;0.137862</p><p>　　0.333 * 2^15&#x3D;10911&#x3D;0x2A9F，0.414 * 2^15&#x3D;13565&#x3D;0x34FD</p><p>　　short a &#x3D; 0x2A9F;</p><p>　　short b &#x3D; 0x34FD;</p><p>　　short c &#x3D; a * b &gt;&gt; 15;　　&#x2F;&#x2F; 两个 Q15 格式的数据相乘后为 Q30 格式数据，因此为了得到 Q15 的数据结果需要右移 15 位</p><p>​这样 c 的结果是 0x11A4 &#x3D; 0001000110100100，这个数据同样是 Q15 格式的，它的小数点假设在第 15 位左边，即 0.001000110100100 &#x3D; 0.1378173828125… 和实际结果 0.137862 差距不大。或者 0x11A4 &#x2F; 2^15 &#x3D; 0.1378173828125</p><h2 id="Q-格式的运算"><a href="#Q-格式的运算" class="headerlink" title="Q 格式的运算"></a>Q 格式的运算</h2><ul><li>定点加减法：须转换成相同的 Q 格式才能加减 </li><li>定点乘法：不同 Q 格式的数据相乘，相当于 Q 值相加，即 Q15 数据乘以 Q10 数据后的结果是 Q25 格式的数据</li><li>定点除法：不同 Q 格式的数据相除，相当于 Q 值相减</li><li>定点左移：左移相当于 Q 值增加</li><li>定点右移：右移相当于 Q 减少</li></ul><h2 id="Q-格式的应用格式"><a href="#Q-格式的应用格式" class="headerlink" title="Q 格式的应用格式"></a>Q 格式的应用格式</h2><p>​实际应用中，浮点运算大都时候都是既有整数部分，也有小数部分的。所以要选择一个适当的定标格式才能更好的处理运算。一般用如下两种方法：</p><ol><li>使用时使用适中的定标，既可以表示一定的整数复位也可以表示小数复位，如对于 2812 的 32 位系统，使用 Q15 格式，可表示－65536.0～65535.999969482 区间内的数据。</li><li>全部采用小数，这样因为小数之间相乘永远是小数，永远不会溢出。取一个极限最大值（最好使用 2 的 n 次幂），转换成 x&#x2F;Max 的小数（如果 Max 是取的 2 的 n 次幂，就可以使用移位代替除法）。</li></ol><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p>​支持浮点运算的DSP就是浮点DSP芯片，在这种片子上可以自由进行小数运算。而在定点DSP上是不能直接进行小数运算的，需要先给数值定标，且这个小数点不可移动。</p><p>​因此，定点DSP完成小数运算时，编程稍微复杂一点。速度肯定就不如浮点的片子了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://blog.csdn.net/messi_cyc/article/details/77934566">Q格式（Q15）DSP上浮点数据定点化处理</a></p></li><li><p><a href="https://blog.csdn.net/cuiweitju/article/details/39395715">定点DSP与浮点DSP的比较（定点DSP和浮点DSP的定义）</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1670449">一文教你搞懂C语言的Q格式</a></p></li><li><p><a href="https://www.796t.com/content/1549700470.html">DSP中的定點運算</a></p></li><li><p><a href="https://www.daimajiaoliu.com/daima/479b6a503900409">DSP学习笔记（二）——DSP中浮点数与定点数格式与运算处理</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于 valine 评论插件失效记录</title>
    <link href="/posts/f86f.html"/>
    <url>/posts/f86f.html</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>博客底部的 valine 评论插件无法正常显示。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在使用 <code>F11</code> 打开网页控制窗口，可以看到 valine 相关的连接出错。</p><p>ERR_CONNECTION_REFUSED 问题</p><div class="note note-success">            <p>判断是否为 DNS 劫持的方法</p><ul><li>ping 自己的 REST API 服务器地址（xxxxx 为 自己 AppID 的前 8 位字符）<br>（如果 ping xxxxxxxx.api.lncldglobal.com 域名指向 127.0.0.1 可能是 DNS 劫持）</li></ul>          </div><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/Snipaste_2022-07-23_11-24-09.png" alt="Snipaste_2022-07-23_11-24-09"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>修改 DNS</li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/Snipaste_2022-07-23_11-22-25.png" alt="Snipaste_2022-07-23_11-22-25"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/Snipaste_2022-07-23_11-23-18.png" alt="Snipaste_2022-07-23_11-23-18"></p><h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><p>[1] <a href="https://iyichen.xyz/2022/01/hexo-leancloud-valine-access-fail/">Hexo使用国际版LeanCloud Valine评论连接失败</a></p><p>[2] <a href="https://github.com/xCss/Valine/issues/340">国际版域名问题 #340</a></p><p>[3] <a href="https://github.com/DesertsP/Valine-Admin/issues/63">关于时区的一个问题 #63</a></p><p>[4] <a href="https://inktea.xyz/2022/bed6.html">LeanCloud-Valine出现ERR_CONNECTION_REFUSED问题</a></p>]]></content>
    
    
    <categories>
      
      <category>折腾派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DSP 学习笔记 |（五）HiFi 4 User&#39;s Guide 笔记</title>
    <link href="/posts/9860.html"/>
    <url>/posts/9860.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文笔记整理摘自《HiFi4 DSP User’s Guide》。</p>          </div><blockquote><p><strong>先导阅读手册</strong>：</p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095009245.png" alt="image-20220724095009245" style="zoom:80%;" /></blockquote><h2 id="一、-HiFi-4-概述"><a href="#一、-HiFi-4-概述" class="headerlink" title="一、 HiFi 4 概述"></a>一、 HiFi 4 概述</h2><div class="note note-warning">            <ul><li>Cadence HiFi ：Cadence Tensilica HiFi DSP 架构，用于音频解码</li><li>Tensilica：嵌入式处理器公司，已被芯片 EDA 巨头 Cadence 收购</li><li>Xtensa：DSP 处理器核心，也是该系列的型号名称，也是该处理器中指令集架构的名称</li><li>HiFi：特指 32 位音频&#x2F;语音处理数字信号处理 (DSP) 核，基于 Xtensa® 架构</li></ul>          </div><h3 id="1-1-HiFi-4-特点"><a href="#1-1-HiFi-4-特点" class="headerlink" title="1.1 HiFi 4 特点"></a>1.1 HiFi 4 特点</h3><p>HiFi 4 DSP 是一个高性能的嵌入式数字信号处理器，专门为音频和语音处理进行了优化。</p><p>HiFi 4 DSP 由三个主要部件组成：</p><ol><li>一个 DSP 子系统；</li><li>一个可选的单精度浮点单元；</li><li>一个协助比特流访问和变长（Huffman）编解码的子系统。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095035434.png" alt="image-20220724095035434"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095047136.png" alt="image-20220724095047136"></p><ul><li>HiFi 4 DSP 是一个 VLIW 架构，支持并行执行四个操作。</li><li>DSP 的读取、比特流和 Huffman 操作以及核心操作都可以在 VLIW 指令的 0 槽和 1 中，存储仅在槽 0 中可用。DSP MAC、ALU 和可选的浮点操作通常在槽 2 和槽 3 中进行。</li><li>HiFi 4 DSP 是建立在 Xtensa RISC 架构的基础上，它实现了丰富的通用标量指令集，为高效的嵌入式处理进行了优化。</li><li>由 Cadence 提供的音频包不使用 DMA。因此，大多数客户要么使用缓存，要么使本地存储器足够大以覆盖所需的应用。</li></ul><h3 id="1-2-寄存器"><a href="#1-2-寄存器" class="headerlink" title="1.2 寄存器"></a>1.2 寄存器</h3><p><strong>AE_DR 寄存器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095058671.png" alt="image-20220724095058671"></p><ul><li><p>HiFi 4 DSP 包含一个 16 进制 64 位寄存器 AE _ DR。</p></li><li><p>当寄存器被存储到内存中时，寄存器的较高一半总是存储在较低的内存地址中，并从较低的内存地址加载。寄存器的单独的一半或四分之一始终是单独的数据项。 例如，如果将 32 位元素向左移动，则 L 元素不会溢出到高位元素中</p></li></ul><p><strong>AE_EP 寄存器</strong></p><ul><li>HiFi 4 DSP 支持一个 4 进制、8 位的额外精度寄存器 AE_EP。</li><li>该寄存器的访问时间比 AE_D R寄存器晚一个周期。</li></ul><p><strong>AE_VALIGN 寄存器</strong></p><ul><li>HiFi 4 DSP 支持一个 4 进制、64 位的对齐寄存器 AE_VALIGN。</li><li>使用这个寄存器允许硬件以每周期 64 位的速度加载或存储非 64 位对齐的 SIMD 流位&#x2F;周期。</li><li>对齐的加载和存储只存在于槽0中，所以不可能同时发出这些指令。</li></ul><h3 id="1-3-操作助记符"><a href="#1-3-操作助记符" class="headerlink" title="1.3 操作助记符"></a>1.3 操作助记符</h3><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220720152135269.png" alt="image-20220724095113577" style="zoom:150%;" /><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095120543.png" alt="image-20220724095120543" style="zoom:150%;" /><h3 id="1-4-定点数及其运算"><a href="#1-4-定点数及其运算" class="headerlink" title="1.4 定点数及其运算"></a>1.4 定点数及其运算</h3><p>一个定点数的数据类型 <em>m.n</em> 包含一个符号位，在小数点的左边有m-1位，在小数点的右边有n位。</p><p>当表示为一个二进制的时候，最不重要的 n 位是小数部分，最重要的 m 位是整数部分。</p><h3 id="1-5-VLIW-槽及格式"><a href="#1-5-VLIW-槽及格式" class="headerlink" title="1.5 VLIW 槽及格式"></a>1.5 VLIW 槽及格式</h3><p>HiFi 4 DSP 可以在一个 88 位的指令束中发出 4 个操作，或在一个 48 位的指令束中发出 2 个操作。使用 Xtensa LX FLIX (VLIW) 技术，HiFi 4 DSP 支持几种不同的格式，有不同的插槽限制。每条指令都属于一种格式，但不同的格式可以在一条指令中打包不同数量的操作。</p><ul><li>第一个插槽支持标量与矢量的 <strong>读取与写入</strong>，以及 <strong>标量 Xtensa 操作</strong>；</li><li>第二个插槽支持标量与矢量的 <strong>读取与写入</strong>，以及 <strong>矢量 Xtensa 操作</strong>；</li><li>最后两个插槽主要支持 <strong>矢量逻辑运算</strong> 与 <strong>矢量乘法运算</strong>。</li></ul><p>对于可选择的浮点单元来说，大多数浮点操作都可在 slot 3 和 slot 4 中进行。</p><p><strong>在优化 HiFi 4 DSP 代码中理解开槽的概念是十分重要的。</strong>循环通常受到只能进入一个或另一个槽的操作的限制。例如，每个周期不可能发出一个以上的（可能的SIMD）存储。如果一个循环被一个槽中的操作所限制，那么试图优化另一个槽中的操作就没有意义了。 </p><h2 id="二、DSP-编程"><a href="#二、DSP-编程" class="headerlink" title="二、DSP 编程"></a>二、DSP 编程</h2><div class="note note-info">            <ul><li>HiFi 4 DSP 每个周期提供四个 MAC。 它提供对整数和小数运算的等效支持。</li><li>不利用 SIMD 的应用程序的运行速度将比利用 SIMD 的应用程序慢 4 倍。</li><li>对于 24 位和 32x16 位的应用程序，编译器不会自动矢量化。应用程序编写器必须使用显示矢量数据类型或内部函数来编写代码。</li></ul>          </div><h3 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h3><ul><li>HiFi 4 DSP 支持 16、24、32 以及 64 位的数据类型。所有类型都包含整数与分数版本。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095144861.png" alt="image-20220724095144861"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095156736.png" alt="image-20220724095156736"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095206371.png" alt="image-20220724095206371"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095217319.png" alt="image-20220724095217319"></p><h3 id="2-2-编码与解码"><a href="#2-2-编码与解码" class="headerlink" title="2.2 编码与解码"></a>2.2 编码与解码</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095229654.png" alt="image-20220724095229654"></p><h3 id="2-3-基于内嵌函数编程"><a href="#2-3-基于内嵌函数编程" class="headerlink" title="2.3 基于内嵌函数编程"></a>2.3 基于内嵌函数编程</h3><p>每条 HiFi 4 DSP 指令都可以通过一个相同名称的内部函数直接访问，除了 “.” 需要全部变成 “_”。</p><h2 id="三、HiFi-4-指令集"><a href="#三、HiFi-4-指令集" class="headerlink" title="三、HiFi 4 指令集"></a>三、HiFi 4 指令集</h2><ul><li><p>对于矢量读取和写入，<strong>内存中的高位地址总是存储在寄存器中的最小有效位</strong>。</p></li><li><p>HiFi 4 DSP 还支持两个圆形缓冲区，可用于对齐或不对齐的数据。</p></li><li><p>虽然向量变量不需要被对齐到 64位，但它们仍然必须根据每个标量元素的要求进行对齐，例如32位的向量的 ints。</p></li><li><p>AE_LA64.PP 是一个特殊的初始化指令，这条指令将数据从数据流的起点加载到对齐寄存器中。对齐指令工作的具体细节与程序员无关。只要调用 AE_LA64_PP 引导内在的第一个要加载的地址（不管是否对齐），然后用适当的对齐加载继续加载。</p></li><li><p>大多数读取和写入操作的助记符包含一个尺寸，表示操作符的大小；</p></li><li><p>大多数加载和存储操作的助记符包含一个后缀，<strong>表示如何计算有效地址以及是否更新基址寄存器</strong>。</p></li><li><p>定点数 1.31, 是指令里面操作的数据类型，int 之后，还有按照指令规范的类型来转换。</p><p>int &#x3D; 2, 在经过 1.31 后，二进制，000….10（32位）。如果是负数，第一位是符号位，补码形式。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095242956.png" alt="image-20220724095242956"></p><h3 id="3-1-读取与写入操作"><a href="#3-1-读取与写入操作" class="headerlink" title="3.1 读取与写入操作"></a>3.1 读取与写入操作</h3><ul><li><p>load 是将内存里面的值读取到寄存器（CPU 内部的存储单元）。如果都是放在寄存器的，寄存器哪有那么多地方给你存东西？</p></li><li><p>store 是将寄存器里面的值写入到内存。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095252488.png" alt="image-20220724095252488"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将数组a的值赋值给数字b，分别使用load和store指令</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span><br>&#123;<br><span class="hljs-comment">// 初始化数据</span><br><span class="hljs-type">short</span> a[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">short</span> b[<span class="hljs-number">4</span>];<br>ae_int16x4 *ap = (ae_int16x4 *) &amp;a[<span class="hljs-number">0</span>];<br>ae_int16x4 *bp = (ae_int16x4 *) &amp;b[<span class="hljs-number">0</span>];<br>ae_int16x4 src;<br><span class="hljs-comment">// load：先读取内存中的值到寄存器</span><br>AE_L16X4_IP(src, ap, <span class="hljs-number">8</span>);<br><span class="hljs-comment">// store: 将数组a中的值存到数组b中</span><br><span class="hljs-comment">//AE_SA16x4_IP (src, ae_valign u, *ap);</span><br>AE_S16X4_IP(src, bp, <span class="hljs-number">8</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, b[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-乘积累加操作"><a href="#3-2-乘积累加操作" class="headerlink" title="3.2 乘积累加操作"></a>3.2 乘积累加操作</h3><p>乘积累加运算 （ 英语：Multiply Accumulate, MAC,）。</p><p>乘法 multiplication、加法 adder、周期 cycle 就是 mac，乘加器，表示一个周期完成一次乘法和加法运算。DSP 的重要性能指标。DSP 的主要工作就是大量的乘加器运算。</p><p>DSP 一个机器指令周期能实现乘加运算，这是 DSP 的精髓。 实现这个运算的内核就是 MAC。 </p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095327286.png" alt="image-20220724095327286"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095339843.png" alt="image-20220724095339843"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095352754.png" alt="image-20220724095352754"></p><p><strong>MAC:</strong></p><p>两个和四个 MAC 操作有两种形式——双 MAC 取两个 MAC 的结果，并将它们加或减，如下示例所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">acc = acc – d0.L*d1.L + d0.H*d1.H<br></code></pre></td></tr></table></figure><p><strong>MACs:</strong><br>SIMD MACs 不结合不同乘数的结果。相反，它们对数据的不同部分执行示例乘法操作，如下示例所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">acc.h = acc.h – d0.h*d1.h<br>acc.l = acc.l – d0.l*d1.l<br></code></pre></td></tr></table></figure><p>高位和低位各算各的，SIMD MACs 将其结果打包为 32 位或 16 位，因此在其名称中使用 P。通过同时添加或减去两个乘法结果，双 MAC 指令能够保持它们的累积精度，而不需要写入多个输出寄存器。</p><ul><li>在单乘法和 SIMD 乘法运算中，每个乘法&#x2F;累加操作系列都有一个仅乘法变体，即乘法&#x2F;加法变体和乘法&#x2F;减法变体，通过将 accum_type 设置为空、A 或 S 来表示分别。 </li><li>使用 MUL 变体，累加器内容会被以下结果覆盖乘法。 使用 MULA 变体，乘法的结果被添加到累加器内容并写回累加器。 使用 MULS 变体，结果从累加器的内容中减去乘法的值并写回累加器。</li><li>accum_type 以 Z 开头的双 MAC 操作是对零进行累加的。换句话说，累积器的初始内容被丢弃。那些没有 Z的操作则是针对累加器的初始内容进行累加。在可选的 Z 后面，有两个字母表示加法或减法，两个乘法结果各一个。</li><li>小数乘法指令在 accum_type 后面有一个 F。</li></ul><p><strong>对称 &amp; 非对称四舍五入</strong></p><ul><li>整数 SIMD 乘法指令扔掉了其结果的高位，就像标准的 C&#x2F;C++乘法。小数 SIMD 乘法指令使用对称或不对称的四舍五入方法，将低位舍去。</li><li>在非对称四舍五入的情况下，两半被向上舍入，即 0.5 倍的最小有效结果位被舍入为 1.0，-0.5 倍的最小有效结果位被舍入为 1.0。即 0.5 倍的最小有效结果位被向上舍入为 1.0，-0.5 倍的最小有效结果位被向上舍入为 0。</li><li>在对称四舍五入的情况下，两个半数从零开始四舍五入，即 -0.5 倍的最小有效结果位四舍五入到 -1.0。</li><li>在指令描述中，对称舍入被称为 round，而非对称舍入被称为 round+∞。</li></ul><p><strong>饱和 &amp; 非饱和乘法</strong></p><p>​执行操作时，某个中间变量的值的范围大于了最终结果的值的类型范围。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">eg. <br>（中间变量值）int32 <span class="hljs-type">int</span> <span class="hljs-number">129</span><br>（最终值）int8 <span class="hljs-title function_">char</span> <span class="hljs-params">(范围：<span class="hljs-number">-128</span> - <span class="hljs-number">127</span>)</span><br> 此时最终值就会溢出，变成 -127，此时与实际值相差很远了。<br> <br>饱和：先做一个判断<br> <span class="hljs-title function_">if</span><span class="hljs-params">(<span class="hljs-type">int</span> &gt; <span class="hljs-number">128</span>)</span><br>     <span class="hljs-type">int</span> = <span class="hljs-number">128</span>;<br> 这样就避免了最后结果会相差很大。<br>    <br></code></pre></td></tr></table></figure><ul><li>没有保护位的小数 MAC 运算，1.31x1.31 到 1.63 或 1.31，1.31x1.15 到 1.31 和 1.15x1.15 到 1.15 或 1.31，使它们的结果饱和。 所有其他 MAC 操作都是完整的或具有保护位且不会饱和。</li><li>饱和乘法有一个 S 跟在大小或四舍五入的名称后面。</li><li>一些 16x16 位乘法器被设计为与 ITU-T&#x2F;ETSI 内在函数，因此串联进行多次饱和。 这些指令的名称中有 SS。</li></ul><p><strong>其他</strong></p><ul><li>无符号乘以无符号的乘法，在其前面有一个 U。无符号乘以有符号 的乘法，在指定符前有一个 US。利用 AE_EP 寄存器文件产生 72 位累加器的乘法运算，在指令前有一个 EP。</li><li><strong>所有 MAC 操作都出现在第三个或第四个插槽中</strong>。 出现在第三个插槽中的任何乘法运算都将具有后缀  _S2。 C&#x2F;C++ 程序员可以忽略后缀。 编译器会在需要时自动将普通乘法转换为 _S2 乘法。</li></ul><h3 id="3-3-加、减与比较操作"><a href="#3-3-加、减与比较操作" class="headerlink" title="3.3 加、减与比较操作"></a>3.3 加、减与比较操作</h3><p>Add, Subtract and Compare Operations</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095415682.png" alt="image-20220724095415682"></p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095438397.png" alt="image-20220724095438397"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095454559.png" alt="image-20220724095454559"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095517115.png" alt="image-20220724095517115"></div></div><div class="group-image-row"></div></div><h3 id="3-4-移位操作"><a href="#3-4-移位操作" class="headerlink" title="3.4 移位操作"></a>3.4 移位操作</h3><p>Shift Operations 移位操作</p><p><strong>所有移位操作都以前缀 AE_S 开始。</strong>下面的字母是 L 或 R，表示主要移位方向是左还是右。下一个字母是 L或 A，表示是逻辑移位（在右移时填入0）还是算术移位（在右移时符号扩展）。下一个字母 I 表示立即移位，A 表示 AR 移位，S 表示 AE_SAR 移位。后面是一个数字，表示被移位的元素的大小，还有一个可选的R表示右移位而不是截断的右移，以及一个可选的 S 表示饱和的左移。</p><h3 id="3-5-归一化操作"><a href="#3-5-归一化操作" class="headerlink" title="3.5 归一化操作"></a>3.5 归一化操作</h3><h3 id="3-6-Divide-Step-操作"><a href="#3-6-Divide-Step-操作" class="headerlink" title="3.6 Divide Step 操作"></a>3.6 Divide Step 操作</h3><h3 id="3-7-截断操作"><a href="#3-7-截断操作" class="headerlink" title="3.7 截断操作"></a>3.7 截断操作</h3><p>Truncate Operations</p><p>AE_TRUNC16X4F32 Operation</p><h3 id="3-8-移动操作"><a href="#3-8-移动操作" class="headerlink" title="3.8 移动操作"></a>3.8 移动操作</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724095531219.png" alt="image-20220724095531219"></p><h2 id="四、-HiFi-4-备忘录"><a href="#四、-HiFi-4-备忘录" class="headerlink" title="四、 HiFi 4 备忘录"></a>四、 HiFi 4 备忘录</h2><h3 id="4-1-HiFi-4-的头文件"><a href="#4-1-HiFi-4-的头文件" class="headerlink" title="4.1 HiFi 4 的头文件"></a>4.1 <strong>HiFi 4 的头文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;xtensa/tie/xt_hifi4.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;xtensa/hal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;xtensa/xtruntime.h&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DSP 学习笔记 |（四）Xtensa ISA 笔记</title>
    <link href="/posts/6ba9.html"/>
    <url>/posts/6ba9.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文笔记主要整理摘自《Xtensa® Instruction Set Architecture (ISA)》。</p>          </div><h2 id="一、-XCC-编译器"><a href="#一、-XCC-编译器" class="headerlink" title="一、 XCC 编译器"></a>一、 XCC 编译器</h2><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724094306520.png" alt="image-20220724094306520"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093233735.png" alt="image-20220724093233735"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093243706.png" alt="image-20220724093243706"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093252702.png" alt="image-20220724093252702"></p><h2 id="二、-Candence-处理器"><a href="#二、-Candence-处理器" class="headerlink" title="二、 Candence 处理器"></a>二、 Candence 处理器</h2><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093310661.png" alt="image-20220724093310661"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093416020.png" alt="image-20220724093416020"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093322357.png" alt="image-20220724093322357"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093348993.png" alt="image-20220724093348993"></p><h2 id="三、-语法"><a href="#三、-语法" class="headerlink" title="三、 语法"></a>三、 语法</h2><h3 id="3-1-数据类型"><a href="#3-1-数据类型" class="headerlink" title="3.1 数据类型"></a>3.1 数据类型</h3><ol><li><p><code>ae_int32x2</code><br>由两个 32 位的数据类型组成一个 64 位的数据，8 字节对齐。如果使用 int 类型强制转换，那么在内存分布上，将是两个相同的 32 位数据，举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> mem1 = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-type">int</span> mem2 = <span class="hljs-number">0x5678</span>;<br>    ae_int32x2 p = mem1;<br><br>    <span class="hljs-type">int</span> *p1 = (<span class="hljs-type">int</span> *)&amp;p;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(int)p = 0x%0x\n&quot;</span>,(<span class="hljs-type">int</span>)p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*(p1) = 0x%0x\n&quot;</span>,*(p1));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*(p1+1) = 0x%0x\n&quot;</span>,*(p1+<span class="hljs-number">1</span>));<br><br>    ae_int32x2 p2 = <span class="hljs-built_in">AE_MOVDA32X2</span>(mem1, mem2);<br>    <span class="hljs-type">int</span> *p3 = (<span class="hljs-type">int</span> *)&amp;p2;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p3=0x%0x,*(p3) = 0x%0x\n&quot;</span>,p3,*(p3));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p3+1=0x%0x,*(p3+1) = 0x%0x\n&quot;</span>,p3+<span class="hljs-number">1</span>,*(p3+<span class="hljs-number">1</span>));<br>&#125;<br><br>输出：<br>    <br>(<span class="hljs-type">int</span>)p = <span class="hljs-number">0x1234</span><br>*(p1) = <span class="hljs-number">0x1234</span><br>*(p1+<span class="hljs-number">1</span>) = <span class="hljs-number">0x1234</span><br>p3=<span class="hljs-number">0x2ffffeb8</span>,*(p3) = <span class="hljs-number">0x1234</span><br>p3+<span class="hljs-number">1</span>=<span class="hljs-number">0x2ffffebc</span>,*(p3+<span class="hljs-number">1</span>) = <span class="hljs-number">0x5678</span><br>    <br>分析：AE_MOVDA32X2作用是将两个<span class="hljs-number">32</span>位数拼成一个<span class="hljs-number">64</span>位数。<br></code></pre></td></tr></table></figure></li></ol><h2 id="四、-基础的-SIMD-编程"><a href="#四、-基础的-SIMD-编程" class="headerlink" title="四、 基础的 SIMD 编程"></a>四、 基础的 SIMD 编程</h2><p><strong>SIMD</strong> ：Single Instruction Multiple Data，<strong>单指令流多数据流</strong>，是一种采用一个控制器来控制多个处理器，<strong>同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。</strong>在 <a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8">微处理器</a> 中，单指令流多数据流技术则是一个 <a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%99%A8">控制器 </a>控制多个平行的 <a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%84%E7%90%86%E5%BE%AE%E5%85%83&action=edit&redlink=1">处理微元</a>.</p><p>由于单指令流多数据流处理效率高的原因，常被用于在多媒体应用中的 3D 图像和音视频处理。</p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093442891.png" alt="image-20220724093442891" style="zoom:200%;" /><p>基本的 SIMD 操作概念：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093451811.png" alt="image-20220724093451811"></p><p>SIMD 操纵不能以不同的形式处理多数据，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093500823.png" alt="image-20220724093500823"></p><h3 id="4-1-矢量类型"><a href="#4-1-矢量类型" class="headerlink" title="4.1 矢量类型"></a>4.1 矢量类型</h3><p>C 语言常用的数据类型例如 <code>char</code> 、<code>float</code> 被称为标量类型。在 SIMD 运算中的数据类型被称作矢量类型。每个矢量类型都有其相应的标量类型。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220711144041063.png" alt="image-20220724093512219"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093522749.png" alt="image-20220724093522749"></p><p>在 SIMD 编程中，经常需要将特定的向量元素称为标量或将标量块称为单个向量。本节介绍了满足这一需求的引用方法，例如，只输出向量的第三个元素或将标量数组输入数据捆绑成适合 SIMD 处理的向量成为可能。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093533040.png" alt="image-20220724093533040"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093550883.png" alt="image-20220724093550883"></p><h3 id="4-2-基础的-SIMD-运算"><a href="#4-2-基础的-SIMD-运算" class="headerlink" title="4.2 基础的 SIMD 运算"></a>4.2 基础的 SIMD 运算</h3><ol><li><p><strong>以加法为例，介绍标量运算与 SIMD 运算</strong></p><p>a. <strong>标量运算</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093601622.png" alt="image-20220724093601622"></p><p>b. <strong>SIMD 运算</strong></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093628087.png" alt="image-20220724093628087"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093639289.png" alt="image-20220724093639289"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093702759.png" alt="image-20220724093702759"></p><p>​c. 完整的加法例程<img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093714182.png" alt="image-20220724093714182"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093727381.png" alt="image-20220724093727381"></p><div class="note note-info">            <p>运算几乎都是以标量矩阵作为输入数据。</p>          </div><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093743600.png" alt="image-20220724093743600"></p><ol start="2"><li><strong>条件运算</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093752699.png" alt="image-20220724093752699"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093802584.png" alt="image-20220724093802584"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093810499.png" alt="image-20220724093810499"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093821334.png" alt="image-20220724093821334"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093828937.png" alt="image-20220724093828937"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093836377.png" alt="image-20220724093836377"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093847048.png" alt="image-20220724093847048"></p><h2 id="五、寄存器"><a href="#五、寄存器" class="headerlink" title="五、寄存器"></a>五、寄存器</h2><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220724093859234.png" alt="image-20220724093859234"></p><h3 id="5-1-通用（AR）-寄存器"><a href="#5-1-通用（AR）-寄存器" class="headerlink" title="5.1 通用（AR） 寄存器"></a>5.1 通用（AR） 寄存器</h3><p>地址寄存器（Address Registers, AR）。每条指令最多包含三个 4 位的通用寄存器（AR）指令，每个指令可以选择 16 个 32 位寄存器中的一个。这些通用寄存器被命名为地址寄存器，以区别于协处理器寄存器，后者在许多系统中可能作为 “数据 “寄存器使用。然而，AR 寄存器并不限于保存地址，它们也可以保存数据。</p><p>如果配置了窗口寄存器选项，地址寄存器文件将被扩展，并使用从虚拟到物理寄存器的映射。</p><p>地址寄存器文件的内容在复位后是未定义的。</p><h3 id="5-2-移位和移位量寄存器（SAR）寄存器"><a href="#5-2-移位和移位量寄存器（SAR）寄存器" class="headerlink" title="5.2 移位和移位量寄存器（SAR）寄存器"></a>5.2 移位和移位量寄存器（SAR）寄存器</h3><p>移位和移位量寄存器（Shifts and the Shift Amount Register，SAR)。ISA 提供了传统的即时移位（逻辑左移、逻辑右移和算术右移），但是它没有提供单指令移位，其中移位量是一个寄存器操作数。从一个普通的寄存器中获取移位量会产生一个关键的时序路径。另外，简单的移位不能有效地扩展到更大的宽度。漏斗式移位（两个数据值在输入移位器的时候被 catenated）解决了这个问题，但是需要太多的操作数。ISA 通过提供一个漏斗移位来解决这两个问题，其中移位量是从 SAR 寄存器中获取的。可变移位由编译器合成，使用指令从一般寄存器中的移位量计算 SAR，然后再进行漏斗移位。</p>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DSP 学习笔记 |（三）C &amp; DSP 基础概念</title>
    <link href="/posts/af34.html"/>
    <url>/posts/af34.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>记录在学习过程中所需的 C 语言与 DSP 相关基础知识补充。</p>          </div><h2 id="一、C-语言基础"><a href="#一、C-语言基础" class="headerlink" title="一、C 语言基础"></a>一、C 语言基础</h2><h3 id="1-1-零碎"><a href="#1-1-零碎" class="headerlink" title="1.1 零碎"></a>1.1 零碎</h3><ol><li><p><strong>const</strong> 修饰：用 const 修饰过的指针变量 p 不能修改 a 中的内容，而没有用 const 修饰过的指针变量 q 照样可以修改 a 中的内容，而且 a 自己也可以重新给自己赋值。它用来 <strong>告诉编译器， 被修饰的这些东西，具有“只读”的特点</strong> 。</p></li><li><p>C 语言中 “ ! ” 是对<strong>立面的意思</strong>。例如 ！ &#x3D; 就是不等于的意思，常用在循环条件判断中，或者逻辑运算中，例如 x&#x3D;! (1&#x3D;&#x3D;1),（1&#x3D;&#x3D;1）的结果为1，但有！ X的结果从1变为0。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220706163451150.png" alt="image-20220706163451150"></p></li><li><p><strong>字节对齐</strong>：计算机中内存大小的基本单位是字节（byte），理论上来讲，可以从任意地址访问某种基本数据类型，但是实际上，计算机并非逐字节大小读写内存，而是以 2,4,或 8 的 倍数的字节块来读写内存，如此一来就会对基本数据类型的合法地址作出一些限制，即它的地址必须是 2，4 或 8 的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是对齐。</p><p><strong>对齐原因</strong>：根本在于 CPU 访问数据的效率问题。</p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220708153912242.png" alt="image-20220708153912242" style="zoom:80%;" /><p><strong>对齐准则</strong>：总的来说，字节对齐有以下准则：</p><ul><li><strong>结构体变量的首地址能够被其对齐字节数大小所整除</strong>。</li><li><strong>结构体每个成员相对结构体首地址的偏移都是成员大小的整数倍</strong>，如不满足，对前一个成员填充字节以满足。</li><li><strong>结构体的总大小为结构体对最大成员大小的整数倍</strong>，如不满足，最后填充字节以满足。</li></ul></li><li><p><strong>寄存器</strong>：CPU 内部的存储单元，寄存器是 CPU 内部用来创建和储存 CPU 运算结果和其它运算结果的地方。</p></li><li><p><strong>计算机字长（机器字长）</strong>：计算机字长（机器字长）取决于数据总线的宽度，通常就是CPU一次能处理的数据的位数（CPU位数）。</p></li><li><p><strong>argc &amp; argv</strong>:</p><p>argc 是 argument count 的缩写，表示传入 main 函数中的参数个数，包括这个程序本身；</p><p>argv 是 argument vector 的缩写，表示传入 main 函数中的参数列表，其中 argv[0] 表示这个程序的名字。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220708165617659.png" alt="image-20220708165617659"></p><ol start="7"><li><ul><li>二进制的【或】运算：遇1得1<br>参加运算的两个对象，按二进制位进行“或”运算。<br>运算规则：0|0&#x3D;0； 0|1&#x3D;1； 1|0&#x3D;1； 1|1&#x3D;1；<br>参加运算的两个对象只要有一个为1，其值为1。</li><li>二进制的【与】运算：遇0得0<br>运算规则：0&amp;0&#x3D;0; 0&amp;1&#x3D;0; 1&amp;0&#x3D;0; 1&amp;1&#x3D;1;<br>即：两位同时为“1”，结果才为“1”，否则为0</li><li>二进制的【非】运算：各位取反<br>运算规则：~1&#x3D;0； ~0&#x3D;1；<br>对一个二进制数按位取反，即将0变1，1变0。</li><li>二进制的【异或】运算符 “^”：相同为0 ，不同为1”<br>参加运算的两个数据，按二进制位进行“异或”运算。<br>运算规则：0^0&#x3D;0；   0^1&#x3D;1；   1^0&#x3D;1；   1^1&#x3D;0；<br>参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</li></ul></li><li><p><strong>有符号位 &amp; 无符号位</strong><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220712164201496.png" alt="image-20220712164201496"></p></li><li><p><strong>浮点数标准</strong></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220712172111112.png" alt="image-20220712172111112"></p><p>​<img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/v2-f7561bf6717325ea710620df172ff528_r.jpg" alt="v2-f7561bf6717325ea710620df172ff528_r"></p><p>​<img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220712175656905-16586252982787.png" alt="image-20220712175656905"></p><ol start="10"><li><p><strong>小数的二进制计算</strong></p><p>采用 “乘 2 取整，顺序排列” 法，用 2 乘十进制小数，可以得出积，将积的整数部分取出，再用 2 乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的<a href="https://so.csdn.net/so/search?q=%E7%B2%BE%E5%BA%A6&spm=1001.2101.3001.7020">精度</a>为止。然后把取出的整数部分按顺序排列起来。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/20190601082719128.png" alt="20190601082719128"></p></li><li><p>内联函数能提高程序运行效率（inline)</p></li><li><p>正数的补码是其本身，负数是除最高位（符号位）保留外，其余取反，末位加一。</p></li><li><p><strong>宏函数</strong>：宏函数是在 <strong>程序编译时进行简单的字符替换</strong>，而函数是在程序生成后才进行调用，这时会占用开销时间（主程序函数保留现场，在子函数体中需要进行参数的传递 – 实参传递给形参以及调用完后形参的销毁等步骤 ），因此宏函数占用的编译时的时间，而函数占用的是执行时的时间。</p><p>注意宏函数在调用时只是对函数中的变量做简单的 <strong>替换</strong>，注意这里的替换真的是替换，非常死板的那种！！！所以在宏函数中经常看到（）</p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220721114507999.png" alt="image-20220721114507999" style="zoom:80%;" /><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220721114522687.png" alt="image-20220721114522687" style="zoom:80%;" /></li></ol><h3 id="1-2-汇编-amp-反汇编"><a href="#1-2-汇编-amp-反汇编" class="headerlink" title="1.2 汇编 &amp; 反汇编"></a>1.2 汇编 &amp; 反汇编</h3><div class="note note-primary">            <p>汇编语言是高级语言转换成机器码的桥梁，通过汇编语言的编译转换成机器码，计算机就可以执行程序。</p><p>因为在计算机中，所有的程序都是按照机器码执行的，所以对汇编语言的理解，能够增加对底层执行的认识。</p>          </div><p>下图为一个 c 程序变成一个可执行程序的过程：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/20161106180515946.png" alt="20161106180515946"></p><p><strong>汇编</strong>：</p><ol><li>动词，指的是把 <a href="https://so.csdn.net/so/search?q=%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80&spm=1001.2101.3001.7020">汇编语言 </a>翻译成机器语言的过程。<br>就是图中 hello.s 文件经过汇编器变成二进制 hello.o 文件的过程。</li><li>名词，指的便是汇编语言<br>就是 hello.c 经过预处理器，再经过编译器生成的 hello.s 文件。这个文件里的东西就叫汇编程序（汇编语言）。</li></ol><p>汇编指令一般都是由操作符和操作数组成，操作符也被称为指令助记符，它是指令中的关键字，表示本条指令操作类型，不能省略。操作数可以省略，也可以有很多，但各操作数之间要用 “，”分开。指令助记符与操作符之间要用空格分开。</p><p><strong>反汇编：</strong></p><ol><li>动词，指的是由已生成的机器语言（二进制语言）转化为汇编语言的过程，也可以说是汇编的逆向过程。</li><li>名词，指的是有机器语言经过反汇编过程生成的汇编语言。</li><li>反汇编生成的汇编代码，每一行前面都有一串16进制的数字。这些数字就是每一行汇编代码对应的机器代码。</li><li><strong>反汇编就是我们把一系列的机器码转换成改程序的助记符</strong>。如果我们拿到一份机器码程序，而我们想要知道他的功能和工作方式，可以对机器码进行反汇编。</li></ol><h2 id="二、DSP-基础"><a href="#二、DSP-基础" class="headerlink" title="二、DSP 基础"></a>二、DSP 基础</h2><h3 id="2-1-定点数与浮点数"><a href="#2-1-定点数与浮点数" class="headerlink" title="2.1 定点数与浮点数"></a>2.1 定点数与浮点数</h3><p>首先我们要认清一个概念，定点数不一定是整数，浮点数不一定是小数。</p><p>为了轻松指定使用多少位来表示数字的整数和小数部分，我们使用称为Q格式的表示法。例如，<strong>要指定我们对整数部分使用三位，对小数部分使用四位，我们可以说数字采用 Q3.4 格式。</strong></p><p>如其名，浮点数和定点数的区别就在于浮点和定点上，点就是指小数点。浮点数就是小数点是浮动的，定点数就是小数点是固定不动的。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220712174207897.png" alt="image-20220712174207897"></p><p>数字信号处理可以分为两类：定点和浮点。 区分依据是用于存储和操纵数据数字表示的格式。 定点 DSP 设计用于表示和操控整数，包括正整数和负整数，最低为 16 位，因而可能的位模式有 65,536 种 (2^16 浮点 DSP 用于表示和操控有理数，最低为 32 位，与科学计数法相似，数值用尾数和指数表示（例如 A x 2B， A 为尾数，B 为指数)，因而可能的位模式有 4,294,967,296种 (2^32).</p><p><strong>对定点数而言，数值范围与精度是一对矛盾，一个变量要想能够表示比较大的数值范围，必须以牺牲精度为代价；而想提高精度，则数的表示范围就相应地减小。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220712173606593.png" alt="image-20220712173606593"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220712170135724.png" alt="image-20220712170135724"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220712165740026.png" alt="image-20220712165740026"></p><h3 id="2-2-饱和运算"><a href="#2-2-饱和运算" class="headerlink" title="2.2 饱和运算"></a>2.2 饱和运算</h3><p>所谓饱和运算，就是当运算结果大于一个上限或小于一个下限时，结果就等于上限或是下限。例如：BYTE 运算，最大值是 255，0xF1+0x35 应该是等于 0x26，但由于结果大于 255，那么饱和运算的结果就是 0xFF。在图像处理里经常有（比如说增加亮度）两种灰度值运算后要判断值是否大于 255 或小于 0，根据结果再取 255 或 0。</p>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DSP 学习笔记 |（二） 指令集架构</title>
    <link href="/posts/847f.html"/>
    <url>/posts/847f.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文将介绍指令集（ISA）概念，以便在后续的学习中建立其理论基础。</p>          </div><h2 id="一、什么是指令集？"><a href="#一、什么是指令集？" class="headerlink" title="一、什么是指令集？"></a>一、什么是指令集？</h2><p><img src="https://pic2.zhimg.com/80/v2-a5f2cf435cc3d0ff055aca0f7437e639_720w.jpg" alt="img"></p><p>这张图描述了整个计算机系统从上到下的抽象层。首先最顶层的是应用程序（Application），那么应用程序在计算机里是由什么构成的呢？是由它的下一层级，算法（Algorithm）构成的。算法也依赖于所实现它的编程语言（Programming Language），然而编程语言也需要操作系统（Operating System）的支持才能正确工作。那什么东西支持操作系统呢？再往下一层就是我们今天的主角：指令集架构（Instruction Set Architecture, 以下简称 ISA）。</p><p>从 ISA 开始往下，都是和硬件电路相关的内容了，所以我们可以得出一个基本的定义：<strong>指令集架构是一个能为电路硬件翻译应用程序的一层抽象层</strong>。它能够为操作系统制定很多规则和约束，也能让编程者不用操心具体的电路结构，转而在这一抽象的、高级的、定义很多规则的层面编写程序，比如：</p><ul><li>这个计算机架构里有多少个寄存器（Register）？</li><li>我能进行哪些运算操作？（有哪些指令？ADD，SUB，MUL等等）</li><li>如果遇到异常或者中断该怎么办？</li><li>数据可以有哪些类型？最多有几个字节？</li><li>等…</li></ul><p>ISA 在编译器编写者（CPU软件）和处理器设计人员（CPU硬件）之间提供了一个抽象层：</p><ul><li>处理器设计者：依据 ISA 来设计处理器；<br>处理器使用者（如：写编译器的牛*程序员）：依据 ISA 就知道 CPU 选用的指令集，就知道自己可以使用哪些指令以及遵循哪些规范。</li><li>定义处理器上的软件如何构建，这是 ISA 的最重要内涵，现代处理器都是支持高级语言编程、操作系统等等特性，ISA 要定义出指令集内的指令是如何支撑起 C 语言里堆栈、过程调用，操作系统里异常、中断，多媒体平台里数字图像处理、3D 加速等等。</li></ul><blockquote><p>x86 ISA 现在是 Intel 和 AMD 共同拥有，也就是说如果你要开新的 x86 cpu 公司你必须向这两者付版权费用，而且必须两者都同意你才能获得完整的 ISA，如果你只获得一部分不完整的 ISA，那就和完全没拿到 ISA 一样。ISA 在 cpu 里面，就像是字典，用厨房的比喻就是菜谱，菜谱定义了你这个厨房会做什么菜，这个菜做出来是什么样什么味道，那么顾客在这家连锁店的任何一间都能叫到相同的菜，吃到相同的味道。</p><p>ARM ISA 当然是 ARM 公司所有的，当时 ARM 公司是定菜单的，并且给出试菜的人，说你们每家店都要做出这个味才算 ARM。而做店的则是不同的公司，像qualcomn 啦，他们中间喜欢怎么做菜是他们的自由，但是必须会那几道菜，必须做出这个味。</p></blockquote><div class="note note-warning">            <p><strong>提示</strong></p><ol><li>常见的一个误解的答案：<strong>指令集并不存储于CPU中</strong>，应该这样说：CPU本身是指令集 (结构) 的一个实现&#x2F;实例；</li><li>一个 ISA 可能包含多个指令集；</li></ol>          </div><h2 id="二、指令集架构-vs-微架构"><a href="#二、指令集架构-vs-微架构" class="headerlink" title="二、指令集架构 vs 微架构"></a>二、指令集架构 vs 微架构</h2><p>指令集架构（ISA）和微架构（Microarchitecture）很多时候会被人们混淆。<strong>其实微架构就是对 ISA 的一种实现。</strong></p><p>综合而言，微架构是指令集架构的一种实现方式，不同的处理器有着不一样的微架构。如果你是 RTL 设计工程师或者验证工程师，你就会拿到处理器的指令集架构的手册，然后根据这个手册来设计或者验证芯片的微架构。</p><p>提高 CPU 性能的一个关键方向是如何提高指令级的细粒度并行。目前指令级细粒度并行性的一些方法有:</p><ul><li>流水线：流水线已经普遍应用于处理器中，通过改进单个流水线的实现，几乎无法再获得更多的收益。</li><li>多处理器：使用多个处理器仅对有限的应用程序能够起到提高性能的效果。</li><li>超标量体系结构：超标量架构可以提高所有类型程序的性能。超标量体系结构意味着一次能够完成多个指令的执行</li><li>每条指令完成多个独立操作：即超长指令字架构（Very Long Instruction Word – VLIW）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220718192033581.png" alt="image-20220718192033581"></p><ul><li><p><strong>VLIW</strong></p><ul><li><p>市面上多数的 DSP 都是采取 <strong>VLIW</strong> 指令集(超长指令字)，一次发一个指令包，<strong>指令包包含多个 slot（指令槽），相当于一次发射多条指令</strong>，实现指令级的并行 ILP；DSP 在微架构上的一个优化，就是通过增加指令包的 slot 数量，比如从 4 个增加到 5 个，提高 IPC；</p></li><li><p>与多发射CPU不一样的是，所有的指令打包都是由编译器完成，因此指令吞吐量很依赖于编译器的优化；</p></li><li><p>如果遇到前后指令相关依赖的情况，就不能把这些指令放到一个指令包中，<strong>这种情况下指令包的指令不是满载的</strong>；</p></li><li><p>许多厂商为了提高 IPC，会对这种情况做相应的优化。</p></li></ul></li></ul><p><strong>VLIW 指令架构优缺点</strong></p><p>优点：</p><ul><li>不需要动态调度硬件，简化硬件电路</li><li>不需要在 VLIW 指令中进行依赖项检查，简单的指令多发射硬件</li><li>取指后分发到不同能单元，不需要进行指令对齐&#x2F;分配 简化硬件电路</li></ul><p>缺点：</p><ul><li>编译器需要找到 N 个独立的操作</li><li>如果无法找到，需要在一个 VLIW 指令中插入 NOP，降低并行性，增加代码大小</li><li>当执行宽度 (N)、指令延迟、功能单元改变时需要重新编译（超标量架构不需要重新编译）</li><li>同步执行会导致独立操作停止</li><li>在延迟时间最长的指令完成之前，任何指令都不能执行</li></ul><h2 id="三、-指令集分类"><a href="#三、-指令集分类" class="headerlink" title="三、 指令集分类"></a>三、 指令集分类</h2><p>指令集架构中最重要的就是所包含的指令（Instructions），一个架构中可能包含成百上千的指令，但它们大致可以被分为一下几类：</p><ul><li>数据流转移：Load</li><li>算术逻辑（利用到算术逻辑单元 ALU，arithmetic and logic unit 指令）：ADD、SUB、MUL</li><li>控制流转移：JR（JUMP）、JAL（Jump and Link）、BEQ（Branch if Equal）</li><li>浮点运算：ADD.D、SUB.S、MUL.D</li><li>多媒体运算：ADD.PS、SUB.PS</li><li>字符串运算：REP MOVSB（in x86）</li></ul><div class="note note-info">            <p>精简指令集RISC【educed instruction set computer】</p><p>复杂指令集CISC【complex instruction set computer】</p>          </div><h2 id="四、-寻址模式"><a href="#四、-寻址模式" class="headerlink" title="四、 寻址模式"></a>四、 寻址模式</h2><blockquote><p>寻址方式就是处理器根据指令中给出的地址信息来寻找有效地址的方式，是确定本条指令的数据地址以及下一条要执行的指令地址的方法。</p><p>寻址模式（Addressing Mode）定义了一个指令按照那种方式去寻找想要的数据，其中定义了寄存器和相应的内存位置。</p></blockquote><p>指令寻址的方式包括两部分：</p><ul><li><p><strong>指令的寻址</strong><br>这里的指令寻址指的是具体的操作码上发出的指令。是 <strong>狭义上的指令寻址</strong>。</p></li><li><p><strong>数据的寻址</strong></p><p>可以理解为地址码上操作数的地址寻址</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/v2-1450a904d1852b165216c95753fbfda9_r.jpg" alt="v2-1450a904d1852b165216c95753fbfda9_r"></p><h3 id="4-1-指令寻址"><a href="#4-1-指令寻址" class="headerlink" title="4.1 指令寻址"></a>4.1 指令寻址</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/v2-40b03665473d340e41c8cf8408a72884_720w.jpg" alt="v2-40b03665473d340e41c8cf8408a72884_720w"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/v2-4c620fdfcd35f8517e3786715d6e8f38_720w.jpg" alt="v2-4c620fdfcd35f8517e3786715d6e8f38_720w"></p><p>上述即为指令寻址的两种方式：</p><ul><li>顺序寻址</li><li>跳转寻址</li></ul><h3 id="4-2-数据寻址"><a href="#4-2-数据寻址" class="headerlink" title="4.2 数据寻址"></a>4.2 数据寻址</h3><p>通过 <strong>顺序寻址或者跳转寻址</strong> 取到操作码知道要做什么操作后，我们要拿着地址码去找处理对象了。这里地址码寻址操作对象的寻址方式也是很丰富的简单看个图感受一下：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220719105514473.png" alt="image-20220719105514473"></p><p>地址码其实分为两部分 —— 寻址特征 + 形式地址：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/v2-e9d2e66898dff67075b272076151c6ac_720w.jpg" alt="v2-e9d2e66898dff67075b272076151c6ac_720w"></p><ul><li>寻址特征存的就是每个寻址方式上的蓝色小标，表示一种方式。</li><li>形式地址不是直接对应到存储器中的地址，而是需要根据 <strong>寻址特征的要求</strong> 转换为对应到存储器的地址 。<br>所以我们把通过 <strong>寻址特征和形式地址求出来的真正对应到存储器的地址称之为有效地址。</strong></li></ul><p><strong>1. 立即寻址</strong></p><p>方式：把我们实际要操作的数，直接存放在形式地址中。<strong>立即寻址是获取操作数最快的方式</strong></p><p>eg：假如我们要直接操作的数为 3，那么我们可以用一条一地址指令这么设置：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/v2-9e705f0134f0f4d5c73388641941c8e9_720w.jpg" alt="v2-9e705f0134f0f4d5c73388641941c8e9_720w"></p><p>直接把 3 的补码写在形式地址中</p><ul><li>寻址特征为#，代表立即寻址的意思。</li><li>形式地址 <strong>写的是操作数 3 的补码（011）。</strong></li></ul><p>立即寻址主要执行取指令访存1次，不需要执行指令访存，一共访存1次。</p><p><strong>立即数</strong>：立即寻址方式的目的就是将操作数紧跟在操作码后面，与操作码一起放在指令代码段中，在程序运行时，程序直接调用该操作数，而不需要到其他地址单元中去取相应的操作数，上述的写在指令中的操作数也称作立即数。</p><p><strong>2. 直接寻址</strong></p><p>直接寻址指令中的地址码字段给的是 <strong>操作数的有效位置</strong>，我们可以根据这个有效位置直接去内存中寻找操作数。指令中在操作码字段后面的部分是操作数的地址</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/v2-aa9aa62ad61a4a3fb5a1679f220f4e10_720w.jpg" alt="v2-aa9aa62ad61a4a3fb5a1679f220f4e10_720w"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/v2-5888816bbc50ab0983a356da892d010f_720w.jpg" alt="v2-5888816bbc50ab0983a356da892d010f_720w"></p><p>与立即寻址相比：直接寻址主要执行取指令访存1次，还有执行指令访存1次，一共访存2次。</p><p><strong>直接寻址和立即寻址的区别</strong></p><p>立即寻址：是把一个“常数”送到指定位置。<br>直接寻址：是把一个“变量”送到指定位置。</p><p><strong>3. 间接寻址</strong></p><p>指令中给出的地址是操作数地址的地址。</p><p><strong>4. 寄存器寻址</strong></p><p>指定的寄存器中存放着操作数本身。</p><p><strong>5. 寄存器间接寻址</strong></p><p>指定的寄存器中存放的不是操作数，而是操作数的地址。</p><h2 id="五、-指令编码"><a href="#五、-指令编码" class="headerlink" title="五、 指令编码"></a>五、 指令编码</h2><p>对于指令编码（Instruction Encoding），或者说是指令的组成，每个架构的不尽相同。从长度上，可以分为三类：</p><ol><li><p><strong>固定长度指令（Fixed-Length Instruction）</strong></p><p>每个指令的长度都一样，好处是解码非常的方便简易。一些 精简指令集（RISC） 的架构，比如 MIPS、ARM、RISC-V、PowerPC就在使用这种模式。</p></li><li><p><strong>可变化长度指令（Variable-Length Instruction）</strong> </p><p>每个指令都有自己特定的长度，这样设计的好处是可以压缩缓存器和内存的空间，因为很早之前存储器的容量都很小，很珍贵，所以 可变化长度指令 是最先发展起来的。复杂指令集就是这一阵营的代表：x86（最短 1B，最长可达 17B）、IBM 360、Motorola 68k 等。</p></li><li><p><strong>压缩型指令（Compressed Instructions）</strong></p><p>一般这种指令的长度都非常短（16-Bit），目的都是减少编译后的代码量。代表有 MIPS16、ARM THUMB 等。</p></li></ol><p>还有一种特殊的架构：<strong>超长指令集（Very Long Instruction Word，VLIW）</strong>是由英特尔和惠普共同在21世纪初提出的一种用于改善工作站性能的新型架构，里面的每条 <strong>指令束（Instruction Bundle）</strong>是由四条或者更多的普通指令集合在一起而形成的。由于技术和时代原因，最后悄然退场。代表作：IA-64 &#x2F; Intel Itanium (英特尔安腾处理器)。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/370204019">关于寻址方式一篇就够了</a></p><p>[2] <a href="https://panda-tang.blog.csdn.net/article/details/104361017?spm=1001.2014.3001.5502">如何快速判断立即数</a> </p><p>[3] <a href="https://zhuanlan.zhihu.com/p/449069647">Computer Architecture —— ISA 指令集架构介绍 （一）：为什么需要 ISA</a></p><p>[4] <a href="https://zhuanlan.zhihu.com/p/346757887">Computer Architecture —— ISA 指令集架构介绍 （二）：四大特性（完结）</a></p><p>[5] <a href="https://www.arm.com/glossary/isa">What Is an Instruction Set Architecture?</a></p><p>[6] <a href="https://zhuanlan.zhihu.com/p/20731557">科普向 ISA,cpu架构原理</a></p><p>[7] <a href="https://blog.csdn.net/whatday/article/details/87268727?spm=1001.2101.3001.6650.9&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-9-87268727-blog-103138156.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-9-87268727-blog-103138156.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=10">XTENSA处理器介绍</a></p><p>[8] <a href="https://suda-morris.github.io/blog/cs/xtensa.html#xtensa-%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82-hal">𝙓𝙩𝙚𝙣𝙨𝙖 基础</a></p><p>[9] <a href="https://www.jianshu.com/p/66e205efbba9">HIFI3 DSP芯片技术摘要</a></p><p>[10] <a href="https://blog.csdn.net/qq582880551/article/details/122467496">Cadence Tensilica Xtensa HiFi 音频解码器相关介绍</a></p>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DSP 学习笔记 |（一） 初识 DSP</title>
    <link href="/posts/65e8.html"/>
    <url>/posts/65e8.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>由于工作需要，在此开设 DSP 学习笔记系列。如有错误，欢迎交流指正！</p>          </div><h2 id="一、DSP-概念"><a href="#一、DSP-概念" class="headerlink" title="一、DSP 概念"></a>一、DSP 概念</h2><p>数字信号处理器（DSP，Digital Signal Processor）接收经数字化处理的语音、音频、视频、温度、压力或位置等现实世界信号，然后以数学方式进行操作处理。 可以非常迅速地执行”加”、”减”、”乘”、”除”之类数学运算功能。</p><center><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/DSP_block_diagram.svg.png" alt="DSP_block_diagram.svg" style="zoom: 30%;" /></center><br/><p>通过下图可以清楚了解 MP3 播放器中 DSP 的工作原理。 在录制阶段，模拟音频通过接收器或其他来源输入。 模拟信号接着通过一个模数转换器转换为数字信号，再传至 DSP。 DSP 进行 MP3 编码，然后将文件保存至内存。 在回放阶段，文件从内存中取出，由DSP解码，再经数模转换器转回模拟信号。这样模拟信号就可以通过音响系统输出。 在更复杂的例子中，DSP 将执行其他功能，如音量控制、均衡和用户界面。</p><center><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/mp3demo_light_blue.gif" style="zoom: 100%" /></center><br/><p><strong>DSP 与其它处理器的差别</strong></p><p>数字信号处理器（DSP）、通用微处理器（MPU）、微控制器（MCU）三者的区别在于：DSP 面向高性能、 重复性、数值运算密集型的实时处理；MPU 大量应用于计算机；MCU 则适用于以控制为主的处理过程。</p><h2 id="二、DSP-结构特点"><a href="#二、DSP-结构特点" class="headerlink" title="二、DSP 结构特点"></a>二、DSP 结构特点</h2><center><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220716173129183.png" alt="image-20220716173129183" style="zoom:50%;" /></center><br/><ol><li><strong>哈佛结构</strong>：一种将 <u>程序指令存储</u> 和 <u>数据指令存储</u> 分开的存储器结构。可以减轻程序运行时的总线瓶颈。(程序和数据不在同一个地方)</li></ol><br/><center><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220716173403540.png" alt="image-20220716173403540" style="zoom:40%;" /></center><br/><ol start="2"><li><p><strong>专业的硬件乘法器</strong></p><p>经典的 FFT、IIR 和 FIR 等数字信号处理算法中，乘法的 DSP 运算的重要组成部分；</p><ul><li><p><strong>时钟周期</strong>：晶振频率的倒数；</p></li><li><p><strong>机器周期</strong>：把一条指令分割成若干个阶段，每个阶段就称为机器周期；</p></li><li><p><strong>指令周期</strong>：取指令、译码、操作，完成一条指令所需要的时间。</p></li></ul></li><li><p><strong>流水线操作</strong></p><p>执行指令的几个阶段在程序执行过程中是重叠的，即几条不同的指令同时处于激活状态，每天指令处于不同的阶段。</p><p>取指和取操作数都需要对 CPU 和内存来进行对数据的和指令的交换。由于 DSP 是哈佛结构，CPU 和存储器不在同一位置，所有可以同时进行。在冯诺依曼结构中，数据和指令都在同一存储器中，不能重叠进行。</p><br/><center><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220716173832518.png" alt="image-20220716173832518" style="zoom:50%;" /></center><center><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220716173857726.png" alt="image-20220716173857726" style="zoom:50%;" /></center><br/></li><li><p><strong>特殊的 DSP 指令</strong></p><p>DSP 采用特殊的指令。</p></li><li><p><strong>快速的指令周期</strong></p><p>快速的指令周期、哈佛结构、流水线操作、专用的硬件乘法器、特殊的 DSP 指令，再加上集成电路的优化设计可使 DSP 芯片的指令周期在 200ns 以下。</p></li></ol><h2 id="三、DSP-芯片分类"><a href="#三、DSP-芯片分类" class="headerlink" title="三、DSP 芯片分类"></a>三、DSP 芯片分类</h2><ol><li>根据基础特性分类：静态 DSP 芯片、一致性 DSP 芯片</li><li>根据数据格式分类：定点 DSP 芯片、浮点 DSP 芯片</li><li>根据用途分类：通用型 DSP  芯片、专业型 DSP 芯片</li></ol><h2 id="四、DSP-内部结构"><a href="#四、DSP-内部结构" class="headerlink" title="四、DSP 内部结构"></a>四、DSP 内部结构</h2><p>DSP 包含以下这些重要元件：</p><ul><li><strong>程序存储器：</strong>储存 DSP 将用来处理数据的程序</li><li><strong>数据存储器：</strong>储存将要处理的信息</li><li><strong>计算引擎：</strong>进行数学处理、访问程序存储器中的程序及数据存储器中的数据。</li><li><strong>输入&#x2F;输出：</strong>提供一系列功能，与外部连接</li></ul><h3 id="4-1-内存总线"><a href="#4-1-内存总线" class="headerlink" title="4.1 内存总线"></a>4.1 内存总线</h3><p><strong>内存总线（Memory Bus）</strong>：包含数据总线和地址总线，总线是为了数据交换的。</p><p>以 TI DSP  ‘28x 为例，CPU 内部总线：</p><center><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220716175339210.png" alt="image-20220716175339210" style="zoom:50%;" /></center><center><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220716175437558.png" alt="image-20220716175437558" style="zoom:80%;" /></center><center><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220714204045145.png" alt="image-20220714204045145" style="zoom:40%;" /></center><h3 id="4-2-CMD-文件"><a href="#4-2-CMD-文件" class="headerlink" title="4.2 CMD 文件"></a>4.2 CMD 文件</h3><ul><li>命令文件即 CMD （Command）是 DSP 运行程序必不可少的文件，用于 <u>指定 DSP 存储器分配</u>；</li><li>CMD 文件主要由两个伪指令构成，即 MEMORY 和 SECTIONS；</li><li>MEMORY 指令定义目标存储器的配置，SECTIONS 指令规定程序中各个段及其在存储器中的位置。</li></ul><h2 id="五、DSP-相关名词"><a href="#五、DSP-相关名词" class="headerlink" title="五、DSP 相关名词"></a>五、DSP 相关名词</h2><ul><li><p><strong>模拟信号处理 vs 数字信号处理</strong></p><p>前者可以处理包括微波毫米波乃至光波信号（分辨率很高）。后者按照奈氏准则的要求，受 S&#x2F;H 、A&#x2F;D 和处理速度的限制，对高频信号处理没有优势。</p></li><li><p>在 DSP 开发中就是通过对 DSP 的寄存器进行配置或者赋值，来控制 DSP 使其按照我们预定的功能运行。</p></li><li><p><strong>align &#x3D; 16</strong>，地址对齐，起始地址必须是 16 的倍数。</p></li><li><p><strong>位:</strong> 数字字可细分的最小单位。 位数反映字宽。 字的位数越多，该字代表的数越大。</p></li><li><p><strong>DMA（直接存储器访问）：</strong>DSP的I&#x2F;O处理器通过外部、主机、串行、SPI 和 UART 端口支持在 DSP 存储器和外部存储器、主机或外设之间的数据 DMA。 每次 DMA 操作可以传输整块数据。</p></li><li><p><strong>定点：</strong>DSP 操控和表示最适合数字的一种方法，其中该数字不大于单个内部寄存器中的最大数字。 寄存器的大小由其包含的位数确定。 例如，32 位数可能大于 16 位数。</p></li><li><p><strong>浮点：</strong>数字由尾数和指数表示的系统。 例如，a×2b，其中”a”为尾数，b为指数。 利用该方法，DSP 可操纵非常小的数字或非常大的数字。 浮点处理器表示IEEE确定的标准格式数字。 它是由 32 位表示的科学计数法。</p></li><li><p><strong>Von Neumann architecture 架构</strong>： 这是大多数（非 DSP）微处理器所用的架构。 该架构采用单一地址和数据总线进行存储器访问</p></li><li><p><strong>Harvard 架构：</strong>DSP 使用具有独立总线的内存架构以便编程和存储数据。 两个总线使 DSP 同时获得数据字和指令。</p></li><li><p><strong>I&#x2F;O 处理器：</strong> DSP 具有分布式 DMA 架构，其中每个支持 DMA 的外设均配有 DMA 控制器。 此外，大多数端口可直接（非 DMA）访问内部存储器和 I&#x2F;O 存储器。 I&#x2F;O 处理器这一术语在全球范围内指 DMA 控制器、DMA 通道仲裁和外设至总线连接。</p></li><li><p><strong>MIPS:</strong> 百万条指令&#x2F;秒，其中每个指令可执行多个操作。</p></li><li><p><strong>MACS:</strong>  乘加&#x2F;秒</p></li><li><p><strong>MOPS:</strong>  百万次操作&#x2F;秒</p></li><li><p><strong>MFLOPS:</strong>  百万次浮点操作&#x2F;秒</p></li><li><p><strong>字:</strong> 表示数据值的位串。 DSP 中的字长通常为16位、24位、32位和48位。</p></li></ul><h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><p>[1] <a href="https://www.bilibili.com/video/BV1j7411j7eJ?p=25&spm_id_from=pageDriver&vd_source=d9ea89354387124c55d399a79c8a00ba">DSP数字信号处理</a></p><p>[2] <a href="https://www.analog.com/en/education/education-library/lets-talk-dsp.html">Let’s Talk DSP</a></p><p>[3] <a href="https://www.analog.com/cn/design-center/landing-pages/001/beginners-guide-to-dsp.html">数字信号处理入门指南</a></p><p>[4] <a href="https://en.wikipedia.org/wiki/Digital_signal_processor">Digital signal processor</a></p>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Origin 备忘录</title>
    <link href="/posts/e1b4.html"/>
    <url>/posts/e1b4.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>在此记录笔者在使用 Origin 进行数据绘图过程中遇到的问题及笔记。</p>          </div><blockquote><p><strong>Origin</strong> 是由 <a href="https://zh.wikipedia.org/w/index.php?title=OriginLab&action=edit&redlink=1">OriginLab</a> 公司开发的一个科学绘图、数据分析软件，支持在 Microsoft Windows 下运行。Origin 支持各种各样的2D&#x2F;3D 图形。Origin 中的数据分析功能包括统计，信号处理，曲线拟合以及峰值分析。Origin 中的 <a href="https://zh.wikipedia.org/wiki/%E6%9B%B2%E7%B7%9A%E6%93%AC%E5%90%88">曲线拟合</a>是采用基于 <a href="https://zh.wikipedia.org/w/index.php?title=Levernberg-Marquardt%E7%AE%97%E6%B3%95&action=edit&redlink=1">Levernberg-Marquardt算法</a>（LMA）的非线性 <a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95">最小二乘法 </a>拟合。Origin 强大的数据导入功能，支持多种格式的数据，包括 <a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a>、<a href="https://zh.wikipedia.org/wiki/Excel">Excel</a>、NI TDM、DIADem、<a href="https://zh.wikipedia.org/wiki/NetCDF">NetCDF</a>、SPC 等等。图形输出格式多样，例如 JPEG，GIF，EPS，TIFF 等。内置的查询工具可通过ADO 访问数据库数据。 ——Wikipedia</p></blockquote><h2 id="常见设置"><a href="#常见设置" class="headerlink" title="常见设置"></a>常见设置</h2><ol><li><strong>坐标轴遮挡数据点标志</strong></li></ol><p>​<img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202204121039961.png" alt="img"></p><ol start="2"><li><p><strong>增加上面和右边边框</strong></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202204121039582.png" alt="img"></p></li><li><p><strong>修改页面大小</strong></p></li></ol><blockquote><p>a. 在 plot details-graph-print&#x2F;dimensions 中修改页面尺寸，这是你最终得到的图像大小的物理尺寸，按期刊投稿要求；</p><p>b. 在 plot details-graph-Layer-size&#x2F;speed 中修改每层图层的物理尺寸，确定图像的长宽比，取消 unit % of page，将 unit设为确定的物理单位（cm，mm等）</p><p>c. 关键的一点，所有图层都要按步骤 2 修改</p><p>d. 修改坐标轴、曲线的粗线等。</p></blockquote><ol start="4"><li><strong>设置坐标轴单位长度相等</strong></li></ol><p>​<img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202204121039177.png" alt="img"></p><h2 id="三维图绘制"><a href="#三维图绘制" class="headerlink" title="三维图绘制"></a>三维图绘制</h2><p><strong><a href="https://blog.csdn.net/qqin0110/article/details/87900490">使用Origin画三维图和等高图、以及函数图</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MATLAB 备忘录</title>
    <link href="/posts/73eb.html"/>
    <url>/posts/73eb.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>在此记录笔者在使用 MATLAB 过程中遇到的问题及笔记。</p>          </div><blockquote><p>MATLAB（Matrix Laboratory，矩阵实验室）是由美国 The MathWorks 公司出品的商业数学软件。MATLAB 是一种用于算法开发、数据可视化、数据分析以及数值计算的高级技术计算语言和交互式环境。除矩阵运算、绘制函数&#x2F;数据图像等常用功能外，MATLAB 还可用来创建用户界面，以及调用其它语言（包括 C、C++、Java、Python、FORTRAN）编写的程序。 ——Wikipedia</p></blockquote><h2 id="常用知识"><a href="#常用知识" class="headerlink" title="常用知识"></a>常用知识</h2><ol><li><p><strong>分号的作用</strong></p><p>两个作用：1. 数组行分隔符；2. 取消运行显示</p></li></ol><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ol><li><p><strong>批量添加&#x2F;取消注释</strong></p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">ctrl + r  <span class="hljs-comment">% 添加注释</span><br>ctrl + t  <span class="hljs-comment">% 取消注释</span><br></code></pre></td></tr></table></figure></li><li><p><strong>中断正在执行的操作</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">ctrl + <span class="hljs-keyword">c</span>  <br>% 很多程序操作都是使用 ctrl+<span class="hljs-keyword">c</span> 进行操作中断<br></code></pre></td></tr></table></figure></li><li><p><strong>清屏</strong><br>清除命令窗口中的所有输入和输出信息，不影响命令的历史记录。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">clc<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>清除变量名</strong></p><p>清除 workspace 中的无用的变量，尤其是一些特别大的矩阵，不用时及时清理，可以减少内存占用。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">clear</span>;  % 清除 <span class="hljs-keyword">workspace</span> 中的无用的变量<br><span class="hljs-keyword">clear</span> all;  % 清除 <span class="hljs-keyword">workspace</span> 中的所有变量<br></code></pre></td></tr></table></figure></li><li><p><strong>关闭绘图窗口</strong></p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mercury">close <span class="hljs-built_in">all</span>;  <span class="hljs-comment">% 关闭所有绘图窗口 </span><br><span class="hljs-comment">%% 一般主函数都是三件套</span><br>clc;<br>clear <span class="hljs-built_in">all</span>;<br>close <span class="hljs-built_in">all</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>取实部虚部</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>i<span class="hljs-comment">;</span><br><span class="hljs-attr">shibu</span> = real(a)<span class="hljs-comment">;</span><br><span class="hljs-attr">xubu</span> = imag(a)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>查看.mat文件中的数据</strong></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">whos  %</span> 命令行输入<br></code></pre></td></tr></table></figure></li></ol><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><ol><li><p><strong>二维线条</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(t, r1, <span class="hljs-string">&#x27;linewidth&#x27;</span>,<span class="hljs-number">1.2</span>)<br><span class="hljs-comment">% Linewidth 是修改线宽，Markersize 是修改离散点标记的大小（比如x或＋）</span><br></code></pre></td></tr></table></figure></li><li><p><strong>显示网格</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">grid</span> <span class="hljs-literal">on</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>图片标题</strong></p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">title</span>(<span class="hljs-string">&#x27;图片标题&#x27;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>坐标轴设置</strong></p></li></ol>   <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">xlabel(<span class="hljs-string">&#x27;x 轴的标题&#x27;</span>)，ylabel(<span class="hljs-string">&#x27;y 轴的标题&#x27;</span>);  <span class="hljs-comment">%坐标轴标题</span><br>axis([<span class="hljs-number">0</span> <span class="hljs-number">100</span> <span class="hljs-number">0</span> <span class="hljs-number">90</span>]);  <span class="hljs-comment">% 设置坐标轴范围</span><br><br>set(gca, <span class="hljs-string">&#x27;YTick&#x27;</span>, (<span class="hljs-number">0</span>: <span class="hljs-number">5</span>: <span class="hljs-number">100</span>))  <span class="hljs-comment">% 设置 Y 坐标的刻度</span><br>set(gca, <span class="hljs-string">&#x27;FontSize&#x27;</span>, <span class="hljs-number">8</span>)  <span class="hljs-comment">% 设置坐标轴字体为 8</span><br><br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;KF&#x27;</span>,<span class="hljs-string">&#x27;EKF&#x27;</span>,<span class="hljs-string">&#x27;UKF&#x27;</span>)：在坐标区上添加图例 KF,EKF,UKF<br></code></pre></td></tr></table></figure><h3 id="线型、符号及颜色汇总"><a href="#线型、符号及颜色汇总" class="headerlink" title="线型、符号及颜色汇总"></a>线型、符号及颜色汇总</h3><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/image-20220416171408067.png" alt="image-20220416171408067"></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li><strong>串口通讯中出现 “COMXX is not available.” 错误</strong></li></ol>   <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">打开串口时出现错误：MATLAB:<span class="hljs-type">serial</span>:fopen:opfailed<br>打开失败: Port: COM1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> available. <span class="hljs-keyword">No</span> ports are available.<br>Use INSTRFIND <span class="hljs-keyword">to</span> determine <span class="hljs-keyword">if</span> other instrument objects are connected <span class="hljs-keyword">to</span> the requested devic<br></code></pre></td></tr></table></figure><p>   <strong>解决方法</strong>：错误提示中已经说明了使用  <code>instrfind  </code> 去检查串口对象是否在运行（被占用）。</p><p>   在命令行输入 <code>instrfind </code> 可以看到：</p><p>   Instrument Object Array</p><p>   Index:    Type:     Status:   Name: 1   serial    closed    Serial-COM3</p><p>   index 为 1 那行中 COM3 已经被打开了。在代码中打开串口前加一行代码：<code>fclose(instrfind)</code>;   </p><p>   用意是把已经打开的串口关闭，此时再运行代码，就可以成功打开串口了。</p><ol start="2"><li><p><strong>1e2&#x3D;100</strong></p><p>表示一个数。这是科学计数法表示，e 前面指的是基数，e 后面指的是 10 的幂数，如 2.2e3&#x3D;2.2×1000&#x3D;2200。</p></li><li><p><strong>workspace 不显示变量信息</strong></p><p>使用 <code>function</code> 后就会这样。自动清掉在 <code>function</code> 内部建立的变量。 解决方法：去掉头部的 <code>function main</code> 和最后一个 <code>end</code>。</p></li><li><p><strong>“警告: 矩阵为奇异工作精度”</strong></p><p><strong>解决方法</strong>：把 <code>inv</code> 改成 <code>pinv</code> 即可。因为 <code>inv</code> 是对矩阵求逆，而对于不是可逆矩阵的矩阵求逆就会出错，<code>pinv</code> 就是对不是可逆矩阵的矩阵求伪逆。</p></li><li><p><strong>matlab 中 @(x)的含义</strong></p><p>表示 f 为函数句柄，@是定义句柄的运算符。f&#x3D;@(x)acos(x) 相当于建立了一个函数文件：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">% f.m<br>function<br><span class="hljs-attribute">y</span><span class="hljs-operator">=</span>f(x)<br><span class="hljs-attribute">y</span><span class="hljs-operator">=</span>acos(x)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><strong>NaN: not a number</strong></strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「游记」坡坡坎坎去重庆</title>
    <link href="/posts/3187.html"/>
    <url>/posts/3187.html</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>每日 3w 的步数体验，混到私人小区 33 楼去拍立交桥，迷路在错综复杂的古楼，四字弟弟拍戏地重游…都在这冬日的山城雾都重庆之旅里了。</p>          </div><p>虽然身为四川人，上一次去重庆是陪姐姐艺考，但并没有好好的去玩过重庆。这次趁着放假早，就又约着土豆到重庆扫街去。</p><p>和土豆出行就是放心，一溜烟就把车票、酒店、行程给规划好了。（不禁感叹：土豆随行，天下任我行！）</p><p>不得不说成渝双经济圈的国家战略起来后，成都到重庆乘坐复兴号只需要一个小时，完全属于还没睡舒坦就到站的乘车体验。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://i.loli.net/2021/01/20/QRiEgASZs1cwCX9.jpg"  /></div><div class="group-image-wrap"><img src="https://i.loli.net/2021/01/20/S3mNjW5dkzl7Kxy.jpg" alt="微信图片编辑_20210120132141"  /></div></div><div class="group-image-row"></div></div><p>如下是我们计划要去的拍照机位，主要是土豆在小红书上找到的一些我们比较喜欢的拍照点。</p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/20210120202019.jpeg" alt="微信图片编辑_20210120191438" style="zoom: 50%;" /><div class="note note-info">            <p>由于本身就是奔着拍照去的，那么话不多说直接上图。下文图片均出自土豆及笔者之手。</p><p>笔者设备：富士 X-T200（15-45mm）</p><p>土豆设备：富士 X100F（23mm f&#x2F;2.0）、佳能 80D（50mm f&#x2F;1.8）</p>          </div><h2 id="山上城-·-「雾都」"><a href="#山上城-·-「雾都」" class="headerlink" title="山上城 · 「雾都」"></a>山上城 · 「雾都」</h2><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/20210120211652.jpg" alt="微信图片_20210120210817 (1)"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/2021012ss0133412.jpg" alt="DSCF0966"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/2021012015330ll6.jpg" alt="微信图片_20210120144808"></p><h2 id="霓虹城-·-「雾都」"><a href="#霓虹城-·-「雾都」" class="headerlink" title="霓虹城 · 「雾都」"></a>霓虹城 · 「雾都」</h2><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/20210120133352.jpg" alt="微信图片_20210120132018"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202101201ll35735.jpg" alt="微信图片_20210120132018"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/20210135518.jpg" alt="微信图片_20210120133616"></p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202101201357.jpg" alt="微信图片_20210120132220"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202100535.jpg" alt="微信图片_20210120150839"></div></div><div class="group-image-row"></div></div><h2 id="轻轨城-·-「雾都」"><a href="#轻轨城-·-「雾都」" class="headerlink" title="轻轨城 · 「雾都」"></a>轻轨城 · 「雾都」</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202101275709.jpg" alt="微信图片_20210120154713"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/20210120ll152834.jpg" alt="微信图片_20210120145105"></div></div><div class="group-image-row"></div></div><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/20210120153940.jpg" alt="微信图片_20210120145513"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/20210120152l243.jpg" alt="微信图片_20210120145108"></div></div><div class="group-image-row"></div></div><h2 id="旧楼城-·-「雾都」"><a href="#旧楼城-·-「雾都」" class="headerlink" title="旧楼城 · 「雾都」"></a>旧楼城 · 「雾都」</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/20210120155035.jpg" alt="微信图片_20210120153155"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202103953.jpg" alt="微信图片_20210119214414"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/2021012017kk5257.jpg" alt="微信图片_20210120153155"></div></div><div class="group-image-row"></div></div><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202101235.jpg" alt="微信图片_20210120153207"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本次重庆行并不是典型的打卡式旅游 <del>（机位打卡不算打卡？双标怪）</del>，反倒是去了许多小众偏门的景点。这样体验最大的好处就是能探索到未知，也许下一个路口处就是你想要的惊喜，又也许是竹篮打水一场空。总之，面对不确定性也是很让人着迷的体验。</p><p>在旅途中我常挂在嘴边的便是：满重庆都是坡坡坎坎的噢。“你以为你在地下，其实你在地上” 。在坐车的时候我打趣道：重庆出租车师傅脑壳里的地图都跟我们的不一样，他们的是 3D 的立体地图。</p><p>重庆的确是座旅游城市，许多地方的设计都对游客非常友好，在一些后记被人挖掘出来的打卡机位还会专门设置打卡位。</p><p>雾都城，雾都人，雾都魂… 还有雾都的火锅儿都很让人感到亲切。</p><p>ps：本次雾都之行最大的遗憾就是没有拍到我们最期待的赛博朋克风街道。</p>]]></content>
    
    
    <categories>
      
      <category>生活派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Eren 的 2020 年终总结</title>
    <link href="/posts/2407.html"/>
    <url>/posts/2407.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>2020 年外部世界的关键字大概就是【变】，从新冠疫情、股市熔断、美国大选… 外部世界的风云变幻给以独立而弱小的个体不安全感，作为个体我今年的关键词大概就是【观察】，对自我的不断观察与自我接纳。</p>          </div><h2 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h2><p>在 2020 年，我做的最重要的一件事就是对自己进行持续不断的观察，从自我跳脱出来进行自我意识的察觉。在情绪的表达上能够更加的通透，只少现在我能在开心的环境下表达出内心的喜悦，在让我感到不悦的场景下正常地表达出我 的愤怒。而不是像过去，觉得什么事情都是可以忍受的，即使是那些令我不快的，通俗意义上来讲就是老好人的形象，性格的菱角也不在掩饰。</p><p>这一年我逐渐在学会如何对情感的正确感受与表达。</p><div>            <input type="checkbox" disabled checked="checked">每月进行自我复盘          </div><div>            <input type="checkbox" disabled checked="checked">持续进行自我察觉          </div><div>            <input type="checkbox" disabled checked="checked">多和比自己优秀的人接触          </div><div>            <input type="checkbox" disabled >践行极简主义（上半年疫情在家各种断舍离，下半年就被消费主义狂潮席卷了）          </div><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>今年上半年疫情在家，学习效率极低，现在回想那荒废的大半年，只好小猪叹气了。研二开学，阴差阳错进到导师公司的一个项目中，开始了由硬件转软件的过程。也算是确定了以后专心搞软件的决心，老实说一直对太底层的电路板、PCB 板着实感兴趣不起来。自入学以来对嵌入式的态度就是暧昧不清，<del>现在确定转软件之后算是把今后的路给走窄了吧。</del></p><p>毕设的题目也定了下来，关于毕设本想只是搭建整个项目系统，毕竟 BLE + AOA 在商用上还算个新定位模式。没想到开题还是被批说是本科生的毕设水平，“研究生要做的是 research”… 好吧，还是得老老实实研究算法。</p><div>            <input type="checkbox" disabled checked="checked">发表了一篇 EI 论文          </div><div>            <input type="checkbox" disabled checked="checked">完成了智能水表项目的交接          </div><div>            <input type="checkbox" disabled checked="checked">完成了开题答辩          </div><div>            <input type="checkbox" disabled >Java 程式的学习 （断断续续地学习，效率极低）          </div><div>            <input type="checkbox" disabled >智能水表服务器搭建（搭个服务器也打不好，太垃圾了）          </div><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>2020 年，有身边的亲人离去，会很伤心，但最亲爱的爷爷身体还算健康，虽然由于年纪大的原因，难免会有一些身体上的磕磕碰碰，但好在都有惊无险。</p><p>这后半年身边人给我最大的感受就是大家都在不约而同的讨论起来房产。身边的朋友们也都是刚需，最开始我也是一股脑扎进房市进行研究，但现在冷静下来之后更多的是观察。不会抱有买到就是赚到的心态，加之我本身就没有对房子的执念，在哪儿都是住。房屋的本质是居住，我不愿意牺牲最青春的十年去背负沉重的房贷，牺牲现金流动性，被迫放弃机会成本，所以近五年对于购房的事情我不会再庸人自扰了。<del>（可如何说服母亲大人是个bug）</del></p><p>2020 年，对于金钱相较于以往有看淡，会更加注重生活的体验。当然，对于搞钱这件事是一如既往的感兴趣。只是说我会更倾向于花钱买体验，而不是将钱存起来享受存钱、拥有钱的快乐。（写到这里莫名想到之前一个导游的洗脑话术：挣钱都已经这么辛苦了，花钱还不快乐点呀！）</p><div>            <input type="checkbox" disabled checked="checked">基金年化总收益：45%（事实告诉我们正确的买鸡方式是：买了然后忘掉这笔钱的存在）          </div><div>            <input type="checkbox" disabled checked="checked">三亚旅游（去了沙滩🏖️ 看了大海🌊 赏了夕阳🌇 逛了森林🌲 民宿被拒❌ 进了警局👮🏻）          </div><div>            <input type="checkbox" disabled checked="checked">第一次去蹦迪（老嗨老嗨了，然后耳朵聋了一个星期，苦笑ing）          </div><div>            <input type="checkbox" disabled checked="checked">第一次吃海底捞也算吧（为了享受学生优惠，下午三点去吃也是够拼的）          </div><div>            <input type="checkbox" disabled >日本行🗾（因为疫情原因流产了）          </div><h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><p>今年结束了一段感情，其实本应该早就结束。但自己的逃避性格和自私，双方硬是硬撑了半年。如果要有一个总结，那就是过程很快乐，结局很无奈。感情是最不应该自学的课题，得不到就是学到。自此对于感情这件事，自己对此也是看通透了许多。现在的我早已对纯洁的校园恋爱失去了兴趣，莫名的被现实起来，不知道算不算是遗憾。</p><p>在此分享上周看复旦大学文学系梁永安教授关于爱情的 <a href="https://www.douban.com/people/1109956/status/3217177951/">论述</a>，希望自己能往这方面发展：</p><blockquote><p>希望爱情解决自己的人生问题，而爱情本来是个感情它不是问题。</p><p>真正拥有爱情或者有资格谈恋爱的是那种人，就是他有能力一个在这个世界上生活。</p><p>这样生活它本身是富有活力的，只有这样的人他才有能力辐射出去温暖，</p><p>才有能力给别人一种信心和快乐。</p><p>…</p><p>你首先把自己建设成一个不需要恋爱，不需要婚姻，我也能独立地在世界上丰富而自由的生活。</p><p>这样的话，你既可以谈恋爱，也可以不谈。</p><p>你不会变成别人的压力</p></blockquote><div class="note note-danger">            <p>难免落俗，但浪漫不死</p>          </div><h2 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h2><p>阅读是仍在持续做的事情，电影与动漫总是能超额完成观影任务<del>（苦笑）</del>。小惊喜便是今年开通了博客，并结识了有趣的小伙伴。用文字记录生活，是我一直在做的事情，无论以什么样的载体形式。今年双十一购入了一款微单，摄影小白也开始入坑了…</p><p>此外播客的表现形式让我很惊奇，这一年光是在小宇宙 app 上就陆陆续续听了大概 200h 的播客内容。其中《得意忘形》、《BYM》是我的最爱了。</p><p>2020 阅读的书籍也有好有坏，相较于去年少了虚构类文学，多了许多所谓的 “中信” 畅销书。这也让给我不可避免地尽可能理想地去思考问题，从而丧失了理想主义的幻想，这难免少了些浪漫主义色彩。</p><ul><li><p>年度书籍：《<a href="https://book.douban.com/subject/5346110/">穷查理宝典》</a>《<a href="https://book.douban.com/subject/10517238/">平凡的世界</a>》《<a href="https://book.douban.com/subject/27064488/">活着</a>》</p></li><li><p>年度电影：《<a href="https://www.douban.com/link2/?url=https://movie.douban.com/subject/1307697/&query=%E8%8A%9D%E5%8A%A0%E5%93%A5&cat_id=1002&type=search&pos=1">芝加哥</a>》《<a href="https://movie.douban.com/subject/24298954/">疯狂原始人 2</a>》《<a href="https://movie.douban.com/subject/24733428/">心灵奇旅</a>》</p></li><li><p>年度音乐：《<a href="https://music.douban.com/subject/34946085/">MELANCHOLY</a>》《u’re mine》《<a href="https://music.douban.com/subject/35142476/">Shall We Talk (Tre Lune MMXIX)</a>》</p></li><li><p>年度电视剧：《<a href="https://movie.douban.com/subject/27166039/">Rick and Morty 4</a>》《<a href="https://movie.douban.com/subject/27622782/">上载人生</a>》《<a href="https://movie.douban.com/subject/30312909/">外星也难民 1</a>》</p></li></ul><div>            <input type="checkbox" disabled checked="checked">阅读 19 本课外书籍          </div><div>            <input type="checkbox" disabled checked="checked">入坑摄影          </div><div>            <input type="checkbox" disabled checked="checked">开通博客          </div><div>            <input type="checkbox" disabled checked="checked">沉迷播客          </div><div>            <input type="checkbox" disabled checked="checked">去了几个有趣的展          </div><div class="note note-primary">            <p>理工科素养是成为创造者的要素，但是文科素养是一个人行事风格的基调。这种「基调」是会扩散到周围环境的。</p>          </div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2020，现如今需要复盘总结的地方仍也不少，但无论怎样已经平安度过了。</p><p>2021，向前（钱）看吧！也希望能多有机会出去旅游，2020 年去过的地方实在太少了。</p><p>共勉之。</p>]]></content>
    
    
    <categories>
      
      <category>生活派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我有时也想变作猫咖里的一只猫</title>
    <link href="/posts/e31e.html"/>
    <url>/posts/e31e.html</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>真正严肃的哲学问题只有一个，那便是自杀。  ——阿尔贝 · 加缪《西西弗神话》</p>          </div><h2 id="两位年轻人的自杀"><a href="#两位年轻人的自杀" class="headerlink" title="两位年轻人的自杀"></a>两位年轻人的自杀</h2><p>今晚刷 B 站看到自己很喜欢的曾在东京大学留学的 up 主 <u><a href="https://space.bilibili.com/60614881?spm_id_from=333.788.b_765f7570696e666f.2">无聊的 Do 君</a></u> 发布了一条《<a href="https://www.bilibili.com/video/BV1ry4y1r7yW">一个叫叶修的年轻人决定去死</a>》，视频中悼念了一位名叫叶修的朋友（于 2020 年 7 月自杀，时年 25 岁），纪念的内容很是真诚。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=797601310&bvid=BV1ry4y1r7yW&cid=248505512&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><p>​                               </p><p>我出于好奇便搜索了一下 <u><a href="https://space.bilibili.com/917629?from=search&seid=16414891925240022834">@路边的叶修</a></u>。了解到他是 B 站上最早一批发布生活 vlog 的 up 主，主要记录其在东京的留学生活。视频风格以真实暖心为特色，也曾因拍摄的留学 vlog 接受过央视的采访。 在他生前发布的视频留言下有不少悼念的网友，并提到其视频在留学期间给予他们很大的帮助。</p><p>我翻看了他早期发布的视频，内容十分生活化，拍摄初期也显露出稚嫩。但在观看的过程中给我以舒缓和亲切感，在加上他聊天式的旁白，一个乐观的、爱生活的在东京留学的大男孩形象跃然于脑海中。</p><p>下面是他发布的第一个 vlog：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=7887482&bvid=BV1Us411877i&cid=12946886&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><p>​                                     </p><p>2015-2016 期间他陆续发布了大概 100 期这样的视频。可在 2020 年 7 月，他选择自杀的方式结束了他 25 岁的生命。</p><p>我是在他去世后 4 个月的今天了解到他，所以当我在翻看他过往视频的时候，总是会不禁带入如此的思考：这样一位乐观、开朗、愿意分享生活并陆续影响了许多留学生的年轻人为什么会早早结束生命。在视频中越是看到他那样的记录生活、热爱生活，我越是陷入人脆弱的沉思。</p><p>我的心情也逐渐随着对叶修的了解所低落起来，我想这也许是共情的缘故吧。</p><hr><p>年轻人、死亡，这两个不着边际的词汇放在一起，进而让我想到前几周大连理工大学研究生自杀的事件。因为平时不刷新闻、微博的缘故，关于这件事情并没有去过多了解。大体印象就停留在：噢，又有一位抗压能力差的研究生自杀了罢了。借此，我翻看了那位同学的遗书。读罢，老实说我还挺喜欢他的文字。没什么华丽的辞藻，尽是些朴实的措辞，再加上一些略显幼稚的玩笑与自嘲，显得真诚无比。从文字中我明明感受到了，他是一个会用幽默的三棱镜滤去内心忧伤的人，是一个会在生活中进行自我消解的人。在文末他提到下辈子想作猫咖里的一只猫，没有对生活报以热爱的人是不会说出这样的话的。可他最终还是选择了离开。</p><p><img src="https://i.loli.net/2020/10/25/C69np2oSwd1Vteu.png" alt="image-20201025142943459"></p><p> 今晚似乎被上帝抛出一个「想热爱生活却选择死亡」的命题给我。在以往我以及身边大多数人的观点总是：那些会选择早早就选择结束生命的人一定是糟糕得一点儿打击都承受不了的废物。可现在我产生了困惑，因为他们并不是那样的啊，他们甚至是曾带给人力量的人啊。</p><p>就像蒲柏所说：</p><blockquote><p>人就想绿萝，他的生存靠别的东西支持，他拥抱别人，就从拥抱中得到力量。</p></blockquote><p>难道我们仍一棍子打死地评价道：他们就是内心脆弱得不堪一击的 loser 吗？也许是没勇气，没能力去面对，去承受当下、未来的期盼。也许会有一个声音说：那你大可丧下去啊！</p><p>可谁让我们都活在这滚烫的十年里，正如王小波在《黄金时代》里那样写到：</p><blockquote><p>那天我二十一岁，在我一生的黄金时代。</p></blockquote><p>我想如果我不能激荡起一丝浪花的话，我也打算早早地在下辈子变成某间猫咖里的一只猫，不过我大概没有那样的勇气吧。  </p><p class="note note-success">人的脆弱与坚强一样，都值得我们去珍惜。</p><hr><p>视频标题 《一个叫叶修的年轻人决定去死》，应该是参照名叫《<a href="https://www.douban.com/link2/?url=https://book.douban.com/subject/26672693/&query=%E4%B8%80%E4%B8%AA%E5%8F%AB%E6%AC%A7%E7%BB%B4%E7%9A%84%E7%94%B7%E4%BA%BA%E5%86%B3%E5%AE%9A%E6%AD%BB%E5%8E%BB&cat_id=1001&type=search&pos=0">一个叫欧维的男人决定死去</a>》的小说所起。在此我想分享书中最爱的这句话给看到这里的你：</p><blockquote><p>每个人的生命中都有一个故事。要是你不了解那个故事，就不了解那个人。</p></blockquote><p>我们不知道叶修在回国这几年发生了什么，也不知道那位大连研究生经历了怎样的压力。因为我们不了解他们的故事，也就不了解他们，就更没有资格去评判他们。</p><h2 id="最后恭喜我们还活着的这个事实"><a href="#最后恭喜我们还活着的这个事实" class="headerlink" title="最后恭喜我们还活着的这个事实"></a>最后恭喜我们还活着的这个事实</h2><p>思绪很多，但最后得出的结论似乎只是：人好像也不总是能一直乐观下去的对吧。就像我自己，每个几个月都会间歇性地低落，然后去思索一些宏大而荒谬的命题。这总会显得很傻，所以只好偷偷地写在日记本上。</p><p>不过最后恭喜我们还活着的这个事实，多去和能让自己觉得活着真好的事物接触吧！</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=34468324&auto=1&height=66"></iframe>]]></content>
    
    
    <categories>
      
      <category>生活派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>「您好，我们这边是蚂蚁金服客服...」</title>
    <link href="/posts/faee.html"/>
    <url>/posts/faee.html</url>
    
    <content type="html"><![CDATA[<h2 id="诈骗电话"><a href="#诈骗电话" class="headerlink" title="诈骗电话"></a>诈骗电话</h2><p>今日午后正在躺椅上休憩，突然接到一通来自「安徽」的私人手机号。</p><blockquote><p>「您好，我们这边是蚂蚁金服客服。请问您是不是 E 先生呢？您的手机尾号是不是 XXXX ? 」</p><p>「是的」</p><p>「我们这边后台有看到您开通的借呗有逾期未还金额。」</p><p>「挂断…」</p></blockquote><p>这本看似是个人信息泄露后平淡无奇的诈骗电话，但却着实让我有些紧张起来。</p><hr><p>事情要从一周前说起。 9 月 23 日开始，我的手机会陆续收到支付宝登陆的短信验证码，起初以为就是正常的误输操作。但接下来几天仍在收到登录的短信验证码，更甚在某一日的 1 个小时内连续收到 20+ 条相同的验证短信。</p><blockquote><p>【支付宝】你正在登录支付宝，验证码5287，泄露验证码会影响资金安全。唯一热线：95188</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201004122715.png" alt="IMG_7500"></p><p>这让我开始意识到，可能有人在试图登录我的支付宝账户。但由于支付宝有二次登录验证，所以只要我保护好短信验证码不会被泄露，那么我的账户仍是安全的。（支付宝的验证码位6位数，对方有 1 &#x2F; 1000000 &#x3D; 0.0001% 的概率成功，并且暴力破解的平均时间会超过验证码超时时间。所以 Duck 不必担心验证码被试对。）</p><p>三天之后突然收到「阿里巴巴」发来的短信，同样是陆续收到很多条。</p><blockquote><p>【阿里巴巴】您正在自助开通账户，验证码636175，请在15分钟内按页面提示提交验证码，切勿将验证码泄露于他人。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201004122735.PNG" alt="IMG_7491"></p><p>不过我同样是并无理会。但一向注重隐私的我开始思考是哪个环节出现纰漏，我开始想到是否是最近在浏览他人博客时，留下的电子邮件。进而让有心之人通过邮箱账号进行支付宝登录。不过这种推测仍处在很初步的怀疑阶段。</p><p>直到接到那通电话，让我意识到「<strong>骗子可能开始主动出击了</strong>」。</p><h2 id="拨通-95188"><a href="#拨通-95188" class="headerlink" title="拨通 95188"></a>拨通 95188</h2><p>在挂掉安徽那通电话后，我随即拨通了支付宝客服电话「95188」。</p><p>拨打 95188 ，我主要想了解清楚以下几点情况：</p><ol><li>在诈骗电话已经打上门的情况下，我的支付宝账户是否仍然安全？</li><li>对方是使用手机号还是电子邮箱进行登录？</li><li>我的借呗是否被开通？借呗的开通流程和借款流程是什么？</li><li>在个人信息已确认泄露无疑的情况下，我个人能做哪些措施去加强账户安全系数（是否需要更换邮箱账号、手机号等）？</li></ol><p>由于我需要咨询业务的权限不同，先后有三名客服接待了我，我也获得了相应的答案。</p><ol><li>在不泄露验证码的情况下，账户仍是安全的。</li><li>通过支付宝后台查看到，在 9 月 23 日 至今的短信验证码申请是通过手机号登录发送的，并不是邮箱账号。所以之前所推测的由于四处胡乱留邮箱所引起的信息泄露就可以排除掉了（其实通过邮箱去反推姓名、手机号的社工难度也很大）。</li><li>我的借呗没有被开通。借呗开通和借款均需要支付密码。</li><li>在确认个人信息已泄露的情况下，可以更换手机或邮箱。但最重要的是保管好短信验证码，最好使用完之后立马删除短信。<strong>定期在 &lt;支付宝安全中心&gt; 使用安全检测功能</strong>。</li><li>建议：<strong>不要信任何私人号码，挂断后主动咨询官方电话</strong>，逆向询问。</li></ol><p>了解到并无大碍之后，又继续酣睡了 😴。</p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>虽然这是一次低级的电信诈骗，可是作为半个信息技术行业从业者，遇到个人信息被泄露得如此彻底，这也是非常值得我去复盘反思的。</p><p>此外，在 9 月 23 日发现异常的两天内，我做了以下三件事情来将损失减到最小。</p><ol><li>将支付宝中余额宝的大部分金额转到银行卡。（不争气的基金实在不忍心因为这件事情割肉卖掉，时常安慰自己是价值投资者…）</li><li>更换全新的支付宝登录密码，检查登录邮箱账户的安全性。</li><li>确认是否购买支付宝账户险。</li></ol><p>在工作、学校中难免会要求填写各种个人信息。这是我们无法回避的，如果信息从这样的渠道泄露我们实在是无能为力，但这不能成为我们彻底放弃个人信息保护的借口。关于此次信息泄露我怀疑是之前同某个培训机构合作所导致的，因为财务往来是通过支付宝，并且个人信息也会填写。并且因为培训机构泄露我的个人信息的情况遇到不止一两次。</p><div class="note note-success">            <p>在这里吐槽一下经常说「信息泄露很正常，没必要在意，反正都已经泄露了，无所谓」的人，每每听到这样的说辞我都会内心 OS :「以后你的个人信息满天飞，在黑市全套信息就值个 2 RMB。而由于我有意在保护个人信息，那么在黑市上全套信息也许能值 500 RMB？」</p>          </div><p>关于信息保护的措施，分享几点我个人在使用的 tips（虽然还是被泄露了…）。</p><ul><li><p>使用两个手机号</p><blockquote><p>一个用于银行卡、亲人联系等会一直用下去的情况。</p><p>另一个用于购物和一些不得不填手机号的情况，此号码通常会每个一两年更换一次。</p></blockquote></li><li><p>网站注册名</p><p>各种网站如需填写姓名，则以网站名为后缀。今后若收到骚扰短信，自然会知道从哪里泄露的。（如：赵B站，赵知乎，赵XX）</p></li><li><p>不贪小便宜去填写商家促销打折等信息</p><p>永远记住你的信息是值钱的。（除了某宝的店铺会员，不过也是使用小号去登记）</p></li><li><p>遇事不决先百度</p><p>在遇到某些自己都不清楚是不是诈骗行为的情况下，先百度（不用 google，因为这种偏家常范儿的问题百度里的内容更多，更接地气），去查询网上是否有相似情况再做判断。</p></li></ul><p>​                        </p><div class="note note-primary">            <p>It’s a proud thing to pay for security and privacy。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>生活派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嘿，青年艺术家们</title>
    <link href="/posts/441c.html"/>
    <url>/posts/441c.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>展名：CHABF 2020 成都艺术书展</p><p>地点：麓湖生态城 A5 麓坊 · A4国际驻留艺术中</p><p>时间：2020.09.18 - 09.20</p>          </div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当时年纪小，喜欢装文艺，便留下了爱看展的习惯  <del>（现在好了，只爱钱 🐶）</del>。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926191712.JPG" alt="IMG_7310(20200926-003520)"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926204938.JPG" alt="IMG_7309(20200922-233444)"></p><h2 id="分享会"><a href="#分享会" class="headerlink" title="分享会"></a>分享会</h2><p>下午一点匆匆赶到会场，选择了一场名叫《美国连环画》的分享会。</p><p>分享者是一位来自东北的艺术家，绘画风格很像美国漫画《马男波杰克》以及《吉普森一家》。分享者讲述了自己在美求学中所经历的创作痛苦和挣扎，最终在体验生活的过程中逐渐找到属于自己的绘画风格。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926195238.JPG" alt="IMG_7132(20200920-095350)"></p><p>分享者在展会中的作品：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926200019.JPG" alt="IMG_7150"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926200425.JPG" alt="IMG_7149"></p><h2 id="盆栽"><a href="#盆栽" class="headerlink" title="盆栽"></a>盆栽</h2><p>这组盆栽的配文实在是有打动到我，所以干脆全拍下来啦。</p><div class="note note-success">            <p>今天有个孩子说：我只能等到十八岁才能过生日，等我过生日的时候要去天上吃云朵，这是我生日最想做的事。</p>          </div><div class="note note-warning">            <p>我：一个人看店就很难出去参加活动什么的。</p><p>客人：可以让男朋友来替一下呀。</p><p>我：唉，异地恋没办法呀。</p><p>客人：那他在哪里呀？</p><p>我：他在多远的未来。</p>          </div><div class="note note-danger">            <p>为了不迟到，每天按部就班的生活，放学就直接回家。今天突然想，这么生活太无聊了吧，怎么能光上学不跟自然接触呢？</p>          </div><div class="note note-secondary">            <p>数字媒体的飞速进步反而让我越发觉得我们的文明是非常脆弱的。100年以后，如果人类灭绝了，最可能留下的还是刻在石头上，最原始的东西。</p>          </div><div class="note note-info">            <p>我的勇气，基本都被拿去跟肯德基里做冰淇淋的人说 “做个大的给我行吗？” 和 “多来点酱吧”。</p>          </div><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926201259.JPG" alt="IMG_7135"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926201633.JPG" alt="IMG_7145"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926201540.JPG" alt="IMG_7140"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003204l321.JPG" alt="IMG_7135"></div></div></div><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003204339.JPG" alt="IMG_7138"></p><p>当逛完这几座盆栽时，不禁让我思考：在平日疯狂敲击代码的日子里，我是否真的有在生活着？</p><h2 id="集市"><a href="#集市" class="headerlink" title="集市"></a>集市</h2><p>说是集市，因为这个会场真的就是青年艺术家们摆摊设点的集市场。不同的是，这里没有讨价还价，有的只是关乎于作品和理念的交流。他们与络绎不绝的人们沟通着，阐述着创作理念。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926203509.JPG" alt="IMG_7247"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926204523.JPG" alt="IMG_7253"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926204627.JPG" alt="IMG_7263"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003202506.JPG" alt="IMG_7222"></p><p>👇  这位小姐姐十分热情地讲解着自己的作品。从她的介绍中了解到这是一本从细胞层面结合女性视角讲述女性的作品。背后墙上挂在作者收集的不同女性在卸妆过程中使用过的卸妆布（or 卸妆巾？），旨在展现每个女性作为独立个体存在的美。（一圈逛下来后，这位青年艺术家告诉我们她已经卖完了今天的大部分作品！）</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926210000.JPG" alt="IMG_7231"></p><p>他们在此努力售卖着梦想，这是值得尊重的。</p><h2 id="趣图"><a href="#趣图" class="headerlink" title="趣图"></a>趣图</h2><p>👇 这是一对双胞胎姐妹的作品展，里面展现了他们在成长过程中的喜乐悲欢。对于为什么要选用红配绿，最开始以为是她们一人喜欢红色一人喜欢绿色。在同创作者交流后，她们说到是以为姐妹俩一人性格更活泼些，一人性格更安静些，所以在创作时便分别选择了红色和绿色。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003202748.JPG" alt="IMG_7156"></p><p>  👇  人们可以自行在白纸上进行创作，于是我熟练地拿起画笔在纸上写道 “四六级包过，加 Q:xxxxx”。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003202806.JPG" alt="IMG_7154"></p><p>👇 一本来自废弃房屋里的手账。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003202821.JPG" alt="IMG_7168"></p><p>👇 创作的含义没看懂，不过就觉得这张拍得很有氛围~</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926213309.JPG" alt="IMG_7153">             </p><p>👇 大黑！<del>（大白的兄弟）</del>，艺术家在此进行了行为艺术表演。着实没看懂，领悟能力还是不 dei 行啊。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926215254.JPG" alt="IMG_7165">              </p><p>👇 「十五分钟的交换」创作者提前三天来到成都，与路人进行十五分钟的交谈，同时进行肖像画创作。每幅画里面都包含着作者对对象的理解。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003203001.JPG" alt="IMG_7142"></p><p>有些画里眼睛里有星星，有笑脸。这就是相由心生吼。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/2020094954.JPG" alt="IMG_7210"></p><p>👇 interesting</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003203029.JPG" alt="IMG_7246"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003204554.jpeg" alt="20200926223016 (2)"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926220546.JPG" alt="IMG_7285(20200921-233710)"></div></div></div>             <p>👇 这…</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003203405.JPG" alt="20200926215730"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003203436.jpeg" alt="20200926220317"></div></div></div><p>👇 「里外美学实验室」这是一个很有意思的小展厅，里面摆放了格式的画作。每幅画作都配有相应制作的音乐，作者希望观赏者结合着音乐来观赏画作，用听觉和视觉共同体验作品来带的魅力。</p><p>其中一个作品是作者将交通事故合集配上清脆悦耳的节奏音，视频初始的压迫感和紧张瞬间就被缓解了。有点可惜没有用视频记录下来，感兴趣的朋友可以关注他们的公众号，并且可以进行声音投稿，来参加他们的新创作「ECHO 回音计划」。（公众号：里外美学实验室）</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003203453.jpg" alt="20200926222005"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003203508.jpg" alt="20200926221131"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>展会中许多内容都是匆匆晃过，许多想去了解的细节还没有同创作者们去交流。虽说都是一些青年艺术家们，有些人可能会觉得许多作品是在故作深沉，或者颇 “有少年不识愁滋味，为赋新词强说愁” 的味道，但个人认为先抛开艺术价值不谈，只要是有过思索过的作品都是值得肯定的。</p><p>看展是一定要看的，这辈子都不可能不看展的。年轻时爱装文艺留下的后遗症，莫得办法…</p>]]></content>
    
    
    <categories>
      
      <category>生活派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>把你的名字送上火星</title>
    <link href="/posts/13b8.html"/>
    <url>/posts/13b8.html</url>
    
    <content type="html"><![CDATA[<div class="note note-primary">            <p>「我们是获得了生命的星尘，然后被宇宙赋予了发现自我的使命。」  ——《写给忙碌者的天体物理学》</p>          </div><p>「<a href="https://www.nasa.gov/press-release/nasa-invites-public-to-submit-names-to-fly-aboard-next-mars-rover">Send Your Name To Mars</a>」是一项 NASA 发起的项目：让公众都有机会将自己的名字通过火星探测器送到火星上去。</p><blockquote><p>位于加利福尼亚州帕萨迪纳市的美国宇航局喷气推进实验室（JPL）的微器件实验室将使用电子束将提交的名字用模板印在硅芯片上，并在芯片上印上小于人类头发宽度千分之一（75纳米）的文字行。以这种大小，在一个一丁点大小的芯片上可以写下一百万个以上的名字。芯片将装在玻璃罩下的漫游车上。</p></blockquote><p>「<a href="https://www.space.com/21900-nasa-mars-rover-2020-images.html">火星 2020</a>」探测器已在 2020 年 7 月被发射，于 2021 年 2 月降落在火星上。所以目前我们已经无法参与「<a href="https://www.space.com/21900-nasa-mars-rover-2020-images.html">火星 2020</a>」探测器的活动。</p><p>但我们可以参与后续的火星探测计划，将自己的姓名送上火星。</p><ul><li><p>进入官网：<a href="https://mars.nasa.gov/participate/send-your-name/future">https://mars.nasa.gov/participate/send-your-name/future</a></p></li><li><p>填入个人信息：（姓名可以输入中文）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/202009131kk719.png" alt="Snipaste_2020-09-13_17-29-23"></p><ul><li>至此，就获得了前往火星的纪念品登机证：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20201003212717.jpeg" alt="BoardingPass_MyNameOnFutureMission"></p><p>让你的名字代替你先去火星旅行吧！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.nasa.gov/press-release/nasa-invites-public-to-submit-names-to-fly-aboard-next-mars-rover">NASA Invites Public to Submit Names to Fly Aboard Next Mars Rover</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.ifanr.com/1216268">现在，NASA 可以将你的名字送到火星上去</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>人文派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈蓝牙 Mesh 组网技术</title>
    <link href="/posts/63c7.html"/>
    <url>/posts/63c7.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文主要根据蓝牙兴趣联盟（SIG）以及其官方微信公众号关于蓝牙 Mesh 组网的相关博文进行梳理，旨在对蓝牙 Mesh 组网技术有一个初步的认识。</p>          </div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>蓝牙 Mesh 脱胎于 CSR 倡导的私有协议- CSR Mesh，该技术诞生于 2014 年。</p><p>蓝牙技术联盟（SIG）于去年 7 月 19 日正式宣布，蓝牙技术开始全面支持 Mesh 网状网络。<strong>蓝牙 Mesh 组网是一种组网技术</strong>，蓝牙 4.0 以上支持低功耗蓝牙的芯片都支持。全新的 Mesh 功能提供设备间多对多传输，并特别提高构建大范围网络覆盖的通信能力，适用于楼宇自动化、无线传感器网络等需要让数以万计个设备在可靠、安全的环境下传输的物联网解决方案。如今，蓝牙适用的范围已经逐渐拓展到所有物联网边缘场景：“蓝牙增强速率技术（BR &#x2F; EDR）” 的应用从无线耳机发展到鼠标键盘；“蓝牙低功耗技术” 应用于手表、手环，发掘了可穿戴市场；而“蓝牙 Mesh 组网技术”则瞄准了整个（边缘域）物联网市场，包括消费领域和工业领域<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[蓝牙 Mesh 简介](http://www.xmamiga.com/3433/)">[1]</span></a></sup>。</p><iframe width="560" height="315" src="https://player.vimeo.com/video/225874947" frameborder="0" allowfullscreen></iframe><h2 id="低功耗蓝牙（BLE）"><a href="#低功耗蓝牙（BLE）" class="headerlink" title="低功耗蓝牙（BLE）"></a>低功耗蓝牙（BLE）</h2><p>要讨论蓝牙 Mesh 组网技术就必须先说明低功耗蓝牙（Bluetooth Low Energy, BLE），因为蓝牙 Mesh 网络使用、并且依赖于低功耗蓝牙。<strong>低功耗蓝牙技术是蓝牙 Mesh 使用的无线通信协议栈<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[An Intro to Bluetooth Mesh Part 1](https://www.bluetooth.com/blog/an-intro-to-bluetooth-mesh-part1/)">[2]</span></a></sup>。</strong></p><p>首先蓝牙是一种短距离通信的无线电技术。其特点为：</p><ul><li>分散式网络结构；</li><li>点对点或多点通信；</li><li>快跳频和短包技术；</li><li>工作在2.4GHz ISM 频段（Industrial Scientific Medical Band）；</li><li>时分全双工传输。</li></ul><p>低功耗蓝牙泛指蓝牙 4.0 或更高的模块，蓝牙低功耗技术是一种低成本、短距离、可互操作的无线技术通信技术，工作在免许可的2.4GHz ISM 射频频段。相比于传统蓝牙（Classic Bluetooth，BT），低功耗蓝牙拥有更低的功耗，更远的传输距离，以及可以实现 AOA 室内定位。现如今的电子设备基本都配备 BLE 4.0 以上的蓝牙模块。例如我们的无线耳机，智能手环以及各种红黄蓝绿的单车等设备都使用到了低功耗蓝牙模块进行通信。</p><p><strong>BLE 低功耗蓝牙和传统蓝牙有以下5大区别<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[The Fundamental Concepts of Bluetooth Mesh Networking Part 1](https://www.bluetooth.com/blog/the-fundamental-concepts-of-bluetooth-mesh-networking-part-1/)">[5]</span></a></sup>：</strong></p><ol><li>低功耗蓝牙的发送和接受任务会以最快的速度完成，完成之后蓝牙 BLE 会暂停发射无线（但是还是会接受），等待下一次连接再激活；传统蓝牙是持续保持连接；</li><li>低功耗蓝牙的广播信道（为保证网络不互相干扰而划分）仅有 3 个；传统蓝牙是 32 个；</li><li>低功耗蓝牙“完成”一次连接(即扫描其它设备、建立链路、发送数据、认证和适当地结束)只需 3ms；传统蓝牙完成相同的连接周期需要数百毫秒；</li><li>低功耗蓝牙使用非常短的数据包，多应用于实时性要求比较高，但是数据速率比较低的产品，遥控类的如键盘，遥控鼠标，传感设备的数据发送，如心跳带，血压计，温度传感器等；传统蓝牙使用的数据包长度较长，可用于数据量比较大的传输，如语音，音乐，较高数据量传输等；</li><li>低功耗蓝牙无功率级别，一般发送功率在 +4dBm，一般在空旷距离，达到 70m 的传输距离；传统蓝牙有3个功率级别，Class1，Class2，Class3，分别支持 100m，10m，1m 的传输距离。</li></ol><p>蓝牙低能耗架构共有两种芯片构成：单模芯片和双模芯片。蓝牙单模芯片可以和其它单模芯片及双模芯片通信，此时后者需要使用自身架构中的蓝牙低能耗技术部分进行收发数据。双模芯片也能与标准蓝牙技术及使用传统蓝牙架构的其它双模芯片通信。</p><h2 id="蓝牙-Mesh-组网"><a href="#蓝牙-Mesh-组网" class="headerlink" title="蓝牙 Mesh 组网"></a>蓝牙 Mesh 组网</h2><div class="note note-danger">            <p>蓝牙 Mesh 技术并非无线通信技术，而是一种网络（组网）的技术，用于构建 “多对多通信连接” 的网络。</p>          </div><p>简单来说，蓝牙 Mesh 组网就是将众多的蓝牙设备互相连接，进而组成一个网络。各个蓝牙设备在网络中被称为节点（某些关键节点被称为网关）。各节点之间能够互相进行通信。</p><p><strong>蓝牙 Mesh 能让我们建立无线设备之间的“多对多”（m:m）关系</strong>。此外，设备能够将数据中继到不在初始设备直接无线电覆盖范围内的其他设备。这样，Mesh 网络就能够跨越非常大的物理区域，并包含大量设备。</p><blockquote><p>The new mesh capability enables many-to-many (m:m) device communications and is optimized for creating large-scale device networks. It is ideally suited for building automation, sensor networks, and other IoT solutions where tens, hundreds, or thousands of devices need to reliably and securely communicate with one another<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[An Intro to Bluetooth Mesh Part 1](https://www.bluetooth.com/blog/an-intro-to-bluetooth-mesh-part1/)">[2]</span></a></sup>.</p><p>新的网状功能可实现多对多 (m:m) 设备通信，并为创建大规模设备网络进行了优化。它非常适合楼宇自动化、传感器网络和其他物联网解决方案，在这些方案中，几十台、几百台或几千台设备需要可靠和安全地相互通信。</p></blockquote><p>对于满足日益普及的各种通信需求，Mesh 拓扑结构能提供最佳的方式，因此蓝牙 Mesh 网络应运而生，典型的应用包括楼宇自动化和传感器网络等。这些通信需求包括：</p><ul><li>覆盖面积广</li><li>“直联互通性”</li><li>监测和控制大量设备的能力</li><li>经优化的、低功耗的</li><li>有效利用无线电资源，有可扩展性</li><li>与当前市场上的智能手机、平板电脑和个人电脑产品兼容</li><li>符合行业标准，具有政府级安全性</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><p><strong>以消息为中心的通信</strong></p><p><strong>蓝牙 Mesh 网络使用发布&#x2F;订阅 (publish&#x2F;subscribe)消息系统</strong>。</p><p>设备可以将消息发送至特定地址，这些地址的名称和含义与用户能够理解的高级概念相对应，如“花园灯”(Garden Lights)。这被称为“发布”（publishing）。</p><p>设备经配置后，可接收由其他设备发送到特定地址的消息。这被称为“订阅” (subscribing) 。</p><p>当设备向特定地址发布消息时，订阅该地址的所有其他设备将收到该地址的副本，对其进行处理，并以某种方式作出回应。</p><p>想象一下花园里安装的一套户外灯, 每盏灯都已经过配置，以便其订阅“花园灯”消息。现在，想像一个蓝牙Mesh 电灯开关向“花园灯”地址发送了 “开” 的消息。没错，花园里的所有灯都会收到 “ON” 消息，并做出开灯的回应。<img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200913131151.png" alt="Snipaste_2020-09-13_13-11-08"></p></li><li><p><strong>消息和设备状态</strong></p><p><strong>“状态” (state) 是蓝牙 Mesh 网络中的一个关键概念</strong>。蓝牙 Mesh 网络中的每台设备都具有一组独立的状态值，表示设备的某些状态。在花园灯的示例中，每盏灯都有一个状态值，表示设备当前是处于打开或关闭状态。通过发布一类在定义上意味着能够回应“开”或“关”状态值的消息，来改变状态值，蓝牙 Mesh 电灯开关就能对灯泡进行控制。更改状态值会修改设备本身的物理状况，例如打开或关闭设备。</p><p>消息、状态、以及这些和其他概念相关的设备行为已被定义在规格中，称为“模型”（modules）。模型由蓝牙Mesh 设备实施。</p></li><li><p><strong>中继</strong></p><p><strong>得益于 Mesh 网络，设备可以在非常广阔的区域中安装，同时彼此之间保持通信。</strong>想象一下购物中心、机场或办公大楼的占地空间有多广阔。因为存在墙壁和其他物理上的障碍物，楼宇中的设备可能无法与安装在同一楼宇远侧的设备、或临近楼宇中的设备建立直接的无线连接。而蓝牙 Mesh 网络则能够将网络中的某些设备指定为“中继设备”，进而解决这一难题。</p><p><strong>中继设备能够转发从其他设备接收到的消息。</strong>在转发消息时，它们能够与位于初始消息发布设备无线范围以外的设备进行通信。消息可多次被中继，每一次中继即为一 “跳”，最多可进行 127 跳，足以在一片广阔的物理区域中进行消息传输。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200913125504.png" alt="Snipaste_2020-09-13_12-54-27"></p></li><li><p><strong>管理型网络泛洪（Managed Flooding）</strong></p><p><strong>蓝牙 Mesh 网络采用一种称为 “网络泛洪（flooding）” 的方式来发布和中继消息。</strong>这意味着消息不会通过某一进程进行路由, 也不会沿着由一系列特定设备构成的特定路径来进行传输。相反，传输范围内的所有设备都会接收消息，负责中继的设备能将消息转发至其传输范围内的所有其他设备。</p><p><strong>网络泛洪的优势在于无需特定设备专门扮演集中式路由器的角色。</strong>集中式路由器一旦发生故障，就可能会导致整个网络无法运行。没有特定的路由也可能对网络造成灾难性的影响，但这种情况也可以通过在 Mesh 网络中采用网络泛洪的方法来避免。</p><p>网络泛洪的方式也意味着消息一般能够通过多重路径到达其目的地。<strong>这就构建了一个相当可靠的网络。</strong></p><ul><li><p><strong>优化 Mesh 网络</strong></p><p><strong>蓝牙 Mesh 网络也采取了一系列措施，支持采用网络泛洪的方式，同时优化每台设备、甚至整体网络的能耗。</strong></p><p>所有数据包都包含一个称为 TTL 的字段，它可用于限制消息中继的跳数。由设备间歇性发送的心跳消息中包含的信息，能够让网络了解其拓扑结构、以及传到其他每台设备之间的跳数。这能够让设备将 TTL 设置为最佳值，从而避免不必要的中继操作。</p><p>每台设备都包含消息缓存，以确定自身是否已经中继过该消息。如果是，则会立即丢弃该消息，从而避免上层堆栈进行不必要的处理。</p></li></ul><p>功率非常受限的设备（例如由小型电池持续供电多年的传感器）可能被指定为 “低功耗节点”。<strong>低功耗节点能够与一个或多个被指定为 “friends” 的设备协同工作。</strong>Friends 并非功率受限，它可以作为低功耗节点，存储寻址到这一低功耗节点的消息，并且只有在低功耗节点需要时才传送消息。<strong>低功耗节点和 “friends” 之间的关系理所当然就称为 “friendship”。</strong></p></li></ul><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ul><li><p><strong>节点（Node）</strong></p><p><strong>蓝牙 Mesh 网络中的这些设备被称为节点 (node) 。</strong>每个节点都能发送和接收消息。信息能够在节点之间被中继，从而让消息传输至比无线电波正常传输距离更远的位置。</p></li><li><p><strong>元素（Elements）</strong></p><p>一些节点（如传感器）的电池有可能会被耗尽，而其他节点（如照明设备、制造机械和安防摄像机）则会通过主电网来获取电力。一些节点的处理能力会高于其他节点。这些节点在 Mesh 网络中可承担更为复杂的任务，扮演不同的角色，表现出 <strong>以下四个节点特征（Features）</strong>：</p><div class="note note-primary">            <p><strong>低功耗 (Low-Power) 特性</strong></p><p>功率受限的节点可能会利用低功耗特性来减少无线电接通时间并节省功耗。同时低功耗节点（LPN）可以与friend 节点协同工作。</p>          </div><div class="note note-success">            <p><strong>Friend 特性</strong></p><p>功率不受限的节点很适合作为 friend 节点。Friend 节点能够存储发往低功耗节点（LPN）的消息和安全更新；当低功耗节点需要时再将存储的信息传输至低功耗节点。</p>          </div><div class="note note-warning">            <p><strong>中继 (Relay) 特性</strong></p><p>中继节点能够接收和转发消息，通过消息在节点之间的中继，实现更大规模的网络。节点是否能够具备这一特性取决于其电源和计算能力。</p>          </div><div class="note note-info">            <p><strong>代理 (Proxy) 特性</strong></p><p>代理节点能够实现 GATT 和蓝牙 Mesh 节点之间的 Mesh 消息发送与接收。承担这一角色的节点需要固定的电源和计算资源。</p>          </div><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200913134652.png" alt="Snipaste_2020-09-13_13-46-07"></p><p><strong>一些节点的复杂性高于其他节点，由多个称为元素（Element）的独立部分组成。</strong>每个节点至少拥有一个元素，称为主元素（Primary Element），同时还可能包含其他多个元素。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200913132902.png" alt="Snipaste_2020-09-13_13-28-21"></p><p><strong>元素由定义节点功能和元素条件的实体组成。</strong>例如，一个灯泡内有一个元素, 并具有两种功能：</p><div class="note note-danger">            <p><strong>节点 &#x3D; 灯泡</strong></p><p><strong>一个元素 &#x3D; 主元素</strong></p><p><strong>节点功能：</strong></p><p>​           - 开&#x2F;关</p><p>​           - 亮度</p><p><strong>元素条件&#x2F;状态：</strong></p><p>​           - “开”或“关”</p><p>​           - 0 – 10 (亮度等级)</p>          </div><p>节点中的每个元素都有一个唯一的地址，称为单播地址（unicast address），使每个元素都有址可寻。</p></li><li><p><strong>模型 (Model) 和状态 (State）</strong></p><p>无论节点位于制造厂房、酒店、办公楼、还是商业园区的网络中，节点的基本功能都由模型（Model）来定义和实施。模型位于元素内，元素必须具有至少一个模型。<strong>模型能够定义并实施节点的功能和行为，而状态 (State) 能够定义元素的条件</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200913133144.png" alt="Snipaste_2020-09-13_13-31-29"></p><p>以灯泡为例，该模型的功能是开关和调节亮度。相关的状态分别为 “开” &#x2F; “关” 和 0-10：</p><div class="note note-danger">            <p><strong>模型 (节点功能)</strong></p><p>​       <strong>1. 开&#x2F;关</strong></p><p>​          状态 -&gt; “开” 或 “关”</p><p>​       <strong>2. 亮度 (0-10)</strong></p><p>​          状态 -&gt; 0-10</p>          </div><p>蓝牙 Mesh 支持复合状态，即由两个或多个值组成的状态。变色灯就是这样的一个例子，色调可以不受颜色饱和度或亮度的局限而改变。</p><p><strong>“绑定状态” (Bound State) 这一术语的定义源自一种状态的变化导致另一状态变化的情况。</strong>级别状态和开&#x2F;关状态通常就相互绑定。如果级别从0变为1，则“开&#x2F;关”的状态也从“关”变为“开”。</p><p>每个模型都有唯一的标识符。蓝牙技术联盟采用 16 位的模型，而供应商采用 32 位（其中包含蓝牙技术联盟指定的16位公司标识符以及16位供应商指定的模型标识符）。<strong>这确保了每个模型的地址都独一无二并且能确定被寻址到。</strong></p><p><strong>蓝牙 Mesh 网络可借助消息，通过客户端 - 服务器架构进行通信。</strong>服务器的功能是暴露元素的状态。最简单的状态之一是二进制开关，其中状态为“开”或“关”。简单的服务器模型是通用开&#x2F;关服务器模型 (Generic On&#x2F;Off Server Model) ，其中包含表示开关开启或关闭的状态。</p><p>客户端可对状态进行访问，请求、更改或使用服务器的状态。举例来说，一个简单的客户端模型就是通用开&#x2F;关客户端模型（Generic On&#x2F;Off Client Model）（二进制开关）。通用开&#x2F;关客户端模型通过发送消息来控制通用开&#x2F;关服务器模型。例如，客户端可利用这一机制开启或关闭指示灯。</p></li></ul><h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><p><strong>蓝牙 Mesh 网络引入了全新的协议栈</strong>。这一协议栈建立在低功耗蓝牙技术之上。下图描绘了<strong>协议栈的层级</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200913134823.png" alt="Snipaste_2020-09-13_13-48-12"></p><ul><li><strong>承载层（bearer layer）：</strong>承载层定义了如何使用底层低功耗堆栈传输 PDU。目前定义了两个承载层：广播承载层（Advertising Bearer）和 GATT 承载层。</li><li><strong>网络层（network layer）</strong>：网络层定义了各种消息地址类型和网络消息格式。中继和代理行为通过网络层实施。</li><li><strong>底层传输层（lower transport layer）：</strong>在需要之时，底层传输层能够处理 PDU 的分段和重组。</li><li><strong>上层传输层（upper transport layer）</strong>：负责对接入层进出的应用数据进行加密、解密和认证。它还负责称为 “传输控制消息”（transport control messages）这一特殊的消息，包括与 “friendship” 相关的心跳和消息。</li><li><strong>接入层（access layer）：</strong>负责应用数据的格式、定义并控制上层传输层中执行的加密和解密过程，并在将数据转发到协议栈之前，验证接收到的数据是否适用于正确的网络和应用。</li><li><strong>基础模型（foundation models）：</strong>基础模型层负责实现与 Mesh 网络配置和管理相关的模型。</li><li><strong>模型（models）：</strong>模型层与模型等的实施、以及诸如行为、消息、状态等的实施有关。</li></ul><p>节点（如照明装置、温控设备、制造设备和电动门）是蓝牙 Mesh 网络中能够发送、接收或中继消息的设备。消息（message）用于在节点之间传输数据，地址（address）用于定义消息源（source）地址和目的（destination）地址。</p><h3 id="地址（Address）"><a href="#地址（Address）" class="headerlink" title="地址（Address）"></a><strong>地址（Address）</strong></h3><p><strong>地址有四种类型，其中的三类用于消息的传送：单播（unicast）、虚拟（virtual）和群组（group）地址。第四种被称为未分配（unassigned）地址。</strong>地址长度为16位，并按下述定义进行编码。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200913135kk700.webp" alt="640"></p><div class="note note-primary">            <p>  <strong>未分配地址（Unassigned Address）</strong></p><p>未经配置的元素或未被指定地址的元素拥有的就是未分配地址。鉴于这些元素没有唯一的地址，<strong>它们不会用于消息的传送。</strong></p>          </div><div class="note note-secondary">            <p>  <strong>单播地址（Unicast Address）</strong></p><p>在“启动配置”（provisioning）期间，启动配置设备（provisioner）会在网络节点的生命周期内为节点中的每个元素分配一个单播地址。单播地址可能出现在消息的源地址字段或目的地址字段中。<strong>发送到单播地址的消息只能由一个元素进行处理。</strong></p>          </div><div class="note note-success">            <p>  <strong>虚拟地址（Virtual Address）</strong></p><p><strong>虚拟地址是与特定的 UUID 标签相关联的一组元素</strong>；这些地址可能会被发布或订阅。UUID 标签是与多个来自一个或多个节点的元素相关联的 128 位值。</p><p>对于虚拟地址，15 和 14 位分别设置为 1 和 0；13 – 0 位被设置为散列值（hash value）（提供 16384 个散列值）。散列（hash）来自于 Label UUID。使用订阅元素（subscribing element）来检查完整的 128 位 UUID 是十分低效的，特别当 UUID 跨越多个消息段时更为低效。<strong>散列值提供了一种更为有效的方式来确定哪些消息被发送至哪些元素。</strong></p>          </div><div class="note note-info">            <p><strong>群组地址（Group Address）</strong></p><p><strong>群组地址是蓝牙 Mesh 网络中的另一种多播地址（multicast address）</strong>，它通常代表一个或多个节点中的多个元素，包含两种类型：</p><ul><li>动态分配的地址（Dynamically Assigned） -&gt; 0xC000-0xFEFF</li><li>固定地址（Fixed Address） –  由蓝牙技术联盟分配，分为五段。</li></ul>          </div><h3 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）"></a>消息（Message）</h3><p><strong>蓝牙 Mesh 网络通过消息进行通信。消息可以分为控制消息和接入消息。</strong></p><div class="note note-warning">            <p><strong>控制消息（Control Message）：</strong>与蓝牙 Mesh 网络操作有关的消息，例如心跳（heartbeat）和 friend 的请求消息。</p><p><strong>接入消息（Access Message）：</strong>该类消息允许客户端模型检索或设置服务器模型中的状态值，或被服务器用于报告状态值。</p>          </div><p>模型可实施并定义节点的功能。<strong>元素是节点内唯一可被寻址的实体（节点中可包含一个或多个模型），并由状态（state）定义元素的状况变化</strong>。对于每个状态，都有一组服务器模型支持的消息。例如请求状态值或请求改变状态的客户端模型、以及发送状态或状态改变相关消息的服务器模型。</p><p><strong>接入消息分为两类：经确认的（acknowledged）和未经确认的（unacknowledged）</strong>。经确认的消息被发送至每个接收元素，并经其确认。响应通常为状态消息。对于未经确认的消息则不作出响应。<strong>例如蓝牙 Mesh 网络的状态消息就是一种未经确认的消息。</strong></p><h3 id="安全（Security）"><a href="#安全（Security）" class="headerlink" title="安全（Security）"></a>安全（Security）</h3><p><strong>所有蓝牙 Mesh 网络消息的安全保障都来自网络密钥（NetKey）和应用密钥（AppKey）对消息的加密和验证。</strong>NetKey 用于网络层通信。假设蓝牙 Mesh 网络没有子网，则该 Mesh 网络内的所有通信都使用相同的网络密钥。</p><p><strong>AppKey 用于应用程序的数据。</strong>网络中的一些节点具有特定应用，并且根据应用的需要对一些潜在敏感数据的访问进行限制。这些节点具有特定的 AppKey，并与特定应用相关联。会使用不同 AppKey 的领域通常包括安全（楼宇门禁、机房门禁和 CEO 办公室门禁）、照明（制造厂房、外部楼宇照明和人行道）和 HVAC 系统。</p><p>中继节点（relay node）（如灯泡或墙壁开关）通常具有有效的 NetKey，能够在网络内中继敏感性消息。然而，这些节点无法访问各种限制区域（如楼宇控制或 HVAC 系统）的特定 AppKey，，亦无法解密应用程序的数据。</p><h3 id="启动配置（Provisioning）"><a href="#启动配置（Provisioning）" class="headerlink" title="启动配置（Provisioning）"></a>启动配置（Provisioning）</h3><p>启动配置的全过程包括大概 5 个步骤<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[蓝牙 Mesh 简介](http://www.xmamiga.com/3433/)">[1]</span></a></sup>, 分别是：</p><ul><li>Beaconing: 发送Beacon信号，告诉你我要配网, 这里使用的是新定义的 AD 广播包类型, Mesh AD；</li><li>Invitation: 配网者 Provisioner 听到了这个 Beacon 以后, 就发一个邀请, 用的就是配网邀请 PDU（Protocol Data Unit）；</li><li>Exchanging Public Keys: 交换公钥；</li><li>Authentication: 一个互动随机数的认证流程；</li><li>Distribution of the Provisioning Data: 认证完成, 从公钥和两个设备的私钥派生出 Session Key，后面的配网的信息交互的过程会用这个 Session key 来加密， 配网成功以后, 就会根据最后一步里面包含交换的 NetKey 来加密后面的数据交换</li></ul><h3 id="信息交换"><a href="#信息交换" class="headerlink" title="信息交换"></a>信息交换</h3><p><strong>蓝牙 Mesh 网络使用发布&#x2F;订阅 (publish&#x2F;subscribe) 模型来进行消息传输。</strong>生成消息的节点会发布消息。需要接收消息的节点会订阅它们所需的地址。消息可被发布至单播、群组或虚拟地址。</p><p><strong>消息可以作为对其他消息的回复而发送，也可以作为非请求消息（unsolicited messages）被发送。</strong>当模型发送回复消息时，使用消息始发处的源地址作为目标地址。发送非请求消息时，模型将使用模型的发布地址作为目标地址。节点中的每个模型都有一个发布地址。</p><p>接收消息时，节点内模型（节点中可能存在多个模型）中的每个实例均可通过订阅方式从一个或多个群组或虚拟地址接收消息。</p><p>订阅消息的模型使用模型的订阅列表来定义用于接收消息的有效地址。当模型接收到消息时，模型将检查其订阅列表。<strong>当订阅列表上的地址设置为模型的元素单播地址或属于该节点的固定群组地址时，则视为一个匹配（match）。</strong>下图表示了接入消息的有效源地址和目标地址。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200913141452.webp" alt="640 (1)"></p><p>蓝牙 Mesh 实体发布各种节点的状态时，无论其与发送数据的节点位置距离远近,整个蓝牙 Mesh 网络中的系统均可订阅该数据。<strong>这就实现了网络一端的设备可通过低功耗无线消息与设施中的其他的管理者进行对话，而不受距离限制。</strong></p><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><div class="note note-success">            <ul><li><p><a href="https://www.bluetooth.com/blog/bluetooth-mesh-networking-series-friendship/">Bluetooth Mesh Networking: Friendship</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTg3MTg2Mg==&mid=2651236984&idx=3&sn=a9ed5551ba9703a9ee93ed03a8459de5&chksm=847c5ce1b30bd5f71cca73920a9b1808d16372d8076ebcd226ece022f98a79d2eb7e331ffa21&scene=21#wechat_redirect">蓝牙mesh网络 （ 友谊篇 ）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTg3MTg2Mg==&mid=2651236997&idx=1&sn=99975f2b3930e36a2e8a040beed7cb75&chksm=847c5c1cb30bd50acc8745f37b2fa733171e2757529ac386cea58e6d2d62c326691e70888469&scene=21#wechat_redirect">蓝牙mesh网络（设备管理）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTg3MTg2Mg==&mid=2651237018&idx=1&sn=87b36c6b36ead981e8b89903bcb0880f&chksm=847c5c03b30bd51596d772121c1454393a5dc3b2b03fc41a0eb590847cc8c4dde9b89c0a6f0a&scene=21#wechat_redirect">蓝牙mesh网络（安全性概览）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/aS16lAPmy4IRUgmcvqYe8g">蓝牙mesh网络（启动配置Part1）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/yaixqoR5s87c3uw5Uw7ccA">蓝牙mesh网络（启动配置Part2）</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/o2oTlXjzcbr0bDEU89uGuA">潜入蓝牙mesh海洋深处</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/4g9dvRy3eJ9ToyMFWiDScQ">蓝牙mesh | “三大法宝“让你的网络无懈可击</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/cFn3xQ4X3e87viqyDhJM_Q">蓝牙mesh网络：走进数据包</a></p></li></ul>          </div><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>虽然蓝牙 Mesh 组网技术的协议早已提出，但个人感觉相关 SDK 开发包仍不太成熟。不过未来应用场景仍然是可以畅想的。</p><p>正如蓝牙兴趣联盟所畅想的一样：</p><blockquote><p>我们期待蓝牙 Mesh 网络广泛应用于各行各业和各种应用，预计最初会从<strong>楼宇自动化、商业照明和传感器网络</strong>等应用开始。尤其令人兴奋的是<strong>蓝牙 Mesh 网络在商业照明方面的应用</strong>。试想一下，有了正确的固件，照明系统能实现的就不仅是无线灯光控制，还能够成为楼宇中各种蓝牙服务的平台，如物资跟踪和定位服务！</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://www.xmamiga.com/3433/">蓝牙 Mesh 简介</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bluetooth.com/blog/an-intro-to-bluetooth-mesh-part1/">An Intro to Bluetooth Mesh Part 1</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.bluetooth.com/blog/an-intro-to-bluetooth-mesh-part2/">An Intro to Bluetooth Mesh Part 2</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.bluetooth.com/blog/introducing-bluetooth-mesh-networking/">Introducing Bluetooth Mesh Networking</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.bluetooth.com/blog/the-fundamental-concepts-of-bluetooth-mesh-networking-part-1/">The Fundamental Concepts of Bluetooth Mesh Networking Part 1</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://www.zhihu.com/question/48722431/answer/599493049">BLE和传统蓝牙有什么区别，各有什么优缺点？</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://blog.csdn.net/zhanghuaishu0/article/details/78770486">蓝牙mesh — 解密蓝牙mesh系列文章汇总</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>打球手歪后，我却要安利「蜜雪冰城」</title>
    <link href="/posts/6591.html"/>
    <url>/posts/6591.html</url>
    
    <content type="html"><![CDATA[<h2 id="受伤"><a href="#受伤" class="headerlink" title="受伤"></a>受伤</h2><p>昨天下午打球，接球的时候小拇指被急速飞来的球给打折了… 小拇指靠近指甲的第一、第二个关节给往外翻 30° 左右 。疼得我立马没知觉了。可怕的是我当时看着这扭曲的小拇指竟然 <strong>顺手给掰回来了</strong> 。</p><p>随后下场休息，准备再战（现在想来当时我脑子是瓦特掉了吗？）。坐了大概 30s 后就感觉眼前很模糊，眼睛无法聚焦，就像以前贫血的症状一样。当时以为缓一缓就没事了，结果一分钟后仍然这样，并且被我强行掰回来的手指开始痛了。之后马上打电话叫室友来医务室陪我，我凭感觉自行走到医务室去（因为当时眼前依旧很模糊，我也太逞能了，还好没直接晕倒）。</p><p>到医务室后，校医听我情况后马上让室友扶着我去床上躺下。给我喝了两大杯糖水后，我的意识才慢慢缓过来。</p><h2 id="冰敷之旅"><a href="#冰敷之旅" class="headerlink" title="冰敷之旅"></a>冰敷之旅</h2><p>听闻学校的「冰雪蜜城」能提供冰块，于是买杯奶茶后要了点冰块。可…这店员小姐姐给得也太多了吧~</p><p>不禁喃喃自语，我要对外安利「冰雪蜜城」，不是因为他家的奶茶好喝，而是他家冰给得多。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200906001636.JPG" alt="IMG_7001"></p><p>回寝室之后开始冰敷，这酸爽手指都快没知觉了。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200906002103.JPG" alt="IMG_7009"></p><p><strong>2 Hours Later</strong> ，小拇指在冰水里遨游~</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200906002827.JPG" alt="IMG_7011"></p><p><strong>20 Hours Later</strong>，继续白嫖他家冰块，但嘱咐道只需要半口袋的冰就行了😂。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200906003125.JPG" alt="IMG_7016(20200905-224640)"></p><h2 id="医院插曲"><a href="#医院插曲" class="headerlink" title="医院插曲"></a>医院插曲</h2><p>我状态恢复之后，校医建议我去医院拍片检查一下。随后到某第一人民医院挂急诊去检查，结果医生说：</p><blockquote><p>「 你都自己掰回来了，还检查什么呀。我不信你这样就能把骨头弄断不。」</p></blockquote><p>我：</p><blockquote><p>「 ？？？」</p></blockquote><p>这时进来了另外一位医生，我那位外科医生说到:</p><blockquote><p>「这位就是骨科医生，不信你可以问他。」</p></blockquote><p>于是我那位外科急诊医生拿着我食指对骨科医生说我的情况，这时我急忙打断道：</p><blockquote><p>「不是这只手指，是小拇指这只。」</p></blockquote><p>随即，他尴尬地笑了笑…我无奈地摇了摇头。</p><p>之后骨科医生建议我先观察两天，后续有情况再挂骨科门诊，不要挂急诊。</p><p>于是我点头道谢，这点头是为了后半句话…</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>虽说是安利「冰雪蜜城」，但其实也为了苦中作乐，<del>老实说真心觉得不太好喝</del>。</p><p>最应该感谢的其实是负责的校医。看得出来校医当时得知我头晕眼花，又加之没吃晚饭后，觉得事态有点严重，说话的口气都变得紧张起来，不过搞得我心更慌了😂，估计是怕我休克吧。</p><p>此外还要感谢我的可爱室友 @强强，耽搁了他复习 GET 的时间（就是因为这一晚上，他考不了 100 分了，害）</p><p>这件事给我敲了个警钟：</p><ul><li>一定要及时寻求帮助</li><li>一定要吃了饭去运动</li><li>一定要有个好室友</li></ul>]]></content>
    
    
    <categories>
      
      <category>生活派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>这喵眼里有整个星空</title>
    <link href="/posts/fb22.html"/>
    <url>/posts/fb22.html</url>
    
    <content type="html"><![CDATA[<p>元宝是一只小布偶猫 🐱，老姐 <a href="https://www.instagram.com/chizi_wmd/">@chizi</a> 家的新成员。</p><p>在与她相处的两天时间中，每当在日光之下对视她碧蓝色双眼的时候，我时常会产生「当我凝视这双眼睛时，我在思考什么」的迷思。</p><p>是深沉的大海、静谧的银河还是整个星空 ✨？    <del>（别 ™ 瞎想了，其实是有蓝眼基因）</del></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/202008300k15037.JPG" alt="IMG_6930(20200828-191808)"></p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/202008300115kk11.JPG" alt="IMG_6924(20200830-004034)"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200830011kk502.JPG" alt="IMG_6927(20200830-004049)"></div><div class="group-image-wrap"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200830011447.JPG" alt="IMG_6926(20200830-004059)"></div></div></div><p>​                     </p><p>👫🏼 <strong>元宝的老妈与老爸</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200830012112.JPG" alt="IMG_6967(20200828-210238)"></p><center>（老妈的哺乳期照，👆 其中某一只就是元宝啦）</center><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200830012103.JPG" alt="IMG_6968(20200828-210241)"></p><center>（这位爹看起来憨憨的 👆）</center><p>​                        </p><p>😺 <strong>元宝的特写时刻</strong>        </p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200830013056.JPG" alt="IMG_6955(20200830-003859)"> </p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200830013117.JPG" alt="IMG_6950(20200830-003823)"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200830013107.JPG" alt="IMG_6946(20200828-182508)"></p><p>明天就回学校了，等下次回来见你的时候，你肯定得窜一大头了吧。</p>]]></content>
    
    
    <categories>
      
      <category>生活派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客域名更换小记</title>
    <link href="/posts/1f1b.html"/>
    <url>/posts/1f1b.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为内心其实是想拥有 <code>.com</code> 域名的，但建站初期脑子热，只想先把站点搭建起来再说。现在该搭建的也搭建好了，改润色的也润色完了，于是就打起了域名的主意。<del>（真相：下周就要开学了，想趁着开学再折腾一番）</del></p><h2 id="新域名解析"><a href="#新域名解析" class="headerlink" title="新域名解析"></a>新域名解析</h2><p>如何购买新域名的过程不再赘述，笔者是在 <a href="https://www.namesilo.com/">Namesilo</a> 购买的域名。</p><blockquote><p>优点：提供永久免费的域名隐私保护，防止别人通过 WHOIS 查询获取域名所有者的个人注册信息。</p><p>缺点：网站的网页设计也太丑了，一股扑面而来的 20 年前设计感。</p></blockquote><ul><li>购买新域名之后，需要将 GitHub page 的域名（你建站初期的 username.github.io 网址）解析到新域名。因为笔者使用了 Vercel 对网站进行托管，所以在域名解析处添加的是 Vercel 的域名。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/2020082712kk3539.png" alt="Snipaste_2020-08-27_12-30-00"></p><ul><li>打开 <code>你的博客目录\public</code> 下的 <code>CNAME</code> 文件，将里面旧域名更改为你的新域名地址。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200827124440.png" alt="Snipaste_2020-08-27_12-43-25"></p><ul><li>打开博客目录根下的 <code>_config.yml</code> 文件，将 url 地址改为新博客域名。</li></ul><p>至此已经完成了博客到新域名的解析，执行部署命令，就可以通过新域名访问博客。</p><div class="note note-danger">            <p>注：启用新域名后，文章链接会自动更换为新域名目录下的，不用手动更改。</p>          </div><h2 id="删除旧域名"><a href="#删除旧域名" class="headerlink" title="删除旧域名"></a>删除旧域名</h2><p>现在我们可以通过新旧两个域名来访问博客，但是显得很累赘。我们只想启用一个博客域名，所以现在需要将旧域名处的域名解析进行删除。</p><ul><li><p>删除旧域名处的域名解析，也就是将 username.github.io 的解析文件删除（CNAME 记录类型）；</p></li><li><p>删除 username.github.io对应的  A 记录类型的域名解析。</p></li></ul><p>笔者在基本上把过去添加的域名解析删干净了，包括百度站点或谷歌站点的认证记录，因为旧域名等于已经弃用了。</p><div class="note note-danger">            <p>注：因为笔者之前使用了 Vercel 对站点托管，所以此处还需要删去 Vercel 的解析域名。</p>          </div><h2 id="旧域名重新定向"><a href="#旧域名重新定向" class="headerlink" title="旧域名重新定向"></a>旧域名重新定向</h2><p>因为笔者的旧域名被友链收录，并且旧域名还有一年才到期。为了不麻烦友人重新填写站点信息 <del>（说得好像一年后还能跳转一样）</del>，所以需要将旧域名重新定向到新域名，以保证通过旧域名能自动跳转到新域名站点。</p><ul><li><p>参照以下博文创建新账号、新的 .io仓库并在就域名解析处添加新的 username.github.io 解析。</p><div class="note note-success">            <p>参考教程：<a href="https://www.cz5h.com/article/7f0e.html">Github托管站点的域名更换</a></p>          </div></li><li><p>在新账号的新仓库中添加以下四个文件（文件在 <a href="https://github.com/eren997/eren997.github.io">此处</a>下载并上传）。<img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200827135300.png" alt="Snipaste_2020-08-27_13-52-51"></p></li><li><p>修改其中 <code>404.html</code> <code>CNAME</code> <code>index.html</code> 这三个文件中的内容。将笔者的旧域名（erenspace.cool）替换为你的旧域名，将笔者的新域名（erenship.com）替换为你的新域名。</p></li><li><p>保存之后，重新部署。</p></li></ul><p>至此，我们便完成了对旧域名的重新定向。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我们来测验下最终效果：</p><ul><li>旧域名：<a href="https://erenspace.cool/">https://erenspace.cool</a></li><li>新域名：<a href="https://erenship.com/">https://erenship.com</a></li></ul><p>访问 <a href="https://erenspace.cool/">https://erenspace.cool</a> → 最终访问 <a href="https://erenship.com/">https://erenship.com</a></p><p>虽然完成了主域名的跳转，但是没实现旧域名全站内容跳转。不过好在建站不久，内容其实并不多。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.yanbinghu.com/2019/03/29/25951.html">多个域名映射同一个github pages</a></li><li><a href="https://www.cz5h.com/article/7f0e.html">Github托管站点的域名更换</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>曾经留下的评论与感想</title>
    <link href="/posts/1838.html"/>
    <url>/posts/1838.html</url>
    
    <content type="html"><![CDATA[<h2 id="🧐-前言"><a href="#🧐-前言" class="headerlink" title="🧐 前言"></a>🧐 前言</h2><p>大概是从大二开始，看了什么之后总会想写点儿评论。一方面是满足自我表达欲，另一方面也是想训练表达能力。虽然现在看来曾经的有些话显得很幼稚，甚至可笑。不过成长不正是逐渐发现曾经的自己是个 SB 的过程吗？Nobody cares~</p><div class="note note-success">            <p>在此将 2016 - 2019 年份自己曾经所写过的一些书评、影评由印象笔记转载于此博客，算是当个纪念，也好今后闲得无聊之时以作翻阅。</p>          </div><h2 id="📚-读后感"><a href="#📚-读后感" class="headerlink" title="📚 读后感"></a>📚 读后感</h2><h3 id="《被讨厌的勇气》"><a href="#《被讨厌的勇气》" class="headerlink" title="《被讨厌的勇气》"></a><a href="https://book.douban.com/subject/26369699/">《被讨厌的勇气》</a></h3><p><em>日期：2019-12-05</em></p><blockquote><p>一本给我不同方向的心理学书籍</p></blockquote><p>很早以前就有听过这本书，但是一直没看，觉得这类型的书应该在自己处于低谷时看收获才会大些。读罢，其实不然。</p><p>整本书以为长者同一个年轻人对话为载体，简明扼要地阐述了阿德勒心理学的要义。在看本书之前一直非常认同佛洛依德的理论，并且也赞同一个人的各种行为同他之前所经历过遭遇过的事情有很大的关系，甚至可以说是直接关系。看了这边书后得知这是所谓的原因论，即我们在判断一件事情的时候会从自己的过往去反过来分析为什么我会这样做。而在阿德勒的理论里面则是推崇目的论的，即我们在面对一件事情的时候应该从我们所期望达到的目的来行事，也就是说我当前所做的事情仅仅由当下的我来决定，同我以往所经历的没有任何关系。看似阿德勒将一个人的人生割裂了来进行评判，但其实将目的论的方式运用到人生中是避免了在做出选择时人们选择更加容易进行逃避的一方进行选择。</p><p>另外书中提到的学会进行课题分离是一个我认为对我启发非常大的一点。捋清楚哪些属于自己的人生课题，哪些又是属于别人的人生课题。不妄加干涉别人的课题，不忽视自己的人生课题，这样貌似确实能减少大量的烦恼和琐事。听起来会觉得自私，但是分离课题不是意味着自顾自地行事，相反地要更加注重平时对身边人的关心，也就是说将干扰别人课题的行为转变为适当的关系。这里就需要我们在平日中多去实践，把握调整好尺度的拿捏。</p><p>很早以前就听说过“人生所有的烦恼都是人际关系的烦恼”，当时自己不以为然，并列出了许多反例。不过在看过书中的阐述之后，觉得，嗯？好像有理耶。人是社会动物，除生死之外，许多意识都是建立在社会之中。身高、相貌、收入、幸福程度等等都是建立在自己所处的环境的基础之上。而我们需要学习的就是学会切断这些关系，学会进行课题分离。要知道其实许多的评价或者感受都是我们自己主观臆想出来的。</p><p>之后谈到的平等的话题，里面有句话让我感触很深。大意是如果一段关系是建立在压迫之下，或者一旦一方不屈服这段但关系便会迅速破碎，那么这段关系在一开始便没有存在的意义。就像你在一个学校受到不公待遇，争取之后无果，或者觉得继续待下去没有意义，那么你就不应该怕老师对你的危言耸听。当然，退学之类的事情在现实生活中是不那么容易处理的。书中提到，例如在上司提出的任务中明明有错，而你却不肯说出来，只是因为你的觉得这是顶撞或者怕上司，那么你其实实在逃避这段关系。而顶撞上司之类的话只是你的借口而已，对话是建立在双方平等的基础之上。</p><p>在最后的篇幅中，在自我价值的意义或者说是人生的意义上进行了阐述。他者贡献，也就是体现自我价值是非常重要的。并且学会将自己放进团体中，不管大或者小，这些团体会让你有存在的意义。在这里我想到了国外老人和国内老人的退休生活区别，国外老人好像都会加入许多社团组织之类的，积极参与各种公共事务。让感到自己存在的价值是需要付之于行动的，主动地进行帮助，清楚你能带给别人或者团体什么价值，这一点很重要。</p><p>最后，道理看似是懂了许多，但就像书中所提到要想真正领悟阿德勒的要义并转化为内在信念的话只少需要读者接触阿德勒心理学时的年龄的一半时间。比如你30岁接触到，那么你需要花15年才能真正理解并践行下去。当然，还有那么多别的知识没有去了解，我对此也是选择开放的态度来接受新的知识，指不定今后自己又会了解到什么新的心理学呢？Keep moving.</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200825010.webp" alt="3728268"></p><h3 id="《史蒂夫·乔布斯传》"><a href="#《史蒂夫·乔布斯传》" class="headerlink" title="《史蒂夫·乔布斯传》"></a><a href="https://book.douban.com/subject/6798611/">《史蒂夫·乔布斯传》</a></h3><p><em>日期：2019-11-13</em></p><blockquote><p>活在人文和科技的交叉点上</p></blockquote><p>读罢，了解了乔布斯更了解了苹果公司。就如同作者所言，这不是一部内部读物。他全面，完整地展现了乔布斯。他的易怒、暴躁、难以相处，他的智慧、勇敢、激情以及对艺术和极简的追求。</p><p>他创造了一个又一个划时代的产品，他颠覆了一个又一个行业。</p><p>我钦佩于他对于人文与科技的执着，赞叹于他的洞察力与远见。</p><p>乔布斯让我更加地开始反思自己在人文与理工科之间所设定的自我界限。乔布斯告诉了我，它们之间是可以亦如此优雅地方式结合.”我喜欢活在人文和科技的交叉点上”。</p><p>让我反思的是，纵观乔布斯一生，都是在同一批极其聪明和优秀的人打交道，哦，对了，他极其讨厌愚蠢的人浪费他的时间。</p><p>传奇的一生，辉煌而短暂。还记得在上初中时便从亲戚家夺过一台iphone4开始摆弄，那是自己还用着长辈之前淘汰下来的NOKIA NGAG-QD，一款极其笨重，搭载着nokia首个智能操作平台sybiam。当iphone拿在手中时，着实被那款诺达的屏幕和精致而简约的外观所吸引，还有那绚丽的UI和生动的缩放动画设计。</p><p>我庆幸在这个年纪中能够有乔布斯这样的人物，庆幸在自己人生的开始见证了电子设备的革命。</p><p>越是深入了解乔布斯，就越是了解苹果的文化，也就越是明白对外人来说为什么苹果的产品那么的不友好。因为你仅仅用到了乔布斯做创造出来的一部分，而这一部分是割裂的。乔布斯做追求的是硬件、软件、服务的完美结合。你需要至少拥有两台苹果设备才能体会到这一点。苹果产品的高价包含了产品成本以外的服务和体验。</p><p>最近开始喜欢传记，读那些自己一直感兴趣的领域的人的传记。了解他们，就更加了解行业，就能加知道自己在追寻什么。他们便是我的时代偶像吧。</p><p>始终保持对设计的审视，对美的追求。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200825010ddf324.webp" alt="3631544"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200825010355.webp" alt="3631545"></p><h3 id="《為何會拿好人卡》"><a href="#《為何會拿好人卡》" class="headerlink" title="《為何會拿好人卡》"></a><a href="https://book.douban.com/subject/26443930/">《為何會拿好人卡》</a></h3><p><em>日期：2019-03-05</em></p><blockquote><p>一段良好的关系来源于从心底里的认可</p></blockquote><p>托朋友从台湾带回来这本书，受益良多吧。起初是从他的部落格了解到他的，后来听了他tedx上的演讲，对于他所阐述的对于一段长期关系的看法自己非常的赞同，于是便想了解更多他的思考与观点。</p><p>这本书读起来倒是很快，可能是大部分理念自己之前在他的部落格里已经看了不少了，所以阅读起来比较快。</p><p>看完对于他所提到的关系模型有了更加全面的理解，对于目前自己身处什么阶段也更加清楚了。十分赞同他所提到的，“我们应该更好的去看透这个局”，时刻清楚自己处于什么位置，不至于最终进退两难又或者被自己的鲁莽冲动所控制。其实这本书也并不是同市面上所谓的把妹书籍一样，书中更加强调的是如何去开启和经营维系一段长久且健康的关系，同理可以延伸到其他所以的关系中。</p><p>就我个人而言，内心是十分认同这样如何建立长期健康的关系模式的，因为自己已经从这种模式中获得了友谊。就像作者在tedx和书中所强调的，只有让对方从心底里认同你这个人，这段关系才会是长久的，不会因为环境的改变或者其他客观因素而发生改变。没错，我们每个人的时间是有限的，不需要花时间在那些脆弱的感情之上。但在一段感情中我们也必须有意识的去做一些事情，好让事态的发展朝向好的方面。这无论是对于爱情或者友情都是这样的，又或者是其他泛泛之交。最核心的一点也就是让自己有价值起来，努力提升自己的内在价值。若不知道自己有什么价值，那么就想想如果你的朋友把你介绍给新朋友时他会怎样说呢？</p><p>不过话又说回来，纸上得来终觉浅，其实还有许多需要自己亲身去经历去学习的，不过得失心不会像以往那么重了，“得不到就是学到”。</p><h3 id="《象棋的故事》"><a href="#《象棋的故事》" class="headerlink" title="《象棋的故事》"></a><a href="https://book.douban.com/subject/2158684/">《象棋的故事》</a></h3><p><em>日期：2019-3-3</em></p><blockquote><p>人性总是多样的</p></blockquote><p>断断续续花了一年的时间看完。里面的故事深刻到让我发人深省，关于爱情、人性、勇气。毛姆和茨威格一样，同样作为我喜爱的作家，茨威格的心理描写更加的细致和深刻。逃避到异国的软弱画家、沉浸于曼妙文学中的有志青年、失魂落魄却又竭力寻求思维乐趣公爵以及那品德高洁的落魄演员和曾经的那位痴迷少女，这些故事或深沉或浅显地为我们刻画出了人性的多样性，还有那颗应该保持怎样纯洁高尚的心灵。</p><p>虽然说小时候喜欢看辞藻华丽的语言，长大后应看些朴实无华真切的描写。但茨威格的作品中这些句子并没有影响其故事的严肃性和文章的深度，阅读他们的作品总会在其阅读过程中不知不觉的进行自我教育、自我反思，以达到进一步完善自己的目的，这大概就是阅读的意义所在吧。就像王小波曾说过的那样：</p><blockquote><p> “ 人活在世上，自会形成信念。对我本人来说，学习自然科学，阅读文学作品，看人文科学的书籍，乃至旅行，恋爱，无不有助于形成我的信念，构造我的价值观。一种学问、一本书，假如不对我的价值观发生作用（姑不论其作用大小，我要求它是有作用的），就不值得一学，不值得一看。”</p></blockquote><h3 id="《黑客与画家》"><a href="#《黑客与画家》" class="headerlink" title="《黑客与画家》"></a><a href="https://book.douban.com/subject/25724948/">《黑客与画家》</a></h3><p><em>日期：2019-1-28</em></p><blockquote><p>沉默的嘴与自由的思维</p></blockquote><p>书中的《不能说的话》《如何创造财富》这两篇对我十分具有启发性。</p><p>生活在魔幻现实主义中，看到更多真相的人总是需要承受更多的痛苦。在选择沉默与反抗之间挣扎万分，因为自己的力量是显得如此微不足道，而沉默又会备受内心道德准则的质问。时常想起王小波所说的 “一个人在二十岁时如果不是激进派，那他一辈子都不会有出息；假如他到了三十岁还是个激进派，那他也不会有什么大出息。” 没错，激进、热血、正义是年轻人的代名词，在亲眼了解到那些被精心描绘的美好风景背地里的黑暗后，他们会心怀愤懑，会对所见的现实同从小被灌输的美好幻景产生怀疑和质问，而这个时代的主旋律便是服从、权威，不允许质疑与反抗。于是他们挣扎着。</p><p>在《不能说的话》中，作者表述出自己的观点：把自己的精力放在真正值得做的事情上。但在保全自己的同时，记得不要忘记质疑和批判的精神。试图通过观察那些在某些社会现象中所被禁止或被镇压的事物，进而思考其背后的原因。这样就能比别人多思考那么一点，就能多想到别人所想不到的地方。就像书中说到 “每个时代都有自己的忌讳，如果你触犯它们，就算没有坐牢，至少也会为自己惹来麻烦，干扰了正常生活。”“自由思考比畅所欲言更重要…更好的办法是在思想和言论之间划一条明确的界限。在心里无所不想，但是不一定要说出来。” </p><p>作者也提到也可以寻找自己完全信任的朋友进行讨论，以及在谈论一些问题时尽量从抽象、宏观的层面进行评价，又或者通过幽默的隐喻方式进行批判，总之你得保护好你自己，免遭文字狱。</p><p>冯大辉在对这本书评中说得挺好的 “如果自己是潮水的一部分，你无法看清潮水的方向，唯一的办法是永远保持质疑，提升自己的思辨能力。”我想这一点是本书对我最大的启发。</p><p>在《如何创造财富》一文中以及后文所提到的“老爹模式”深入浅出的介绍了自己的财富观念，作者指出了金钱与财富的关系，金钱只是用于支配财富的权力，金钱并不等于财富。我觉得最有趣的便是作者提到的“老爹模式”：在真实世界中，财富是你必须自己创造出来的东西，而不是等着老爹给你买。由于每个人创造财富的能力和欲望强烈程度都不一样（想到了马克思经济学中的每个人按需分配的观点，话你怎么知道谁更需求什么东西？马有点胡扯啊），所以每个人创造财富的数量很不平等。所以别说什么这个世界太不公平了，而是你不够现实罢了。作者也一阵见血地指出了社会中普遍存在的误解以及一些十分天真的想法。</p><p>还有许多带给我启发的地方，例如：想要不能迅速超越，那么最好一开始就选择hard模式，今后的决策中也选择hard，渐渐的你就养成一种习惯了。</p><p>总的来说，这本书的某些章节值得读第二遍</p><h3 id="《心灵的焦灼》"><a href="#《心灵的焦灼》" class="headerlink" title="《心灵的焦灼》"></a><a href="https://book.douban.com/subject/2146279/">《心灵的焦灼》</a></h3><p><em>日期：2018-5-4</em></p><blockquote><p>写出了我们都会有的心灵焦灼</p></blockquote><p>本书讲述了一位少尉在一次聚会中偶然结识了一位下身残疾的姑娘，并借由自己的同情之心与姑娘及家庭产生了连结，其间发生的一系人物情感，内心冲突与变化。</p><p>整本小说以同情情感为中心。霍夫米勒的同情是软弱无力的。正如康多尔所说的因害怕此种不幸降临到自身而产生的同情，想尽快抽身于此中不幸之中的同情。但霍夫米勒身上也有可贵之处，即他的正义感。他始终清楚的知道自己内心真正的想法，没有被外界声音所迷失。他能在关键时刻理性地去分析。这让我想到，人大部分所做出的行为都是依靠感性而完成的，我们只需要在重要关键时侯保持理性的思考即可，而不是时时与自己的内心本意作斗争，我们应该引导自己的内心。</p><p>我发现不论是在毛姆还是茨威格的作品中，主人公总是在进行自我对话的过程中进行成长的，自己很喜欢这种意识流的写作方式，能将自己与主人公产生连结，将其中的特性映射到自身之中，从而产生共情。不止一次读到霍夫米勒的所作所为与内心想法冲突时想到我自己。自己也会在一场交谈之后进行思考反思，也会在真正应该勇敢时怯懦软弱，但至少霍夫米勒心中的正义是一直存在的，而我却时有时无。</p><p>艾迪特对爱情的渴望是如此具有压迫性，使人喘不过气来。最近一段时间由于自身的一些原因也阅读了不少关于情感方面的文章。也知道了一段情感上的距离是由最不在意的那个人决定的。艾迪特由于无法控制自己不断溢出的爱意，在给霍夫米勒信中所表现出对爱情的渴望，这种卑微到尘埃里的爱情，是令另一方感到窒息的吸氧器。想起曾经看到一个综艺里面一位嘉宾说：“如果没有卑微到尘埃的那一刻，又怎知爱为何物。”当时看完深以为然，但现在想想，不禁觉得这样如此可悲的爱情让人感到畏惧。这样的爱，看似所求得如此之少，但实际又是渴望独占这一切。最终恐怕得到的只有同情与逃避。一段真正健康的爱情，从来不应使任何一方有卑微的姿态。</p><p>开克斯伐克，一个深经世故的商人，一个为了自己女儿不顾一切的父亲，想必最终是累倒了。</p><p>康多尔在关于医生与病人同疾病之间的一场论述令我印象深刻。世界上是没有不治之症的，只有在现如今医疗水平之下无法治愈的疾病。病人及家属的眼中一切关于机率、概率的词汇是与我们常人是完全不同的。康多尔的自我牺牲是伟大的。他的为人行事让我想到了毛姆《克拉多克夫人》中叙述者的形象。同样对一切事物具有强大的洞察力，直言不讳的进行讨论。“在任何一场对话中，任何一方有所隐瞒，那这场对话便是无意义的。”</p><p>这是一本让我感到读罢后久久不能平复的小说，其中总有些许的小细节会不禁联想到现实中的自己，想到自己也存在的心灵的焦灼。</p><h3 id="《三毛1943-1991》"><a href="#《三毛1943-1991》" class="headerlink" title="《三毛1943-1991》"></a><a href="https://book.douban.com/subject/5417810/">《三毛1943-1991》</a></h3><p><em>日期：2018-3-3</em></p><blockquote><p>酷爱三毛</p></blockquote><p>三毛的作品将我引入缤纷的文学殿堂。从《撒哈拉沙漠的故事》到《千山万水走遍》，有人生经历感悟，有为人从善品格，其中的作品无不潜移默化的印象着我对学习爱情生活的认识。三毛是一个具有超强执行力的人，敢爱敢恨，学习能发疯一样的学习，恋爱能为之赴汤蹈火，在生活中发现生活。爱一个人可以是平静如水，也可以是死去活来，看你爱的是谁。</p><p>我喜欢三毛，从她的《撒哈拉沙漠》到她整个人。</p><p>热爱生活，才能体验出生活的美。三毛是我心中最酷爱的人。她的一生，别人也许需要好几个世纪才能走完。</p><p>在看《1943-1991》中，对生活中的三毛形象增添了更多的细节。在阅读过程中，我愈发觉得一个人在幼年时期读书的多少，以及是否养成阅读习惯，对他今后在文学修养的高度有很大的影响。回想起自己的幼年时期，不禁感叹不已，“只叹年少戏蝴蝶，今朝方觉书中趣”。三毛幼年时期接触的人，都可谓修养高，知识丰富。从小经历良好的教育。反思自己的经历，即使上辈没有经历良好的教育，自己也应该努力，三毛在大学时期的努力令人惊叹。三毛给我的是导师的作用。</p><p>酷爱三毛！</p><h3 id="《娱乐至死》"><a href="#《娱乐至死》" class="headerlink" title="《娱乐至死》"></a><a href="https://book.douban.com/subject/26319730/">《娱乐至死》</a></h3><p><em>日期：2017-5-22</em></p><blockquote><p>一个过度娱乐化的社会，其精神文化必将走向自我毁灭</p></blockquote><p>波兹曼的《娱乐至死》阐述了一个过度娱乐化的社会必将走向自我毁灭，这也就是本书书名：娱乐至死。波兹曼的观念与赫胥黎的观念所一致，即最终使人类走向衰败的不是掌权者严厉控制获得人们的信息的方式，而是人们将所创造的文化变成一场滑稽戏。在本书中，作者从文化传播方式讲起，在没有印刷术出来之前人们的传播方只有通过言语，一些具有权威性的人物说出来的话往往会成为真理，难以撼动。随着印刷技术出来，人们获取知识并进行交谈的方式更多地通过纸质，知识也通过书本报刊进行传播，在20世纪阅读报刊已经成为每个美国家庭必不可以少的日常生活。人们的生活中充满了书籍，人们开始更多的去思考去理解书中和书外的知识。在20世纪后期，第三次工业革命爆发，电子科技的飞速发展，电视出现了。人们获取信息的方式又多了一种。电视给人们带来了跟多的娱乐，人们大把的时间都交给了电视娱乐，思考的时间减少许多。电视里的娱乐经济很大程度带动了社会的经济发展，许多的组织机构都向电视娱乐靠拢，渐渐地宗教在电视上被娱乐化，政治也被娱乐化，这些原本应该严肃的一切都是为了提高上镜率，提高在民众心中的出现率而变得不那么严肃甚至是搞笑起来了。一旦类似政治宗教这些本身就应具有严肃性的话题被娱乐化，那么还有什么能是严肃且庄严的出现在公众面前的呢？没有了能够严肃具有权威性的话题，也许没有什么能让公民能够紧张与严肃起来了。电视的出现使我们获得信息的速度和内容量得到了量级的提升，在本书中提到，一则电视新闻平均播放的时间秒，无论这则新闻内容是什么45秒后你都将看到一全新的新闻或者是广告，并且内容一定是与之前的毫无联系。在如此短的时间内，人们是无法在新闻背后去进行任何思考的，大多都是听过就听过，不会去进行任何思考，人们可以一换台就去转眼看其他的节目。一切都被娱乐化了，书中还提到了一种观点，认为教育应该以娱乐化的形式开展。80年代的美国也尝试过，可由于成本极高以及内容的局限性而终止。</p><p>在我自己看来，如今的互联网更是飞速发展，人们获得信息的方式也是各种各样，可这些信息大多都是碎片化的，人们看了之后不能够有进一步思考的内容，电视节目的形式多样化，但终究一定是以娱乐的形式展现出来的。面对如今泛娱乐化的社会，我们应该做的不是去禁止人们看电视亦或是禁止娱乐式的活动，因为如果这样做对于民众无疑是一种苦行，毫无意义。正如书中最后所提到，我们应该从我们的教育入手，电视不应该成为教育的平台，而这正是政府应该去做的。《娱乐至死》这本书总结起来大概就是作者所预言的：我们将毁于我们所热爱的东西。</p><h3 id="《瓦尔登湖》"><a href="#《瓦尔登湖》" class="headerlink" title="《瓦尔登湖》"></a><a href="https://book.douban.com/subject/1865089/">《瓦尔登湖》</a></h3><p><em>日期：2017-4-26</em></p><blockquote><p>对物质无欲是一种能力</p></blockquote><p>今天中午将被誉为人类精神家园的《瓦尔登湖》看完了。书写的确实好。尤其觉得前面部分讲述人性对物质欲望的追求，人文教育以及生活态度方面的认识与见解对我有很大的影响。</p><p>书中提到人们通过无止境的购买衣服来包装自己是毫无意义的，即使外在有多大的改变，人如果内心没有的到净化，那他还是那个他。只有通过不断地学习，思考，进步，人才会是真正意义上的与之不同。徒有其表之人内心是空洞的，如果仅仅是想通过外部的改变而改变，那只能是自欺欺人。这就是旧装新人，新装旧人的区别。在购买衣服这件事上放在现代社会来看，仍是有必要的，外表仍是别人看到自己的第一形式，衣服可以买，但要适度适时的进行购买。</p><p>梭罗在书中说道现代人们通常在繁忙的事务中忘记生活的意义，提倡我们应放慢脚步，多观察生活中的点滴。在我看来，梭罗说的不无道理，但在现如今生活压力大，要求我们放慢脚步去留意点滴，确实不太现实。不过我认为梭罗的本质意思是别让生活的繁杂夺取我们欣赏美的权利。正所谓不忘初心，方得始终就是这样吧。物欲横流的时代，永远都要守住自己的底线。无论外界的风云变化，都请坚守自己的信念。欲望是所有罪恶的源泉，贪念会吞噬的善良理智及所有优良的品质。学会去控制欲望，别让欲望所将你控制。</p><p>书中剩余部分讲述了作者在瓦尔登湖生活的点滴，对自然，人群，生活的理解。在本书前面部分的过程中都会感受到自己的精神受到洗礼，此话并非吹捧之谈，如果读此书都能静下来读进去，我想大多都会有这种感觉。正是所处这在高速信息碎片化娱乐化的时代，尚未成熟的心智难免会受到玷浊，我们才需要更多的去学习掌控自己的内心，并进而探索的内心。</p><p>我们所不能到达最远的地方不是宇宙中的某处，而是我们的内心。</p><h3 id="《1984》"><a href="#《1984》" class="headerlink" title="《1984》"></a><a href="https://book.douban.com/subject/22988752/">《1984》</a></h3><p><em>日期：2017-4-22</em></p><blockquote><p>反极权主义的1984</p></blockquote><p>花了三个星期的时间断断续续读完了乔治奥威尔的《1984》，在之前的了解到奥威尔是一个反共主义者，是一个反社会主义者，然而读完书后发现其实并不是这样，奥威尔其实是一个位反极权主义的。</p><p>《1984》故事设定在1984年前后，世界被分三大国所占据，故事主人公所在国家为大洋国，是一个英格兰社会主义简称英社的社会主义国家，国家和党的最高领导人叫老大哥（big brother）。老大哥是这个国家的灵魂，代表着一切。老大哥和党拥有至高无上的权利，向人民灌输他们认为正确的一切。党的口号是“战争既和平，奴役即自由，无知即智慧”。可想而知这是一个所有权利被绝对掌握在党和老大哥的手中的国家。人民不允许拥有任何不利于党，反对党的行为和思想。党拥有思想警察，无时无刻都在监视着人民。</p><p>主人公温斯顿是一个普通的工人，但他并没有被这个国家所完全控制思想，他发现了这个国家的极权行为。并去寻找另一个神秘的反党组织——兄弟会。直到有天他碰到了另一个女子，裘莉亚，他们相爱了，在一个偶然碰到了自称是兄弟会成员的奥勃良。他两都相信这个组织的存在，并都愿意为推翻老大哥的极权统治，义无反顾的加入了兄弟会。然而这一切都是骗局，没有兄弟会的存在，奥勃良是思想警察，并已经监视了温斯顿7年之久。这个世界的每一个角落都有思想警察和党的存在，政府不允许人民有任何个人的想法。温斯顿在经受了残忍的折磨后被党彻底洗脑，无条件相信党相信老大哥所说的所有。</p><p>双重思想是英社的核心，所有人民都应该有双重思想的能力，党拥有更改历史的权利。</p><p>奥威尔所想要警示我们的是，我们需要警惕任何形式的极权主义，一旦极权主义的形成，底层人民变再无反抗的能力。政府会想尽办法控制我们的思想，限制我们的行为，最终使我们丧失思考的能力。</p><p>绝对的权利就意味着绝对的贪婪。</p><h3 id="《地下》"><a href="#《地下》" class="headerlink" title="《地下》"></a><a href="https://book.douban.com/subject/6265779//">《地下》</a></h3><p><em>日期：2017-3-19</em></p><blockquote><p>“现实本来就是含着混乱和矛盾并因之成立的东西”</p></blockquote><p>这个星期看了村上的《地下》，这是一部完全纪实的作品，记录了村上采访的东京地铁沙林事件的受害者以及奥姆教会人员的谈话内容。作品对日本社会进行了深度的剖析，解释了为什么东京看似是世界上最安全的地方竟会发生这种事件的原因。在我个人看来总结起来便是社会的发展程度还未能触及到少部分人的生活的渴望性，而这少部分人就是奥姆教成员。他们渴望从麻原彰晃那里得到解脱，在现实中或多或少对生活感到了失望，困惑，迷失。两本纪实书中让我思考更多的是第二本，即村上采访奥姆真理教成员的内容。</p><p>教会成员起初根本不相信地铁沙林事件幕后是麻原彰晃，因为他们没有理由相信平日助人解脱的教主做出这样的事情。我是一个无教派人士，今后想也是。个人认为彻底的将自己的思想行为依靠给被神化的形象是没有意义的，只有自己构建内心的信仰才是正确的道路。我并不是否认宗教的意义存在，而是想说明想通过宗教所谓的解脱而达到对现实的逃避是不彻底正确的做法。“现实本来就是含着混乱和矛盾并因之成立的东西，当若排除混乱和矛盾，现实也就不从谈起”书中说道这样一段话，我再赞成不同。现实若不存在这两者，那就是理想，是乌托邦。</p><p>第一次看村上写纪实的作品。村上说写这部作品是为了去寻找这件事其中的恶进而找出社会的恶。恶-是村上小说中十分重要的主题，村上说也是最难去寻找的一个主题。</p><p>看完后给我收获颇多的，作为一个村上迷，对村上的作品也有了更深层的理解，并会有意去寻找小说中人物的恶，事物的恶，社会的恶。对村上所传递出来的价值观也有了认识（姑且认为是价值观吧），有思考意义的作品才会让读者进步。我想这也就是为什么我会喜欢村上的原因，一个对社会有责任感的小说家，写出来的作品是社会的病历本，解毒药更是救心丸。</p><h3 id="《爱的艺术》"><a href="#《爱的艺术》" class="headerlink" title="《爱的艺术》"></a><a href="https://book.douban.com/subject/3026879/">《爱的艺术》</a></h3><p><em>日期：2017-2-19</em></p><p>爱有许多种。爱是情感形式的体现。通过的了有关于亲密关系的书，了解到爱大多都是情感需求的体现。在如今社会，人的价值就如同商品，在人际交往中通过人们不同的需求进行交换，人际关系更像是商品之间的利益交换，如何资本市场一样的进行着运作。</p><p>在看这本书时和看完这本书后我都一直在问自己一个问题: 这本书到底阐述了爱的哪些事情。这本书对我而言阅读起来是有一定难度的，主要是在思想层次上的有些深奥与难以理解，这应该与自己的阅历补足有关系。</p><p>书中说道许多人的爱情是希望得到自己小时候所获得的爱，如同母爱父爱。在孩童幼儿阶段，母亲的爱是起主导作用的，母亲对孩童的百般照顾，情感表达都是相对丰富的。在孩童少年阶段，父亲的爱会起到主导作用，父亲会对孩子产生政治层次的影响。</p><p>在本书中对我影响最深刻的是提到了信仰。真正合理的信仰是通过自己的个人体验，经历，内心想法所构建起来的，这种信仰不会是大众所相信的东西，不会被众人所轻易改变。而在我们拥有这种信仰的过程中，我们就是要克服外界的各种干扰，不断强化自身信仰，使我们的生活得到一个良性的循环，我认为这是本书中说的最好的一个地方之一。</p><p>书中还有许多地方值得学习，由于是快速阅读，许多地方都没有进行认真的思考，看第二遍是一定的。</p><p>Ps: 补充一点忘说的，信仰最重要的三点: 教养，耐心，（还有点忘了，好尴尬）第三点是集中，我想起来了！  </p><h3 id="《昨天》"><a href="#《昨天》" class="headerlink" title="《昨天》"></a><a href="https://book.douban.com/subject/26286208/">《昨天》</a></h3><p><em>日期：2016-12-31</em></p><blockquote><p>人生年轮</p></blockquote><p>读罢村上的《昨天》，内心由衷的喜欢文中的这一句话，“年轻的时候经历这样一些寂寞孤单的时期，在某种意义上也是必要的吧，这就和树木要想茁壮成长必须抗过严冬是一样的。如果气候老是那么温暖,一成不变的话,连年轮都不会有吧。” 经受严寒，树木才会增长真正的年轮，历经孤独与寂寞，人才会真正的成长。</p><p>人生不过几万天，在特定的时期必定会经历不同的孤独寂寞，我们每个人都会走不同的弯路，最终刻画出自己独一无二的年轮。这样，当我们将近暮年之时，回后头来细看自己的年轮时才不会感到后悔与不甘。在年轮记忆中，一边庆幸着自己有推心置腹的朋友，一边叹息的回忆着自己那算得上孤独的青春。</p><p>如果可以，我想在一个孤独寂寥的夜晚里，做一个关于冰月亮的梦。梦里，我同自己心爱的姑娘坐在海边的摇椅上，共同观赏着冰做的月亮。随着太阳的升起，冰月亮融化了，于是我们又期待着明天的赏月，就这样日复一日，如此便好。</p><p>昨天，是前天的明天，是明天的昨天。</p><h3 id="《亲密关系》"><a href="#《亲密关系》" class="headerlink" title="《亲密关系》"></a><a href="https://book.douban.com/subject/26363229/">《亲密关系》</a></h3><p><em>日期：2016-12-18</em></p><blockquote><p>亲密-幻灭-内省-启示</p></blockquote><p>昨天晚上在图书馆花了3个小时的时间把这本书粗略的看完了。大部分讲述如何解决情侣之间矛盾关系的解决。书中说道，任何亲密关系都会有这样的过程：亲密关系，幻灭，内省，启示。大部分人基本走到幻灭阶段就分开了，这边是没有处理好这段感情最关键的问题。其实所以情感，都是对个人需求的满足，这些需求也许来自幼年情感的缺失，可能是个人个性的体现。</p><p>在每段感情的开始，彼此都有能让对方需求得到满足的因素，也许是脸蛋，举止，爱好等等。双方可以在这段情感中都不同程度的得到了满足，彼此不舍得分开，这就是我们所说的热恋期。</p><p>随着时间的推移，最初的需求长期被满足，人本身的需求阈值被提高了，开始对对方感到了不满，厌倦，甚至当初你最喜欢对方的一个行为或特征成了现在你最厌恶的地方，随之幻灭期就到来了。处于幻灭期的情侣会对彼此产生厌倦感，内心会想“当初我怎么会喜欢你这样一个人？”，情感处于最脆弱的阶段，如果处理不当，极可能分到两路，为路人。</p><p>此时，当我们发现我们进入这个阶段后，我们首先应该多想想自己，多反省，这便进入了内省阶段。在实际中，大多初恋之人往往没有走到这一阶段。内省阶段首要任务当然即是进行自我反省，寻求自己内心的真正需求，适当降低对对方的要求。在这个阶段，我们不应该是去寻求其他的人去满足自己的需求，因为如果这样，没有一段感情会真正意义上的走下去的，只是如同行尸一样的去满足自己的欲望。任何解决问题的方式都必须是双方同时进行，并且双方都付出百分之百的努力去解决。</p><p>在内省过后，这段感情就会像注入新的血液一样，又充满了激情与活力。真的得亲密关系的进程远没有我写的那么的简单，也不会真正像书中写的那样有据可依，有法可寻。但我们可以做到的是尽可能的去维持这一段感情，让情感保质。</p><h2 id="🎬-观后感"><a href="#🎬-观后感" class="headerlink" title="🎬 观后感"></a>🎬 观后感</h2><h3 id="《无问西东》"><a href="#《无问西东》" class="headerlink" title="《无问西东》"></a><a href="https://movie.douban.com/subject/6874741/">《无问西东》</a></h3><p><em>日期：2018-7-26</em></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200825003253.jpg"></p><blockquote><p>永远相信这个世界会变得更美好</p></blockquote><p>今天考试结束抽空看到《无问西东》，以四个故事为主线讲述从1920到现代四代人的故事。四代人彼此有连结。在看电影的过程中自己的脑海中不断出现一个概念，即要有永远相信这个世界会变得更美好的信念，在此想到了宇哥，伟哥在课中表达的观念：虽然承认这个世界有黑暗的地方，但我们应该永远向往光明，充满正能量。年纪轻轻想法与言行中却充满世俗与老练，这不是一个二十岁的应有的样子，并且我也希望以后永远不这样。就像影片中台词说的一样：不要让世俗去裹挟了我们的真实。</p><p>今年在准备考研，每天都觉得很辛苦，和以往轻松放纵的日子相比。但在电影中所展现出的四代人：为追求文学的泠澜，决意成为飞行员的光耀，对爱的人永不放弃的陈鹏，救助一家四胞胎的张果果，他们都尽早的寻求到领悟到人生真实的意义与理想，没有被世俗的观念所裹挟。理想无论宏大与渺小，他们都是在帮助别人，是他们的存在让这个世界变得更美好，我们的社会正是有这样一群人，看似默默无闻的行善，但却正是这些细小的善，让世界变得更美好了。在这之前很长一段时间里，自己是有点愤世嫉俗的，觉得这个社会是很黑暗的，他的强大以至于正义无法战胜，而现在我发现是当初是自己只看见黑暗而忽视光明。在黑暗的包围中误以为整个世界都是漆黑一片的。</p><p>向阳而生吧，现阶段的自己无论怎么说也都只是为了自己，这没有什么值得可提的。</p><p>向往美好，追求最真实的东西，因为青春只有这些日子。</p><p>“如此天资，当初你为什么不学文科？而偏要念实科呢？”</p><p>“因为最好的学生都读实科。”</p><p>“你求学的目的是什么？”</p><p>“我只知道不管我将来做什么，在我这个年纪，读书，学习，都是对的。我何用管我学什么，每天把我自己交给书本，就有种踏实。”</p><p>“但是，你还忽略了一件事，真实。人把自己置身于忙碌当中，有一种麻木的踏实。但丧失了真实，你的青春，也不过只有这些日子。”</p><p>“什么是真实？”</p><p>“你看到什么，听到什么，做什么，和谁在一起，有一种从心灵深处满溢出来的不懊悔也不羞耻的平和与喜悦。你慢慢想，转系与否那都是小事……”</p><p>“愿你在被打击时，记起你的珍贵，抵抗恶意；<br> 愿你在迷茫时，坚信你的珍贵。爱你所爱，行你所行，听从你心，无问西东。”</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200825003239.jpg" alt="无问西东2"></p><h3 id="《追梦赤子心》"><a href="#《追梦赤子心》" class="headerlink" title="《追梦赤子心》"></a><a href="https://movie.douban.com/subject/1294753/">《追梦赤子心》</a></h3><p><em>日期：2018-7-19</em></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/202008250520.jpg" alt="p452577492_爱奇艺"></p><blockquote><p>梦想使生活得以忍受</p></blockquote><p>“梦想使生活得以忍受”<br> 不是什么天道酬勤，只要坚持够了努力够了，剩下的就交给上帝吧。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200825002622.jpg" alt="Rudy dream2"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200825002638.jpg" alt="Rudy dream"></p><h3 id="《头脑特工队》"><a href="#《头脑特工队》" class="headerlink" title="《头脑特工队》"></a><a href="https://movie.douban.com/subject/10533913/">《头脑特工队》</a></h3><p><em>日期：2018-6-9</em></p><blockquote><p>培养你的头脑特工队</p></blockquote><p>这部皮克斯动画的影片设定位为每个人头脑中其实都有控制着不同情绪的头脑特工所控制着的背景，围绕着一个叫Reily的12岁小女孩在经历搬家后所发生的，以及同时在Reily脑中头脑特工们发生的故事所展开。</p><p>影片中人的头脑中存在着另一个世界，在这个头脑世界中有负责情绪控制的五名情感特工，他们属于中央控制部门，负责着人生活中最主要的活动，喜怒哀乐全有他们控制，其实更确切的说是他们对当前外界环境所作出的反应与选择。本人的情感记忆会形成不同色彩的彩球，储存在头脑世界中。在这个世界中有不同的城堡，每个城堡都是本人所特有的记忆建筑，因为家庭，就会出现家庭城堡，因为友谊就会有友谊城堡。这些城堡就像是现实大脑中的神经元，每个神经元上都存在着独有的记忆。被遗忘的记忆便会被记忆管理工扔到记忆废墟里去，到了那里的记忆便不再会被想起了。</p><p>影片让我印象深刻的有两处，第一处是Bing Bong和Reily共同拥有的记忆连结火箭被记忆工所清理，yoy过去用逗乐的方式去安慰和sadness通过与其产生同理性的方式安慰的不同效果。很多时候我们在关心别人的时候更多的不应该是表象化的让对方开心起来，因为很多时候很多事情我们是没有能力去改变在对方心里的态度的，而我们能做的就是真诚的去理解对方，去感受对方的悲伤，这样就足够了，能让对方走出来的最终只有他自己。第二处让我印象深刻的是在BingBong和Reily借助火箭逃离记忆废墟的情节。Reily与BingBong想通过不断唤醒童年Reily与BingBong产生的美好记忆从而借助火箭的动力逃离废墟，但由于这段记忆已经快被Reily所遗忘，火箭动力始终不足，而由于BingBong也是属于Reily的记忆，随着这段童年记忆被Reily渐渐遗忘，BingBong的身体也渐渐开始残缺，在最后一次尝试中，在起飞最后过程中，BingBong选择了留下来，而最终Yoy成功逃离。当Yoy发现BingBong在悬崖下的记忆废墟是，BingBong的身体正随着Reily的这段记忆的渐渐消失而消散。BingBong就像我们成长过程中曾经所亲密无间，给我们带来欢乐的人和物，在不断成长的过程中他们也许就被我们遗忘了，他们也想过努力唤起我们共同的那段美好回忆，但往往只是徒劳。但最终被我们所遗忘的，某一天总会以某种形式又再次被唤起，那时的我们会不禁感叹那段美好的记忆。</p><p>影片中的Yoy是给Reily带来快乐的特工，她总是积极乐观的，而Sadness是负责伤心的特工，她看待事物总是消极的态度。最开始我不喜欢sadness，讨厌她的消极，而在她处理问题的过程中发现，悲观的情绪是的的确确存在与我们的情感中，用乐观的情绪去掩盖，只能是欺骗自己。毛姆曾在作品里说到：一个人对别人撒谎，有时确有必要，而如果对自己说谎，无论如何都是卑劣的。想想看我们平时不经常这样骗自己吗，在学习上通过无效的忙碌来欺骗自己已经很努力了，在面对明明已经让自己很难过的事情上对自己说这没什么，很多的积极都是在以一种很隐蔽的方式来欺骗我们自己。不要在隐藏了，不要在欺骗了，都比将自己最真实的情感表达出来，这才是自己，在这样的过程中不断的认识自己，并按照自己的原则去调整，去引导自己的情绪，这就是发现自我的过程，如果只是一昧的去隐藏去欺骗，那人最终会分裂的，这里指的是人格与情感上的。在二十几岁的年龄，个人体验的情感始终应该高于集体体验的情感，因为这个时候是我们能够达到自己情感极限的年纪。去体验，去表达吧！ 不断训练自己的头脑特工队，让他们忠于自我，忠于内心。</p><h3 id="《头号玩家》"><a href="#《头号玩家》" class="headerlink" title="《头号玩家》"></a><a href="https://movie.douban.com/subject/4920389/">《头号玩家》</a></h3><p><em>日期：2018-3-31</em></p><blockquote><p>只有现实才是最真实的</p></blockquote><p>电影讲述了在未来世界，现实世界几乎已被一种叫绿洲项目的游戏世界所替代，人人都沉迷于其中。绿洲世界创始人在虚拟世界隐藏了三把钥匙，取得三把钥匙的人能获得现实世界中5000亿美元和整个绿洲世界的控制权，所有人都趋之若鹜的在绿洲里寻找这三把钥匙。</p><p>电影中大量使用逼真的CG特效，是在令人大开眼界，不知制作团队花了多长时间进行渲染制作。以往听到过恐怖谷理论，大概说若虚拟角色与现实人物中形象相似度在60%-80%，那么这个角色一定是失败的，一定会让人看了觉得很丑陋。这也说明了为什么皮克斯、梦工厂等动画公司在设计角色形象时总会十分夸张的原因。（比如尖长到令人发指的鼻子，细长如电线杆的双腿等）。</p><p>在眼花缭乱的视觉特效之下，电影本身情节的发展并没有被反宾为主。始终以主角寻找彩蛋为主线，并由此逐渐展现主人公内心变化。<br>虚拟世界与现实之间的不确定性与冲突我认为是核心点所在。</p><p>个人最喜欢剧中创始人哈利迪与男主对话的部分。其中哈利迪说：“自己想逃避到虚拟世界中，逃避现实世界中的交往，但最终仍只能回归到真实中，因为只有真实才能让自己真正吃上一顿饱饭。现实是最真实”。看完这段话时不禁想到了自己是那么习惯将自己藏匿于内心的虚拟世界中。虚拟与现实的冲突选择逃避是没有任何意义的，因为只有现实能让你真正吃上一顿饱饭，虚拟世界的满足只能暂时填满内心的空虚，当再次回到现实时，loser 仍是loser，不会有任何改变，不正是这样的吗？这是很多人都懂的道理，可但只有很少人愿意走出来。</p><p>当看到男主控制不住自己爆棚的爱意向女主表白时，我仿佛看到了自己，无知，渴望，鲁莽，以及一切的真性情。</p><p>当一部商业电影，看完后沉淀在脑海里的不是震撼的打斗场面，而是角色内心情感变化引发自身情感的共鸣，这对我应该就不单单是一步爆米花电影了。</p><p>出生在这个千禧年代，目睹了科技如何改变人们的生活。使方便快捷，也使迷失堕落。 保持在现实世界的清醒吧，我们始终只能生活在这个不怎么如意的现实中。</p><h3 id="《东京女子图鉴》"><a href="#《东京女子图鉴》" class="headerlink" title="《东京女子图鉴》"></a><a href="https://movie.douban.com/subject/26921674/">《东京女子图鉴》</a></h3><p><em>日期：2018-3-28</em></p><blockquote><p>无常人生本是爱情的解药</p></blockquote><p>本剧讲述了一个来自地区的女孩儿绫来到心中渴望的大都市东京，并渴望成为时尚东京一份子的故事。故事讲述来到东京这十年，绫的改变与妥协。东京生活的十年，现实不断地冲刷着她，现实的东京与曾经憧憬的巨大沟壑曾让绫一次次产生无力感。好在绫是奋斗的女人，现实并没有轻松地击垮她。</p><p>一切将来必须面对的现实问题接踵而来，追求幸福的过程中绫也在不断成长。绫心中应该是没有信仰的，但她可贵的一点在于她始终坚持自己的价值观（在此我对于信仰和价值观的不同仍存有疑惑）。坚守的代价必定是不得不对抗来自世俗道德的批判与价值观的冲撞。（都说人要为自己活着，可是如果真的只是为自己活着，而不考虑自己应承担的家庭责任，多少来说都是很自私的行为吧。为自己活着不应是自私的为自己活着）</p><p>绫的结局是好是坏，我认为并无好坏之分。绫的东京生活无疑是丰富的，正是这样的人生经历成就了现在的绫。就像剧中绫所说的：“小小的幸福，那时候觉得那样的幸福太渺小而感到悲哀，于是放手了，现在已经懂得这样的幸福多么得来不易，到今为止发生的每件事，大概都是为了重新认知到这个道理而绕的路吧。”这不正是我们所有梦想追求幸福的人所正在做的事情吗？贪婪地追求着更多更华丽的幸福，而其实真正的幸福就悄无声息的存在于我们身边，只是这样真正的幸福太渺小，以至于我们没有珍惜。我们仿佛一定要亲自历经几番的考验之后，才会放下执念，可回过头来却发现那时的幸福没有在那里等我们。</p><p>这大概就是人生应该奋斗的意义吧。为了心中的执念，在全力以赴后，才能真正放下执念，平静地享受幸福。一切若是来的太容易，是没有人会珍惜的。</p><p>“一起加油吧！<br>一步接一步，<br>因为想要得到的东西还有很多。”</p><h3 id="《出租车司机》"><a href="#《出租车司机》" class="headerlink" title="《出租车司机》"></a><a href="https://zh.wikipedia.org/zh/%E6%88%91%E5%8F%AA%E6%98%AF%E5%80%8B%E8%A8%88%E7%A8%8B%E8%BB%8A%E5%8F%B8%E6%A9%9F">《出租车司机》</a></h3><p><em>日期：2017-11-10</em></p><blockquote><p>自由是可贵的，自由是需要代价的</p></blockquote><p>自由是可贵的，自由是需要代价的</p><p>看完韩国的电影《出租车司机》，立马想到了，正如《v字仇杀队》里所说的样：人不应该怕政府，政府应该怕人民。</p><p>王小波在一篇杂文中提到一个牧师曾说过：所有的人是一个整体，别人的不幸就是你的不幸。所以，不要以为丧钟是为谁而鸣——它就是为你而鸣。但这个想法我觉得陌生，我就盼着别人倒霉。五十多年前，有个德国的新教牧师说：起初，他们抓共产党员，我不说话，因为我不是工会会员；后来，他们抓犹太人，我不说话，因为我是亚利安人；后来他们抓天主教徒，我不说话，因为我是新教徒？最后他们来抓我，已经没人能为我说话了。众所周知，这里不是纳粹德国，我也不是新教牧师。所以，这些话我也不想记住。</p><h3 id="《恋恋笔记本》"><a href="#《恋恋笔记本》" class="headerlink" title="《恋恋笔记本》"></a><a href="https://movie.douban.com/subject/1309163/">《恋恋笔记本》</a></h3><p><em>日期：2017-1-4</em></p><blockquote><p>陪伴是最长情的告白</p></blockquote><p>最令人动容的不是诺亚和艾丽当时爱的多深，初恋谁都投入。而是，错过了彼此多年，他们身边都有了别人，但当他们再次遇见，诺亚和艾丽还是选择了彼此。褪去了青春的荷尔蒙我还是选择你！    </p><p>​    —— 尼克·卡萨维茨 《恋恋笔记本》                                                                                                                           </p><h3 id="《本杰明巴顿奇事》"><a href="#《本杰明巴顿奇事》" class="headerlink" title="《本杰明巴顿奇事》"></a><a href="https://movie.douban.com/subject/1485260/">《本杰明巴顿奇事》</a></h3><p><em>日期：2016-10-13</em></p><blockquote><p>本杰明的逆人生</p></blockquote><p>两个小时四十分钟对一部电影来说算是长的了，但对于一个人的人生来说是远不够的。</p><p>本片讲述了一位拥有奇特人生——从老活到小的本杰明的故事。本杰明刚生下来是一位拥有老年人年纪一样的褶皱皮肤和衰老器官的婴儿，刚出生就被其父亲抛弃，被富有爱心的福利院的妈妈收养。随着年纪的增长本杰明渐渐地从满头白发的老人成长到壮年，青年，最终回到了婴儿时期。</p><p>电影开始一位临死的老人躺在病床上，旁边坐着她的女儿，她让女儿将一本老旧的笔记本翻来阅读出来。故事也由此开始。</p><p>本杰明的故事是悲剧的。在本的“老年时期”他遇到了他的那个她——Dasiy一位在福利院居住的老人的孙女。都说“我能想到最浪漫的事就是和你一起慢慢变老”，而本呢？只能看着自己心爱的人慢慢老去，而自己却在逐渐变年轻。年华正好，彼此相爱，他们有了爱情的结晶，可本此时只能选择离开，因为本清楚的知道一个将会变年轻的人是不会成为一个合格的父亲的，他也不想让妻子独自未来照顾两个孩子。幸福生活还没开始，便要离开，此刻本的内心世界又会是怎样一番情形呢？离开后的本仍不忘向家中寄明信片，写下自己对女儿说的话。“I wish …….”此刻我认为是电影情节的高潮部分，泪点一向很低的我没忍住哭了。离开后的本去过了印度，当过汽车修理工，做自己想做的事情，竭尽全力去追寻最好的自己。</p><p>一天，本回到了他们原来的家，此时黛西已经重新成家，此时的黛西脸上已经有了岁月的痕迹，而本杰明却更加的年轻了。那晚，他们来到本居住的宾馆，做爱了。此后，本开始越来越年轻，本逐渐开始出现了痴呆的症状，拥有少年外表的本神志越来越不清楚，最终被送到了当初长大的福利院内，福利院的人通知了黛西。当黛西来到福利院，看到了一位衣衫不整的少年斜侧着身子在那里弹钢琴，而本已经不认识黛西了。福利院的人告诉黛西，本的一本日记里许多次的提到了她，讲着你们两的故事。黛西决定留在福利院照顾日渐变小的本。黛西在变老，本却从会走路会说话慢慢地变成了一个只会哭的婴儿。电影最后的镜头直接浮现在脑海里：垂垂老矣的黛西坐在摇椅上抱着婴儿本，此刻的本仿佛认出了黛西，他们相望着，本慢慢地闭上了眼睛……..电影就此结束。<br>最喜欢黛西最后抱着襁褓中的本，他们那样相望着，好似一生一世的纠葛与痴缠到最后都可以通过这样一个穿越了年龄和岁月的眼神让对方明了，在彼此怀里安睡。</p><h3 id="《琅琊榜》"><a href="#《琅琊榜》" class="headerlink" title="《琅琊榜》"></a><a href="https://movie.douban.com/subject/25754848/">《琅琊榜》</a></h3><p><em>日期：2016-2-3</em></p><blockquote><p>以梅长苏之名，行天下赤子之义</p></blockquote><p>林殊以梅长苏之名，蛰伏十三年。当年大梁叱咤风云的赤焰军，奋勇杀敌，征战铁马，最终却在梅岭被小人所害。七万男儿，天地为墓，赤炎铮魂，情义千秋。林燮一家被灭门。一代名将，一世赤焰军，惨毁恶人之手。</p><p>梅岭一战，当年京城最明亮的少年已不在。时过境迁，江湖上流传着着琅琊榜首，江左梅郎的传说。时机已到，梅郎出山。计谋于心，权权相争，费尽心机，除尽大碍，祁王一案终得昭雪。长苏使命已尽，林殊之名得以见世。</p><p>“公子世无双，陌上人如玉”是对林殊与霓凰的最好诠释。分离十三年，得以相见。可自己知晓此聚终不会长久，曾经深中火寒之毒，受尽挫骨削皮之痛，难再享受常人之寿。霓凰情深林殊，林殊亦然。怜天不惜才，麒麟终折腰。纵然将来儿女成行，鬓白齿松，林殊哥哥也依旧是她的林殊哥哥。红颜旧，任凭斗转星移，唯不变此情悠悠。</p><p>此生一诺，来世必践。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/202008250811.jpg" alt="26fa4b02889d80e843b5e8318f574318e6_r"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200825002820.jpg" alt="416341246c1a677584ed4865910534ad_r"></p>]]></content>
    
    
    <categories>
      
      <category>人文派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>那些可爱的句子（持续更新）</title>
    <link href="/posts/62d2.html"/>
    <url>/posts/62d2.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文记录笔者自 2018 年开始收藏的句子，其出处可能是书中的金句、街边的 slogan 又或是电影台词，总之是来源于生活。收录标准全凭个人主观判定，我认为它们都是可爱的、能打动我的。</p>          </div><h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><ul><li>世界上高级的人很多，有趣的人也很多，又高级又有趣的人却少之又少。高级的人使人尊敬，有趣的人使人喜欢，又高级又有趣的人，使人敬而不畏，亲而不狎，交接愈久，芬芳愈醇。——余光中</li><li>怕什么真理无穷，进一寸有一寸的欢喜。—— 胡适</li><li>美就是理性的感性显现</li><li>康乐平生追壮观，未知席上极沧州。——《题多景楼》米芾</li><li>独学而无友，则孤陋而寡闻</li><li>人来人往中，耳机就像堡垒，既安全也孤独。 </li><li>人生如钟摆，在痛苦和无聊中徘徊</li><li>一只船孤独地航行在海上，<br>它既不寻求幸福，<br>也不逃避幸福，<br>它只是向前航行，<br>底下是沉静碧蓝的大海，<br>而头顶是金色的太阳。<br>将要直面的，<br>与已成过往的，<br>较之深埋于它内心的 皆为微沫。</li><li>世界上高级的人很多，有趣的人也很多，又高级又有趣的人却少之又少。高级的人使人尊敬，有趣的人使人喜欢，又高级又有趣的人，使人敬而不畏，亲而不狎，交接愈久，芬芳愈醇。——余光中</li><li>一流书是试图去回答那些永恒的问题，二流书是承担时代的情绪，三流书可能只是在无病呻吟，只是呻吟得比较漂亮，不入流的书，那纯粹是浪费纸。</li><li>非常奔放，实际上好悲伤</li><li>很多词可以形容我，怀旧可不在其中</li><li>真正把事情做起来的人，考虑事情是这样的，这件事我一定要做到，缺什么我在想办法补，而什么也做不起来的人，永远在等待时机成熟！</li><li>一只船孤独地航行在海上，它既不寻求幸福，也不逃避幸福，它只是向前航行，底下是沉静碧蓝的大海，而头顶是金色的太阳。将要直面的，与已成过往的，较之深埋于它内心的 皆为微沫。</li><li>不要把时间浪费在一些不三不四，不明不白，不痛不痒的人身上，因为这很不值。——钱钟书</li><li>最好的偷懒方式，是一次做好。</li><li>除了知情权以外，人也应该拥有不知情权，后者的价值要大得多。它意味着高尚的灵魂不必被那些废话和空谈充斥。过度的信息对一个过着充实生活的人来说，是一种不必要的负担。——亚历山大·索尔仁尼琴</li><li>觅之，自有所获</li></ul><h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><ul><li><p>你的模样我看见了，很温暖的样子</p><p>宛如你干净的文字</p><p>让人看了舒服，并且安心</p><p>我敢肯定，用不了十年</p><p>我们就会成为老朋友</p><p>到时候，你也许回来看我</p><p>或者我去看你。见面的时候</p><p>如果我习惯地去拉你的手</p><p>你一定不会吓着，不会不愿意</p><p>——海桑《你的模样我看见了》</p></li><li><p>不可能老是想着你</p><p>你不是我火烧眉毛的生活</p><p>但当闲暇的时候</p><p>就会偶尔把你想起</p><p>想起你我站在灵魂的深处</p><p>就那样相互望着</p><p>那么简单，那么美好</p><p>如果我不是小心忍着</p><p>就要一个笑出声来</p><p>——海桑《想起一个遥远的朋友》</p></li><li><p>有人住高楼，有人在深沟，有人光万丈，有人一身锈，世人万千种，浮云莫去求，斯人若彩虹，遇上方知有。有些人沦为平庸浅薄，金玉其外败絮其中。可不经意间，有一天你会遇到一个彩虹般绚丽的人，从此以后，其他人就不过是匆匆浮云。Some of us get dipped in flat, some in satin, some in gloss…. But every once in a while you find someone who’s iridescent, and when you do, nothing will ever compare——《怦然心动》</p></li><li><p>对于三十岁以后的人来说，十年八年不过是指缝间的事；而对于年轻人而言，三年五年就可以是一生一世——张爱玲《半生缘》</p></li><li><p>那些已经吃的满脑肥肠的跟还在饿着肚子的空论那些即将到来的美好时光</p></li></ul><h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><ul><li><p>人与人就是这样，对的人遇见了哪怕只有片刻都好像似曾相识，不对的人即使纠缠不清，也形同陌路</p></li><li><p>发呆是唯一不用付费的宇宙遨游，音乐是唯一不用离家的出走</p></li><li><p>白天要好好读书，书里有你不知道的。夜晚要好好睡觉，梦里有你想要的。</p></li><li><p>人就像藤萝，他的生存靠别的东西支持，他拥抱别人，就从拥抱中得到了力量。——蒲柏</p></li><li><p>有两件事我愈思考愈觉神奇，也愈充满敬畏，那就是，我头上的星空和我内心的道德准则。——康德【德】</p></li><li><p>就算知道毫无价值，也要呐喊出那早已毁坏的世界的歌谣</p></li><li><p>我是那些今非昔比的人，我是黄昏时分那些迷惘的人。——博尔赫斯《我们的全部往日》</p></li><li><p>不要只顾着向前走，也要时常回头，检视自己走过的路，是否偏离了出发的方向。人生并不是只有一个个节点，而是由抵达这些节点的无数片段组成。下午的阳光，黄昏的风，夜晚时回来的门铃，解开盖的热气，晚上十点的台灯，这些琐碎的日常，就是我们的整个人生。——L先生</p></li><li><p>My philosophy is that worrying means you suffer twice.</p><p>我的人生哲学是担忧意味着遭两次罪。——J·K·罗琳 《神奇动物在哪里》</p></li><li><p>你让我想起了汉娜·阿伦特说的一句话：“我这一生中从来没有爱过任何一个民族、任何一个集体——不爱德意志，不爱法兰西，不爱美利坚，不爱工人阶级，不爱这一切。我只爱我的朋友，我所知道、所信仰的惟一一种爱，就是爱人，每一个独立的人。”</p></li><li><p>分享一个我麻麻以前和我聊天的时候说的一句话：你外公那一代只是想要好好活着，我和你爸爸这一代想要的是好好生活，你这一代更多的想要寻找自我和实现理想，每一代人都有每一代人要承担的责任，只有这样，才能为下一代人的难以想象留出更多自由的空间。</p></li><li><p>无法理解你的沉默的人，基本上也没有可能理解你的诉说。——阿尔伯特·哈伯德</p></li><li><p>每个人在他的人生发轫之初，总有一段时光，没有什么可留恋，只有抑制不住的梦想，没有什么可凭仗，只有他的好身体，没有地方可去，只想到处流浪。——EB怀特</p></li><li><p>感觉到了的东西，我们不能立刻理解它。只有理解了的东西才能深刻地感觉它。</p></li><li><p>真正不羁的灵魂不会真的去计较什么，因为他们的内心有着国王般的骄傲。——《在路上》</p></li><li><p>本性若能稍有改变的话，也只能靠本性本身。</p></li><li><p>传说我们每个人对应着天体的一颗行星，从小接受唯物主义教育，本不该信奉神明，但要真是那样，对应我的那颗行星在我出生时定是黯淡无光。</p></li><li><p>每个人心中都有一团火，路过的人只看到烟</p></li><li><p>你说我是你的光  可正是你点亮了我</p></li><li><p>爱大概是这世界上最温柔的子弹…“砰”…</p></li><li><p>心心念念那抹阳光，可为何总是将你推远</p></li><li><p>快乐时的你一定心无愧怍。(拼音：kuì zuò，释义：指惭愧；羞愧。引申为因有缺点或错误而感到不安)</p></li><li><p>Money is like a sixth sense without which you cannot make a complete use of the other five.</p><p>金钱就像人的第六感，没有它你就无法完整地使用其他五感。——W. Somerset Maugham</p></li><li><p>Don’t judge anyone. Don’t regret anything. Don’t waste anytime.</p></li><li><p>奔赴一场劫难，却像去赴一场盛宴，永远去做那些令你害怕的事情。</p><p>You just go for a God-damned abyss of bitterness. Even if you virtually know that, you still treat it as a God-gifted banquet in that those which scare you make a tougher guy.</p></li><li><p>That day when the stars came falling. It was almost as if it were a scene from a dream, nothing more,nothing less than a beautiful view.</p><p>当彗星划过天空，那简直就像梦中的景色一样，只能一味的，眺望着那种无法言喻的美。</p></li><li><p>人的一生中，真正属于自己的财富只有两个：自己的“才华”和自己的“时间”。通常是才华越来越多而时间越来越少。人生就是用时间换取才华。每一个你不满意的现在，都有一个你没有努力的曾经。</p></li><li><p>当你每次产生一个想法时，带有这个想法的神经通道中的生化电磁阻力就会减少。这就像在丛林之中清出一条小路来一样。第一次得费一点儿劲，因为你必须清除掉一路的杂草蔓藤。第二次就容易多了，因为第一次走过这里时已经做了很多清障工作。</p></li><li><p>关于记忆最有趣的一点就是，你不能完全沉溺于其中</p><p>The funny thing about memory, is it can’t be fully trusted. And yet, in the end, it’s the only truth we have. And no matter how painful it is, you have got to look at the truth. Because sometimes it’s the only thing that can save you. It’s the only thing that can set you free.</p></li><li><p>有人问下辈子做不做中国人 当然要 凭什么 凭我识得汉字 赏得诗词 寄得风月</p></li><li><p>只有肤浅的人才不会以貌取人。世界的真谛是可见的，而不是隐形的。 ——王尔德</p><p>It’s only shallow people do not judge by appearence. The ture mystery of the world is visible, not the invisible.——Oscar Wilde</p></li><li><p>When love is in excess, it brings a man no honor nor worthiness. —— Euripides (尤里庇狄斯)</p></li><li><p>花若盛开，蝴蝶自来</p></li><li><p>人看火时的眼睛是比较诚实的</p></li><li><p>安静笃定，又不失春天般的温柔</p></li><li><p>只叹年少戏蝴蝶，今朝方觉书中趣</p></li><li><p>These violent delight have violent ends.</p><p>狂暴的欢愉必将有狂暴的结局</p></li><li><p>健全的灵魂叩问存在的意义难免陷入迷茫，然而这也正是生命确认自身价值的必然过程。</p></li><li><p>“最惨的，并不是莫名其妙的被人给领上了一条迷路，而是当你背上孤独拿上剑，决定要马不停蹄，一意孤行的时候，突然冒出一个人，把你抱紧，说，少年，我想和你分享这漫长的一生，你一激动，把剑给扔了，把马烤了，一回头，人没了。”</p></li><li><p>平等对待，共同奋斗</p><p>值得做的事，现在就去做</p><p>最可怕的是终生遗憾</p></li><li><p>人无癖，不可与交，以其无深情也；人无疵，不可与交，以其无真气也。——张岱</p></li><li><p>《这个杀手不太冷》中，有这样一段对白：</p><p>马蒂尔德：是生命本就如此艰辛还是只有童年如此？</p><p>里昂：是的，生命本就如此艰辛。</p></li><li><p>威胁是现实存在的，但恐惧只存在你的想象之中</p></li><li><p>感情有理智所根本不能理解的理由。</p></li><li><p>海中月是天上月</p><p>眼前人是心上人</p><p>向来心是看客心</p><p>奈何人是剧中人  ——张爱玲</p></li><li><p>雪莱:”我眼中流露的爱情，实在说，只是你自己的美在我灵魂上的反光。”</p></li><li><p>大多数人毕竟没有什么了不起，但他们本来可能很了不起。他们犯各种愚蠢的错误，以致感到极为痛苦，但仍不明白他们本意是好的但为何会落得这个结果。那些令人不愉快的人往往付出深深的痛苦的代价。他们应该受到怜悯而不是攻击。</p></li><li><p>任你红尘滚滚，我自清风朗明</p></li><li><p>“你知道人类最大的武器是什么吗？”“是豁出去的决心。”—伊坂幸太郎</p></li><li><p>我知这世界，本如露水般短暂。然而，然而。——小林一茶</p></li><li><p>在无聊面前即使神也会卷旗而去——尼采 </p></li><li><p>当一个人满怀悲伤的时候，总是喜欢看日落</p></li><li><p>对我没法去掌控的事情，我从来不问一字一句，即使我知道它们终将到来。</p></li><li><p>可惜了那些不抬头看星的人，错过了多少诗酒年华…</p></li><li><p>生活中只有一种英雄主义，那就是在认清生活真相之后依然热爱生活。——罗曼·罗兰</p></li><li><p>满腹心事不知说与谁听，茶人欲去酒客未留</p></li><li><p>我们这辈子最重要的三点是：</p><p>岁月安好、懂得感恩、与你相随</p><p>总的来说就是 Fine,thanks and you.</p></li><li><p>绅士就是：所做的，不是自己想做的之事，而是自己应做之事。</p></li><li><p>当你可以跟一个人不说话，分享片刻寂静，且不会觉得尴尬，那一刻你就会明白，你遇到了对的人。——《低俗小说》</p></li><li><p>若是你的快乐感不再那么强烈，</p><p>那么你的痛苦也不再那么揪心</p></li><li><p>事实上 机场比婚礼现场见证了更多真挚的接吻 医院的墙壁比教堂聆听了更多的祷告</p></li><li><p>你爱谁，谁就是正义</p></li><li><p>如果每个人都理解你，那你得普通成什么样。</p></li><li><p>一个人并不想要成为什么</p><p>他本来就如此这般</p></li><li><p>所以，记住，当你要做一个生命中重要的决定的时候，你得想长远一点，你得问问你自己，“我能一直这样生活下去吗？</p></li><li><p>“当你在暗夜里独自努力奋斗的时候，不要觉得孤独，你要想到，这世界上有千万个牛人正在跟你一起奔跑。你要努力奋斗想办法，和这些牛人打成一片，有一天你不仰慕别人的时候，你才会成为牛人。”</p></li><li><p>当善良的人扯下面具，你连下跪的机会都没有</p></li><li><p>住在五光十色的城市里，没有理由不染上一点颜色——亦舒</p></li><li><p>如果天空是黑暗的，那就摸黑生存；如果发出声音是危险的，那就保持沉默；如果自觉无力发光的，那就蜷伏于墙角。但不要习惯了黑暗就为黑暗辩护；不要为自己的苟且而得意；不要嘲讽那些比自己更勇敢热情的人们。我们可以卑微如尘土，不可扭曲如蛆虫。——季业</p></li><li><p>爱情本身并不具有天然的正义性，屈从于欲望的人只是软弱，而不是真性情。爱情是因发生在美好的人之间，才更美好。</p></li><li><p>人可生如蚁，而美如神——顾城</p><p>时间是一个自称能包治百病的庸医</p><p>只有上帝知道我有多爱你</p><p>天神在你眉宇之间</p></li><li><p>欣赏一个人，始于颜值，敬于才华，合于性格，久于善良，终于人品。</p></li><li><p>“你觉得爱情是什么？”舒适且不尴尬的沉默“</p></li><li><p>喜欢iPad你就去买，喜欢莱卡你就去赚，想喝港式奶茶你就过口岸，想当team leader你就努力学习然后努力去工作，想去威尼斯你就攒钱去，想爱谁你就去爱，想追谁你就去追，想到了就去做，拼命努力，拼命享受，忍着守着惦记着，青春就过去了，何必用40岁的心态过20岁的年华。</p></li><li><p>When I’m scared to tackle an obstacle, I close my eyes and pretend I’m an 80 year old man who regrets not tackling all the obstacles he wanted to in life. Then when I feel like that old man, I say to myself, “I wish I was young again”, then I open my eyes…And BOOM! I’m young again.</p><p>每当我遇到自己不敢直视的困难时，我就会闭上双眼，想象自己是一个80岁的老人，为人生中曾放弃和逃避过的无数困难而懊悔不已。我会对自己说，“能再年轻一次就好了”，然后我睁开眼睛：砰！我又年轻一次了！</p></li><li><p>在我们的一生中，遇到爱，遇到性，都不稀罕。</p><p>稀罕的是遇到了解</p></li><li><p>黎明的到来不一定能给人希望，但总是能抹去昨日的昏暗。</p></li><li><p>柴静说过一段话：“理性和感性是不冲突的，跟理性冲突的是蒙昧，跟感性冲突的是麻木。理性和感性应该给人双重的滋养，此端越深、彼端越深。”</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>人文派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 中的学习型项目（持续更新）</title>
    <link href="/posts/6877.html"/>
    <url>/posts/6877.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/">GitHub</a> 作为全球最大的 <del>同性交友</del> 代码托管平台，在有众多开源代码库的同时，也有许多非常有用的学习资源。在此笔者将在使用 GitHub 过程中所收集到的优质资源汇总，以便日后查阅和分享。</p><p>当然某些拓展内容包括但不限于GitHub。</p><h2 id="文章排版"><a href="#文章排版" class="headerlink" title="文章排版"></a>文章排版</h2><p>一篇优秀的文章不仅需要内容的优质，同时在排版上也需要美观（谁叫我们是视觉动物？）。</p><div class="note note-success">            <ul><li><p><a href="https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.zh-CN.md">中文文案排版指北</a></p><p>「详细全面地讲解了文案排版的风格规范。」</p></li><li><p><a href="https://github.com/ruanyf/document-style-guide">中文技术文档的写作规范</a></p><p>「阮一峰老师所著，内容同样非常全面。」</p></li><li><p><a href="https://sspai.com/post/37815">少数派写作排版指南</a></p><p>「这是少数派文书表述上的一些文字格式和风格规范。」</p></li><li><p><a href="https://practicaltypography.com/">Butterick’s Practical Typography</a></p><p>「这个网站介绍了关于排版和字体的相关知识，侧重使用和在印刷，网站等产品上的实际体验。」</p></li></ul>          </div><h2 id="如何提问"><a href="#如何提问" class="headerlink" title="如何提问"></a>如何提问</h2><p>如何高效提问是一个重要命题。</p><div class="note note-success">            <ul><li><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">提问的智慧</a></p><p>「在互联网上如何抛出一个问题，并获得你想得到的答案？这本书告诉了你应该如何去做。」</p></li><li><p><a href="https://book.douban.com/subject/20428922/">学会提问</a></p><p>「此为豆瓣书链。《学会提问》是一本适用范围更广泛的书籍，推荐阅读。」</p></li></ul>          </div><h2 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a>英语学习</h2><p>好的，在我的收藏夹吃灰吧！</p><div class="note note-success">            <ul><li><p><a href="https://github.com/byoungd/English-level-up-tips-for-Chinese">English-level-up-tips-for-Chinese</a></p><p>「可能是让你受益匪浅的英语进阶指南。」</p><p>​注：想要获得更好的阅读体验，请访问本指南对应的 <a href="https://byoungd.gitbook.io/english-level-up-tips/">GitBook</a> 页面。</p></li><li><p><a href="https://github.com/jgsrty/jgsrty.github.docs">jgsrty.github.docs</a></p><p>「此项目旨在培养阅读习惯，提高英文读写能力。」</p><p>​注： <a href="https://wr0926.ml/go.html?u=https://rtyxmd.gitee.io/">国内访问地址 - 速度更快</a></p></li></ul>          </div><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><blockquote><p>“Life is short, you need Python”</p><p>“人生苦短，我用 Python”</p></blockquote><div class="note note-success">            <ul><li><p><a href="https://github.com/HaoZhang95/Python24">Python24</a></p><p>「集合了某培训机构的 Python 教学视频以及讲义和项目代码（同时包含一些深度学习的内容），如果自学的   话算是比较系统的教学资源。」</p></li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 排坑日记（持续更新）</title>
    <link href="/posts/7487.html"/>
    <url>/posts/7487.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本文最后更新于：2022年 7月 16 日</p>          </div><div class="note note-success">            <p>在此记录我在搭建 Hexo 博客中所遇到的坑以及解决办法。</p>          </div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>曾经年少被 “10 分钟搭建属于自己的个人博客” 的教程（ <del>忽悠</del> ）所鼓舞。风风火火地搭建好基于 Hexo 的个人博客，可谁知接下来等着自己的是各种出乎意料的 Bug。</p><h2 id="YAML-语法错误"><a href="#YAML-语法错误" class="headerlink" title="YAML 语法错误"></a>YAML 语法错误</h2><ul><li><strong><code>YAML Exception: bad indentation of a mapping entry at line xxx</code>  错误提示</strong></li></ul><p>  根据 <a href="https://hexo.io/zh-cn/docs/troubleshooting.html">Hexo 官方文档</a> 说明：</p><blockquote><p>如果 YAML 字符串中包含冒号（<code>:</code>）的话，请加上引号。</p><p>请确认您使用空格进行缩进（Soft tab），<strong>并确认冒号后有加上一个空格</strong>。</p></blockquote><p>  在对应的提示位置加上空格或者引号即可。YAML 拥有严格的语法标准，在某些地方多一个或少一个空格都会导致编译报错。</p><p>  <strong>But</strong>！在一次修改代码友链代码的过程中，提示友链的某个位置语法错误。在检查提示位置后未发现任何缺少引号或空格的错误。随后将此段代码放入 YAML 编辑器中并未提示错误。进一步检查中发现是<strong>之前一段代码</strong>出现了语法错误（多了一个引号）。</p><p>  也就是说，如果报错 <code>YAML Exception: bad indentation of a mapping entry at line xxx</code>，在检查此位置没有语法错误之后，应该对其余位置的代码进行语法检查。</p>  <div class="note note-danger">            <p><strong>注</strong>：所以建议在修改无果的情况下，将所有代码都复制到 <a href="http://www.bejson.com/validators/yaml_editor/">YAML、YML在线编辑(校验)器</a> 中进行语法检查，而不是只将某一段代码带入检查。</p>          </div><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li><strong>webp 格式图片无法在 Safari 浏览器显示</strong></li></ul><p>  原因：webp 是谷歌研发的，属于商业纠葛。</p><p>  解决：为了全平台都能正常显示，并且不想额外折腾 CCS 代码，只好乖乖在博客中不使用 webp 格式的压缩图片。</p><h2 id="valine-评论系统失效"><a href="#valine-评论系统失效" class="headerlink" title="valine 评论系统失效"></a>valine 评论系统失效</h2><p>某日突然发现评论系统出故障。之前的评论消失，且无法进行新的评论。</p><p>后来询问 <a href="https://www.lete114.top/">@Lete乐特</a> 才明白原来是 “LeanCloud的问题，国内版无影响，国际版需要添加 serverURLs”。</p><p>在主题 <code>config.yml</code> 中添加对应字段即可。（自己排查了两三天，问大佬一下就解决了~真的强呀！）</p><p>先附上 <a href="https://www.lete114.top/">@Lete乐特</a> 答复的内容，以供参考。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926163426.png" alt="QQ图片20200926123515"></p><h2 id="PicGo-上传错误"><a href="#PicGo-上传错误" class="headerlink" title="PicGo 上传错误"></a>PicGo 上传错误</h2><ul><li><p>错误信息：Failed to fetch</p><p>错误原因：<strong>端口设置错误</strong> 造成的。</p><p>解决方法：打开设置，点击设置 Server 选项，<strong>将端口改为 36677 端口</strong>，这是 PicGo 推荐的默认端口号。</p></li><li><p>错误信息：{“success”,false}</p><p>错误原因：文件名冲突。</p><p>解决方法：打开设置，将【<strong>时间戳重命名】</strong>打开。</p></li></ul><h2 id="重装系统后无法部署"><a href="#重装系统后无法部署" class="headerlink" title="重装系统后无法部署"></a>重装系统后无法部署</h2><p><strong>问题代码：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Permission denied (publickey).<br>fatal: Could <span class="hljs-keyword">not</span> <span class="hljs-built_in">read</span> <span class="hljs-built_in">from</span> remote repository.<br>Please make sure you have <span class="hljs-keyword">the</span> correct access rights <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> repository exists.<br></code></pre></td></tr></table></figure><p><strong>问题分析：</strong>GitHub 和本地的 SSH 没有进行关联，需要在 GitHub 上 <code>new SSH keys</code> ，然后与本地进行关联。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/picgo/img/202204121058880.png" alt="img"></p><p>注：</p><ol><li><p>生产 SSH 时的有效期可以选择 <code>永久</code>，这样就不需要定期重新生成。</p></li><li><p>GitHub 上的 Token 只会显示一次，建议用备忘录记下以便后续会用到。</p></li></ol><h2 id="Error：hexo-command-not-found"><a href="#Error：hexo-command-not-found" class="headerlink" title="Error：hexo: command not found"></a>Error：hexo: command not found</h2><p>首先检查 nodejs 和 npm 是否正常，依次输入命令 <code>node -v</code> 和 <code>npm -v</code> 看看是否有相关版本信息；</p><p>出现了版本信息就证明 nodejs 和 npm 是没有问题的，那么就应该是环境变量的配置问题了，在【此电脑】右键【属性】，依次选择【高级系统设置】-【环境变量】，选择系统变量 Path，将 <code>node_modules</code> 下的 <code>.bin</code> 文件路径添加到 Path 里面</p><p>eg: <code> D:\MyBlog\node_modules\.bin</code></p><p>环境变量添加好了之后重新打开 git 即可运行 hexo 命令，如果此时仍然无法执行 hexo 命令，则可以运行命令 <code>npm install hexo-cli -g</code> 重新安装 hexo 。</p><h2 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h2><p>[1] <a href="https://blog.csdn.net/qq_36759224/article/details/100411949">完美解决 bash: hexo: command not found</a></p>]]></content>
    
    
    <categories>
      
      <category>折腾派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客站点加速不完全指南</title>
    <link href="/posts/db37.html"/>
    <url>/posts/db37.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们使用 Hexo 作为框架搭建静态博客时，存在两个主要因素影响着网站访问速度。</p><ul><li><p>GitHub 在国内访问速度不稳定</p><p>由于我们搭建的博客是放在 GitHub 上面的，而国内用户直接访问 GitHub 网速不佳。这将是十分影响博客的用户体验。所以使用国内访问速度更快的托管服务商 Vercel （当然也可以用别的服务商，只是在国内来说 Vercel 效果较好）进行网站托管；</p></li><li><p>在使用本地图库引用的情况下，当博客图片资源过大时，网站图片加载会变得缓慢。</p></li></ul><p>所以，我们在此主要针对以上两个问题来进行优化。</p><h2 id="Vercel-托管"><a href="#Vercel-托管" class="headerlink" title="Vercel 托管"></a>Vercel 托管</h2><p><strong>Vercel</strong> 是一家提供 JamStack（静态网站）托管的平台，支持自动从 GitHub 等仓库拉取代码, 按自定义构建方式进行构建，最后把生成的静态网站进行发布; 在这基础上同时也支持自定义域名，自动申请 SSL 证书等功能。</p><p>由于国内访问 Vercel 的速度要比访问 GitHub pages快很多，所以我们只需要把站点交给 Vercel 进行托管就能大幅度提升博客的加载速度。</p><div class="note note-success">            <p>参考教程： <a href="https://vincentqin.tech/posts/speedup-gitpage/">使用 Vercel 加速 Hexo 静态博客访问</a> </p>          </div><p>在使用 Vercel 托管之后，访客在访问博客网站时相当于是在访问 Vercel 的服务器（因为此时已经在域名服务商处处新增了对应 Vercel 站点的域名解析），而不是去访问最开始的 GitHub pages 网址。</p><p>此外，按照上述教程进行操作之后，查看 Domain 一栏是否解析生效。此时可能会出现一会儿配置失败，一会儿配置成功的情况。若出现标红提示配置失败，点击查看错误提示。<strong>如果是提示更改为 Vercel 的 DNS 服务器，只需到你博客域名服务商，将 DNS 服务器地址更改为 Vercel 要求的地址即可。</strong>（例如我的域名服务商是阿里云，我到官网去把阿里云官方的 DNS 服务器地址改为 Vercel 的即可。DNS 服务器地址为两个，都需要进行更改）<img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812033929.png" alt="Snipaste_2020-08-12_02-35-18"></p><p><strong>效果图</strong></p><p>对比站点 github.io 的原始域名，访问延迟明显减小：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200814001334.png" alt="对比"></p><p>使用百度站长对网站速度进行测试：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812040604.png" alt="网站速度诊断"></p><h2 id="jsDelivr-加速"><a href="#jsDelivr-加速" class="headerlink" title="jsDelivr 加速"></a>jsDelivr 加速</h2><p>在博客的撰写中，我们一般是直接引用本地图库资源（使用 hexo-asset-image 插件）对文章进行配图。之后再<code>hexo g -d</code> 将文章和图片资源一同部署到 GitHub 。而我们在访问这些图片资源时又需要再从 GitHub 上进行提取，而 GitHub 上的访问速度本身已经很慢，再去加载大量图片更加会拖慢网页速度。虽然我们前面已经对博客进行了 Vercel 托管，但是我们有一种更简单高效的方式对图片进行上传，那就是<strong>利用 GitHub 图库+ jsDelivr CDN 加速+ PicGo 客户端实现图库的高效使用</strong>。</p><p>简单说明以上三个工具的使用情形：</p><ul><li><p>GitHub 图库：用于存放我们需要使用的文章配图文件的仓库；</p></li><li><p>jsDelivr ：用于 CDN 加速，在 Markdown 文本编辑器中直接引用 jsDelivr 的图片外链，即可快速访问图片资源；</p></li><li><p>PicGo：用于 Markdown 写作端生成对应的 jsDelivr 图片外链，配合 Typora 编辑器时可直接拖拽图片自动生成外链使用。（<strong>故推荐 Typora 客户端 + PicGo 客户端搭配使用，食用效果更佳！</strong>）</p><p>​</p></li></ul><p><strong>什么是 jsDelivr ?</strong></p><blockquote><p>jsDelivr 是国外的一家优秀的公共CDN 服务提供商，也是首个「打通中国大陆（网宿公司运营）与海外的免费CDN 服务」。 jsDelivr 有一个十分好用的功能——它可以加速Github 仓库的文件。 我们可以借此搭建一个免费、全球访问速度超快的图床。</p></blockquote><p><strong>什么是 PicGo ?</strong>  </p><blockquote><p>一个用于快速上传图片并获取图片URL链接的工具。</p></blockquote><div class="note note-success">            <p>参考教程：</p><ul><li><a href="https://www.itrhx.com/2019/08/01/A27-image-hosting/">Github+jsDelivr+PicGo 打造稳定快速、高效免费图床</a></li><li><a href="https://www.cnblogs.com/hoxis/p/12470044.html">Typora原生集成PicGo图床工具！</a></li></ul>          </div><hr><p><strong>此方法会弃用本地图库，启用 GitHub + jsDelivr + PicGo 的方式对文章进行配图操作。</strong> </p><p>所以可以卸载 hexo-asset-image 插件，保持 Hexo 的清爽：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm remove  hexo-asset-image<br></code></pre></td></tr></table></figure><p>并在配置文件_config.yml 中将此行由 true 改为 false：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>此时，在你每次<code>hexo n &quot;title&quot;</code> 的时候就不会在 _posts下面生成同名的文件夹放图片文件了，大可将需要使用的图片放在除博客文件的其他位置（所以你甚至可以把已经生成外链的图片删掉），因为照片放在专门的图片仓库，利用 jsDelivr 外链就可以直接访问，你不需要再将这些图片上传到博客的 GitHub 仓库里面去。下图红色地址就是我们直接可以访问到图片的 jsDelivr 外链地址。你可以点来试下，看看是不是我们下面这张图。 <a href="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812034534.png">https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812034534.png</a></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812034534.png" alt="Snipaste_2020-08-12_03-45-17"></p><blockquote><p>注：在使用 PicGo 客户端时会遇到一些问题，具体解决方法参考：<a href="https://www.cnblogs.com/hoxis/p/12470044.html">Typora原生集成PicGo图床工具！</a> </p></blockquote><p>在使用图床之后，我们所用的的图片就可以不放在本地。那么图片在每次编译部署也就不用上传到网上，这缩短了编译时间。</p><h2 id="Valine-评论系统-（邮件提醒）"><a href="#Valine-评论系统-（邮件提醒）" class="headerlink" title="Valine 评论系统 （邮件提醒）"></a>Valine 评论系统 （邮件提醒）</h2><div class="note note-success">            <p>参考教程：</p><ul><li><a href="https://lete114.now.sh/article/Valine-LeanCloud-Config.html#%E5%89%8D%E8%A8%80">LeanCloud-Valine 保姆及配置教程</a></li><li><a href="https://lete114.now.sh/article/da1d5c8b.html">LeanCloud 因控流原因的解决办法</a></li></ul>          </div><h2 id="其他优化教程"><a href="#其他优化教程" class="headerlink" title="其他优化教程"></a>其他优化教程</h2><div class="note note-success">            <p>参考教程：</p><ul><li><p><a href="https://indexmoon.com/articles/1153730074/">Hexo 基础教程(四)：功能添加与优化</a></p><p>包含：添加 RSS，代码压缩，文章链接唯一化，SEO（搜索引擎优化）等内容。</p></li></ul>          </div><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>完成上述操作之后，博客的打开速度不出意外就会快很多。不过做了这么多操作，我们最核心关注的点还是应该在<strong>博客内容质量</strong>，以及<strong>输出频率</strong>上。总结下来就是内容为王，同时兼顾用户体验。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://vincentqin.tech/posts/speedup-gitpage/">使用 Vercel 加速 Hexo 静态博客访问</a></li><li><a href="https://www.itrhx.com/2019/08/01/A27-image-hosting/">Github+jsDelivr+PicGo 打造稳定快速、高效免费图床</a></li><li><a href="https://www.cnblogs.com/hoxis/p/12470044.html">Typora原生集成PicGo图床工具！</a></li><li><a href="https://blog.juanertu.com/archives/adff04af.html">PicGo+GitHub快速实现markdown图床</a></li><li><a href="https://juejin.im/post/6844904137407086600">利用 GitHub + PicGo + Typora 搭建属于自己的图床</a></li><li><a href="https://blog.iljw.me/2019/05/jsdelivr-cdn-github.html">使用 jsDelivr CDN 加速 Github 仓库的图片，以作为博客的图床</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 常用命令及备份指南</title>
    <link href="/posts/7da2.html"/>
    <url>/posts/7da2.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>在此记录常用 Hexo 命令及备份方式。</p>          </div><h2 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h2><ul><li><p><code>hexo n &quot;title&quot;</code> 创建新文章；</p></li><li><p><code>hexo g -d</code>  生成静态文件（gnerate），且文件生成后立即部署网站（deploy）；</p></li><li><p><code>hexo publish &quot;title&quot; </code>  发表草稿；</p></li><li><p><code>hexo s</code>  启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>；</p></li><li><p><code>hexo clean</code>  清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)；</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令；</p></li><li><p><code>hexo version</code>  显示 Hexo 版本；</p></li><li><p><code>npm list</code> 查看插件；</p></li><li><p><code>npm uninstall 插件名称</code> 卸载插件；</p></li></ul><h2 id="二、备份博客"><a href="#二、备份博客" class="headerlink" title="二、备份博客"></a>二、备份博客</h2><p>使用 <strong><a href="https://github.com/coneycode/hexo-git-backup"> hexo-git-backup</a></strong> 插件进行备份操作。</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>如果 Hexo 版本是 3.x.x，则应按如下方式安装：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ npm <span class="hljs-keyword">install </span>hexo-git-<span class="hljs-keyword">backup </span>--save<br></code></pre></td></tr></table></figure><h3 id="插件升级"><a href="#插件升级" class="headerlink" title="插件升级"></a>插件升级</h3><p>如果使用 –save 安装，则在更新时必须先删除。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ npm remove hexo-git-<span class="hljs-keyword">backup</span><br><span class="hljs-keyword"></span>$ npm <span class="hljs-keyword">install </span>hexo-git-<span class="hljs-keyword">backup </span>--save<br></code></pre></td></tr></table></figure><h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><p>在博客目录根的 _config.yml 中增加相应配置。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">backup:</span><br><span class="hljs-symbol">    type:</span> git<br><span class="hljs-symbol">    theme:</span> coney,landscape,xxx<br><span class="hljs-symbol">    repository:</span><br><span class="hljs-symbol">       github:</span> git@github.com:xxx/xxx.git,branchName<br><span class="hljs-symbol">       gitcafe:</span> git@github.com:xxx/xxx.git,branchName<br></code></pre></td></tr></table></figure><p>其中 branchName 为在 GitHub 中博客仓库中自行创建的分支名称。若需要备份主题则在 theme 处添加主题名称。</p><blockquote><p>插件更多配置细则请参考官方文档。</p></blockquote><h3 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h3><p><code>hexo b</code>  备份博客到 GitHub 上对应的 backup 分支。</p><p><strong>建议每次发布博客 <code>hexo d</code> 的时候都同时 <code>hexo b</code> 对博客进行备份更新。</strong></p><h2 id="三、恢复博客"><a href="#三、恢复博客" class="headerlink" title="三、恢复博客"></a>三、恢复博客</h2><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>在新环境下根据 <a href="https://hexo.io/zh-cn/">Hexo官方文档</a> 安装配置好Hexo环境，</p><p>安装博客部署到 GitHub 所需要的插件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-deployer-git</span><br></code></pre></td></tr></table></figure><h3 id="覆盖本地文件"><a href="#覆盖本地文件" class="headerlink" title="覆盖本地文件"></a>覆盖本地文件</h3><p>从之前插件备份到 GitHub 分支中下载博客文件到本地，并覆盖本地博客文件。</p><p>此外，可以只下载其中的 <code>config.yml，theme/，source/，scaffolds/，package.json，.gitignore</code> 这六个文件覆盖。</p><p>此时运行如下三连进行测试博客是否迁移成功。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>如果成功接下来就是安装常用插件的任务了….</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>如果不想使用 <a href="https://github.com/coneycode/hexo-git-backup">hexo-git-backup</a> 插件对博客进行备份，可参考此文：<a href="https://lrscy.github.io/2018/01/26/Hexo-Github-Backup/">在Github上备份Hexo博客</a> 。</li><li>在 <code>hexo d</code> 时若出现 <code>fatal: &#39;github&#39; does not appear to be a git repository</code> 的错误，请参考此 <a href="https://github.com/coneycode/hexo-git-backup/issues/8">Issue</a> 。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hexo.io/zh-cn/docs/commands">Hexo官方文档</a></li><li><a href="https://github.com/coneycode/hexo-git-backup">hexo-git-backup</a></li><li><a href="https://mxy493.xyz/2019/05/25/Hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6hexo-git-backup%E9%80%9A%E8%BF%87GitHub%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/">Hexo博客使用插件hexo-git-backup通过GitHub备份与恢复</a></li><li><a href="https://lrscy.github.io/2018/01/26/Hexo-Github-Backup/">在Github上备份Hexo博客</a></li><li><a href="https://www.dazhuanlan.com/2019/10/12/5da110cdd9a7b/">卸载 hexo 插件</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo&#39;s Fluid 主题私人定制（持续更新）</title>
    <link href="/posts/40222.html"/>
    <url>/posts/40222.html</url>
    
    <content type="html"><![CDATA[<div class="note note-danger">            <p>注：随着主题版本升级，主题文件内容可能有变动，请谨慎参考。</p>          </div><p>快速到达指南：</p><ul><li><a href="http://localhost:4000/posts/40222.html#%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E4%BC%98%E5%8C%96">版权声明优化</a></li><li><a href="http://localhost:4000/posts/40222.html#%E6%B7%BB%E5%8A%A0%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4">添加运行时间</a></li><li><a href="http://localhost:4000/posts/40222.html#%E5%85%B3%E4%BA%8E%E9%A1%B5%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA">关于页添加评论</a></li><li><a href="http://localhost:4000/posts/40222.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93">自定义字体</a></li><li><a href="http://erenship.com/posts/40222.html#%E8%AF%84%E8%AE%BA%E6%A0%B7%E5%BC%8F%E7%BE%8E%E5%8C%96">评论样式美化</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在茫茫 Hexo 主题中，一眼选中了 Material Design 风格的 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid 主题</a>。老实说基本功能已经完全够用了，可以骨子里那股折腾劲儿又来了，看着自己的网站总觉得哪儿哪儿不顺心。于是有了此贴，专门用来记录笔者自定义 Fluid 主题的过程，以便日后查阅，同时也供相同主题版本的朋友参考。</p><h2 id="版权声明优化"><a href="#版权声明优化" class="headerlink" title="版权声明优化"></a>版权声明优化</h2><div class="note note-primary">            <p>目的：修改文章页底部版权声明内容，实现显示 “本文作者”、“本文地址”、“版权声明” 的内容。</p>          </div><p>目前 Fluid 版本（v1.8.1）中文章末尾版权声明仅设置显示为：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/202008120027886.png" alt="Snipaste_2020-08-08_12-08-18"></p><p>而看到许多博客文章末尾都有完整的文章信息，例如“本文作者”，“本文地址”，“版权声明”等。</p><p>在 Next 等主题中自带文章末尾可以添加“文章链接”，只需要在 <code>_config.yml</code> 中 <code>enable</code> 相应模块即可，效果如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812000800.png" alt="Snipaste_2020-08-08_13-41-30"></p><p>而在 Fluid 主题中则需要用户对相应配置文件进行修改。</p><p>在网上搜寻方法时发现 <a href="https://github.com/julydate">七夏浅笑</a> 针对 Fluid 主题修改的版本实现了版权声明处的文章链接显示。因为都是使用 Fluid 主题，所以想着对方应该能够解答自己的疑惑所以通过邮件进行了联系。很快得到了大佬答复：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812002839.png" alt="Snipaste_2020-08-08_14-04-18"></p><p>根据大佬的提示（还贴心地标出代码位置，小姐姐很 nice 了），并结合网上相应对版权声明修改的资料进行了操作。</p><p><strong>步骤</strong></p><ol><li><p>打开 <code>themes\fluid\layout</code> 中的 <code>post.ejs</code> 文件；</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812002927.png" alt="Snipaste_2020-08-08_14-10-26"></p></li><li><p>找到以下内容进行修改；</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812003002.png" alt="Snipaste_2020-08-08_14-15-44"> </p><p>将红色部分替换为以下代码：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bnf">   <span class="hljs-attribute">&lt;% if(theme.post.copyright.enable &amp;&amp; theme.post.copyright.content &amp;&amp; page.copyright !== false) &#123; %&gt;</span><span class="hljs-attribute">&lt;p class=&quot;note note-warning&quot;&gt;</span><br><span class="hljs-attribute">&lt;strong&gt;</span>本文作者: <span class="hljs-attribute">&lt;/strong&gt;</span><span class="hljs-attribute">&lt;a href=&quot;&lt;%- url_for() %&gt;</span>&quot;&gt;<span class="hljs-attribute">&lt;%- theme.about.name || config.author || config.title %&gt;</span><span class="hljs-attribute">&lt;/a&gt;</span> <span class="hljs-attribute">&lt;br&gt;</span><br><span class="hljs-attribute">&lt;strong&gt;</span>本文链接: <span class="hljs-attribute">&lt;/strong&gt;</span><span class="hljs-attribute">&lt;a href=&quot;&lt;%- full_url_for(page.path) %&gt;</span>&quot;&gt;<span class="hljs-attribute">&lt;%-   full_url_for(page.path) %&gt;</span><span class="hljs-attribute">&lt;/a&gt;</span> <span class="hljs-attribute">&lt;br&gt;</span><br><span class="hljs-attribute">&lt;strong&gt;</span>版权声明: <span class="hljs-attribute">&lt;/strong&gt;</span><span class="hljs-attribute">&lt;%- theme.post.copyright.content %&gt;</span><br>   <span class="hljs-attribute">&lt;/p&gt;</span><br>   <span class="hljs-attribute">&lt;% &#125; %&gt;</span><br></code></pre></td></tr></table></figure><p>替换结果：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/202003812003531.png" alt="Snipaste_2020-08-08_14-18-01"></p></li><li><p>保存文件，cmd  <code>hexo clean</code> <code>hexo s</code> 查看效果；</p></li></ol><p>   实现目标：版权声明处添加“本文链接”并能自动生成文章链接。</p><p>   <img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/202008120403506.png" alt="Snipaste_2020-08-08_14-22-34"></p><ol start="4"><li>cmd  <code>hexo g -d</code>  部署博客。Bingo！</li></ol><p><strong>修改 Tag 颜色</strong></p><ol><li><p>根据 <a href="https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6">官方文档 </a>了解到 Tag 相应的语法；</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/202008120403517.png" alt="Snipaste_2020-08-08_14-48-24"></p></li><li><p>如果要修改 Tag 颜色只需要修改 <code>&lt;p class=&quot;note note-warning&quot;&gt;</code> 即可。</p></li></ol><p><strong>错误做法</strong></p><ol><li><p>修改主题配置文件 <code>config.yml</code></p><p>一开始笔者以为只需要简单的修改主题配置文件 <code>_config.yml</code> 里面版权声明处，但在“本文链接”无法正常生成链接。即使在“本文链接”后面加上代码仍然失败。</p></li></ol><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&lt;a href=<span class="hljs-string">&quot;&lt;%- full_url_for(page.path) %&gt;&quot;</span>&gt;&lt;<span class="hljs-meta">%</span>- full_url_for<span class="hljs-comment">(page.path)</span> <span class="hljs-meta">%</span>&gt;&lt;/a&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812003717.png" alt="微信图片_20200807203239"></p><p>​<code>hexo s</code> <code>hexo g</code> 生成结果如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812003237.png" alt="Snipaste_2020-08-08_13-57-16"></p><p>​2. 单纯复制修改主题的代码</p><p>前面谈到有位小姐姐修改的 <a href="">Fluid主题</a> 能实现我的目标，我寻思着直接找她改动的代码不就行了吗。于是直接就把相应位置的代码给 copy 了过来，结果造成了页面错误。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812003422.png" alt="Snipaste_2020-08-07_23-39-01"></p><p>最后进行修改调试，才恢复正常。</p><h2 id="添加运行时间"><a href="#添加运行时间" class="headerlink" title="添加运行时间"></a>添加运行时间</h2><p class="note note-primary">目的：在站点页面页脚处实时显示网站运行时间 & 自定义页脚信息。</p><p><strong>步骤</strong></p><ol><li><p>打开文件夹 <code>\themes\fluid\layout\_partial</code> 下的 <code>footer.ejs</code> 文件。</p></li><li><p>在任意处添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;timeDate&quot;</span>&gt;</span>载入天数...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;times&quot;</span>&gt;</span>载入时分秒...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();</span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createtime</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> grt= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;07/02/2020 00:00:00&quot;</span>);<span class="hljs-comment">//此处修改你的建站时间或者网站上线时间</span></span><br><span class="language-javascript">      now.<span class="hljs-title function_">setTime</span>(now.<span class="hljs-title function_">getTime</span>()+<span class="hljs-number">250</span>);</span><br><span class="language-javascript">      days = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span>;</span><br><span class="language-javascript">      dnum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(days);</span><br><span class="language-javascript">      hours = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * dnum);</span><br><span class="language-javascript">      hnum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(hours);</span><br><span class="language-javascript">      <span class="hljs-keyword">if</span>(<span class="hljs-title class_">String</span>(hnum).<span class="hljs-property">length</span> ==<span class="hljs-number">1</span> )&#123;</span><br><span class="language-javascript">          hnum = <span class="hljs-string">&quot;0&quot;</span> + hnum;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      minutes = (now - grt ) / <span class="hljs-number">1000</span> /<span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * hnum);</span><br><span class="language-javascript">      mnum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(minutes);</span><br><span class="language-javascript">      <span class="hljs-keyword">if</span>(<span class="hljs-title class_">String</span>(mnum).<span class="hljs-property">length</span> ==<span class="hljs-number">1</span> )&#123;</span><br><span class="language-javascript">                mnum = <span class="hljs-string">&quot;0&quot;</span> + mnum;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      seconds = (now - grt ) / <span class="hljs-number">1000</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * hnum) - (<span class="hljs-number">60</span> * mnum);</span><br><span class="language-javascript">      snum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(seconds);</span><br><span class="language-javascript">      <span class="hljs-keyword">if</span>(<span class="hljs-title class_">String</span>(snum).<span class="hljs-property">length</span> ==<span class="hljs-number">1</span> )&#123;</span><br><span class="language-javascript">                snum = <span class="hljs-string">&quot;0&quot;</span> + snum;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;timeDate&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;🚀 for&amp;nbsp&quot;</span>+dnum+<span class="hljs-string">&quot;&amp;nbspdays&quot;</span>;  <span class="hljs-comment">//此次自定义显示内容</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;times&quot;</span>).<span class="hljs-property">innerHTML</span> = hnum + <span class="hljs-string">&quot;&amp;nbsphr&amp;nbsp&quot;</span> + mnum + <span class="hljs-string">&quot;&amp;nbspmin&amp;nbsp&quot;</span> + snum + <span class="hljs-string">&quot;&amp;nbspsec&quot;</span>;</span><br><span class="language-javascript">  &#125;  <span class="hljs-comment">//此次自定义显示内容</span></span><br><span class="language-javascript">  <span class="hljs-built_in">setInterval</span>(<span class="hljs-string">&quot;createtime()&quot;</span>,<span class="hljs-number">250</span>);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在标注处修改你自己的建站时间，同时自定义显示内容。例如笔者自定义的内容就是 “🚀 for 55 days 18 hr 09 min 37 sec”。</p></li><li><p>（可选）修改字体样式和大小：<img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200826181808.png" alt="Snipaste_2020-08-26_18-17-54"></p></li><li><p>修改页脚信息，只需将 <code>footer.ejs</code> 中对应位置改为你想显示的内容即可。例如笔者的代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center py-1&quot;</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Copyright © 2020<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://erenspace.cool/&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;nofollow noopener&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Eren‘s Spaceship<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>实现效果：</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200826181457.png" alt="Snipaste_2020-08-26_18-14-44"></p><h2 id="关于页添加评论"><a href="#关于页添加评论" class="headerlink" title="关于页添加评论"></a>关于页添加评论</h2><div class="note note-primary">            <p>目的：在关于页添加评论功能，以实现更好的博客互动。</p><p>本文以 Valine 评论系统作为示范。</p>          </div><p><strong>步骤</strong></p><ol><li><p>打开之前自行创建的关于页 <code>.md</code> 文件：<img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200826184334.png" alt="Snipaste_2020-08-26_18-43-02"></p></li><li><p>在你想要的位置添加 Valine 评论系统的代码。你可在别处 CCS 文件找到你对应的 Valine 评论系统代码，也可以直接复制以下代码（复制用纯文本，这样才是 HTML 代码，否则系统会以为是文章内容代码）。<strong>注意将 app_id 和 app_key 换成你自己的。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;vcomments&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadValine</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">     <span class="hljs-title function_">addScript</span>(<span class="hljs-string">&#x27;https://cdn.staticfile.org/valine/1.4.14/Valine.min.js&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Valine</span>(&#123;</span><br><span class="language-javascript">         <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#vcomments&quot;</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">app_id</span>: <span class="hljs-string">&quot;填写在 Leancloud 中的数据&quot;</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">app_key</span>: <span class="hljs-string">&quot;填写在 Leancloud 中的数据&quot;</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">placeholder</span>: <span class="hljs-string">&quot;留下点什么叭... ᶘ ᵒᴥᵒᶅ（自行修改）&quot;</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">path</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">avatar</span>: <span class="hljs-string">&quot;monsterid&quot;</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">meta</span>: [<span class="hljs-string">&quot;nick&quot;</span>,<span class="hljs-string">&quot;mail&quot;</span>,<span class="hljs-string">&quot;link&quot;</span>],</span><br><span class="language-javascript">         <span class="hljs-attr">pageSize</span>: <span class="hljs-string">&quot;10&quot;</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">lang</span>: <span class="hljs-string">&quot;zh-CN&quot;</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">highlight</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">recordIP</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">         <span class="hljs-attr">serverURLs</span>: <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="language-javascript">       &#125;);</span><br><span class="language-javascript">     &#125;);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">   <span class="hljs-title function_">createObserver</span>(loadValine, <span class="hljs-string">&#x27;vcomments&#x27;</span>);</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>Please enable JavaScript to view the <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://valine.js.org&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;nofollow noopener noopener&quot;</span>&gt;</span>comments<br>     powered by Valine.<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实现效果参考：<a href="https://erenship.com/about/">https://erenship.com/about/</a></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><div class="note note-danger">            <p>由于在使用覆盖方式升级 Fluid 主题到 1.8.3 后关于页评论板块消失。更新添加评论方法。</p>          </div> <p>打开 <code>\themes\fluid\layout</code> 文件下的 <code>about.ejs</code> 文件，在文件末尾添加以下评论代码即可。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xquery">&lt;% <span class="hljs-keyword">if</span>(theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;vcomments&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadValine</span>(<span class="hljs-params"></span>) </span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery">      addScript(<span class="hljs-string">&#x27;&lt;%= url_join(theme.static_prefix.valine, &#x27;</span>Valine<span class="hljs-built_in">.min</span>.js<span class="hljs-string">&#x27;) %&gt;&#x27;</span>, <span class="hljs-keyword">function</span> () &#123;</span><br><span class="language-xquery">        new Valine(&#123;</span><br><span class="language-xquery">          el: <span class="hljs-string">&quot;#vcomments&quot;</span>,</span><br><span class="language-xquery">          app_id: <span class="hljs-string">&quot;&lt;%= theme.valine.appid %&gt;&quot;</span>,</span><br><span class="language-xquery">          app_key: <span class="hljs-string">&quot;&lt;%= theme.valine.appkey %&gt;&quot;</span>,</span><br><span class="language-xquery">          placeholder: <span class="hljs-string">&quot;&lt;%= theme.valine.placeholder %&gt;&quot;</span>,</span><br><span class="language-xquery">         <span class="hljs-built_in"> path</span>: &lt;%= theme.valine<span class="hljs-built_in">.path</span> %&gt;,</span><br><span class="language-xquery">          avatar: <span class="hljs-string">&quot;&lt;%= theme.valine.avatar %&gt;&quot;</span>,</span><br><span class="language-xquery">          meta: &lt;<span class="hljs-meta">%-</span> JSON.stringify(theme.valine.meta || []) %&gt;,</span><br><span class="language-xquery">          pageSize: <span class="hljs-string">&quot;&lt;%= theme.valine.pageSize %&gt;&quot;</span>,</span><br><span class="language-xquery">         <span class="hljs-built_in"> lang</span>: <span class="hljs-string">&quot;&lt;%= theme.valine.lang %&gt;&quot;</span>,</span><br><span class="language-xquery">          highlight: &lt;%= theme.valine.highlight %&gt;,</span><br><span class="language-xquery">          recordIP: &lt;%= theme.valine.recordIP %&gt;,</span><br><span class="language-xquery">          serverURLs: <span class="hljs-string">&quot;&lt;%= theme.valine.serverURLs %&gt;&quot;</span>,</span><br><span class="language-xquery">        &#125;</span><span class="language-xml"><span class="language-javascript">);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">waitElementVisible</span>(<span class="hljs-string">&#x27;vcomments&#x27;</span>, loadValine);</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>Please enable JavaScript to view the </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://valine.js.org&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;nofollow noopener&quot;</span>&gt;</span>comments</span><br><span class="language-xml">      powered by Valine.<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span></span><br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h2><div class="note note-primary">            <p>目的：在网站中引入自定义字体；</p><p>本教程以引入思源宋体为例。</p>          </div><div class="note note-danger">            <p>如需引入本地字体，可使用 <a href="http://font-spider.org/">字蛛（font-spider）</a> 对字体文件进行压缩，但由于未知原因笔者使用字蛛压缩失败。故而使用在线托管字体网址进行字体引用。</p>          </div> <p>字体，作为影响网页美观的重要因素。我们常常需要个性化字体来突显网站的风格。但由于中文字体不同于英文字体只需覆盖 26 个字母 ，中文字体包由于包含大量中文字库，其文件大小通常有几兆甚至十几兆。这给网页浏览来带极大的流量负担，拖慢加载速度，影响用户体验。</p><p>在 <a href="https://hexo.fluid-dev.com/docs/guide/#%E5%85%A8%E5%B1%80%E5%AD%97%E4%BD%93">Fluid 官方文档</a> 中也建议使用系统自带字体。</p><blockquote><p>需要注意：</p><ul><li>最好使用系统自带的字体，否则需要通过<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%87%AA%E5%AE%9A%E4%B9%89-js-css-html">自定义功能</a>额外引入 <code>@font-face</code>，字体一般较大，不建议引入；</li><li>应当至少添加一个通用的字体族名（如 serif，具体见上方链接文章）。</li></ul></blockquote><p>但是，这怎么能止住我们追求美的脚步呢？</p><h3 id="引入字体"><a href="#引入字体" class="headerlink" title="引入字体"></a>引入字体</h3><p>2018 年在 Google Fonts 上已经托管了思源宋体，所以我们可以直接通过托管引入到我们的博客中。打开 <a href="https://fonts.google.com/">Google Fonts</a>，搜索思源宋体的英文名：<code>Noto Serif SC</code>，在列表中选择我们个人觉得合适的字体样式，点击右侧的 <code>Select this style</code>，注意此处可根据自己需要选择多个样式。关于字体引用概念和前期准备工作请参考以下教程，在 <strong>本地设置</strong> 中会针对 Fluid 主题的自定义操作进行讲解。</p><div class="note note-success">            <p>参考教程：<a href="https://bestzuo.cn/posts/notoserifsc.html">https://bestzuo.cn/posts/notoserifsc.html</a></p>          </div><h3 id="本地设置"><a href="#本地设置" class="headerlink" title="本地设置"></a>本地设置</h3><ol><li><p>在按照上述教程将 <Link> 代码复制好之后，打开 <code>\themes\fluid\layout\_partial</code> 目录下的 <code>head.ejs</code> 文件，将引入链接添加进文档中。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200905103fff918.png" alt="Snipaste_2020-09-05_10-37-29"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/2020090510kk4055.png" alt="Snipaste_2020-09-05_10-40-47"></p></li><li><p>将字体英文名称添加到 <code>\themes\fluid\source\css\variables\</code> 目录下的 <code>base.styl</code> 文件中，具体位置为 <code>font-family:</code> 。例如笔者引入的字体位思源宋体，其英文名称为 “Noto Serif SC”。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200826200147.png" alt="Snipaste_2020-08-26_20-01-37"></p></li></ol><p>至此，我们就完成了自定义字体引入。你可以执行部署命令来检查是否成功引入。</p><h2 id="评论样式美化"><a href="#评论样式美化" class="headerlink" title="评论样式美化"></a>评论样式美化</h2><div class="note note-primary">            <p>目的：展现评论者身份标识</p>          </div><p>由于当前版本的 Valine 不能实现评论者身份标识的功能，所以我们需要使用魔改版的 Valine。</p><ul><li><p>打开 <code>\themes\fluid\layout\_partial\comments</code> 中的  <code>valine.ejs</code>  文件，替换红标处内容为<code>https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js</code> </p></li><li><p>新增以下内容。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">master:</span> <span class="hljs-string">&quot;&lt;%= theme.valine.master%&gt;&quot;</span>,<br><span class="hljs-symbol">friends:</span> <span class="hljs-string">&quot;&lt;%= theme.valine.friends%&gt;&quot;</span>,<br><span class="hljs-symbol">tagMeta:</span> [<span class="hljs-string">&quot;博主&quot;</span>,<span class="hljs-string">&quot;友人&quot;</span>,<span class="hljs-string">&quot;访客&quot;</span>],<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926161913.png" alt="Snipaste_2020-09-26_16-10-32"></p><ul><li>打开主题配置文件 <code>\MyBlog\source\_data</code> 在 valine 评论系统处新增</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">master:</span> b20c2cxxxxd422dc29ec7a5a3bd66f2ad <span class="hljs-meta"># 你邮箱的md5加密(百度md5在线加密)</span><br><span class="hljs-symbol">friends:</span> a9126a74dxxxx638def0b16025,<span class="hljs-number">0173939</span>xxxxx32a8cffc288b046dc <span class="hljs-meta"># 好友邮箱的md5加密</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/20200926161840.png" alt="Snipaste_2020-09-26_16-15-02"></p><ul><li><code>hexo s</code> , <code>hexo g -d</code>  重新部署便能看到效果。</li><li>若想在关于页也实现这样的效果，则对应地在<code>about.ejs</code> 里更新相关代码。</li></ul><p>​    效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo//img/202009261dd62549.png" alt="Snipaste_2020-09-26_16-21-34"></p><p>​                          </p><div class="note note-danger">            <p>生命在于折腾。</p>          </div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hexo.fluid-dev.com/docs/guide/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B">Fluid配置文档</a></li><li><a href="https://github.com/qixa/hexo-theme-fluid-mod">Hexo Fluid 主题 UI 修改版</a></li><li><a href="https://largesse.12306.recipes/posts/3c2a5351.html">Hexo Fluid主题 添加自定义字体</a></li><li><a href="https://bestzuo.cn/posts/notoserifsc.html#%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93">博客网站字体设置：思源宋体</a></li><li><a href="https://bestzuo.cn/posts/763113948.html">博客Valine评论样式美化</a></li><li><a href="https://lovelijunyi.gitee.io/posts/e52c.html">Valine评论系统详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于房事的一些思考</title>
    <link href="/posts/e005.html"/>
    <url>/posts/e005.html</url>
    
    <content type="html"><![CDATA[<p>最近家里在谈论买房的事情，这当然不是一件小事, 所以觉得自己有必要花时间去研究一下。</p><blockquote><p>由于笔者并不是房地产和金融相关从业者，在此只是将各渠道获得信息进行梳理，并总结出个人粗略的看法，仅从参考。</p></blockquote><h2 id="宏观数据"><a href="#宏观数据" class="headerlink" title="宏观数据"></a>宏观数据</h2><ol><li><p><strong>国内的经济形势不允许</strong></p><p>中国的经济已经过了靠人口和经济全球化红利高速发展的时代。当初房价猛涨的同时居民的收入也在不断增加，但现如今国内经济陷入低迷，大量企业破产，居民收入在短时间内很难有大幅度提升。同时高层也不断强调内循环的概念，已经说明国际环境恶化程度的严重性, 将很难再通过贸易顺差获得大量利好。 </p></li><li><p><strong>城镇居民的高杠杆率</strong></p><p>2019 年城镇居民杠杆率达 <strong>60.4％</strong>，其中 <strong>75%</strong> 为房贷。在房产的流动性较差的属性之下，一旦遭遇失业潮或者家庭变故，其抗风险能力将变得极差。这是极大的社会性风险。</p></li><li><p><strong>未来需求量将减少</strong></p><p>00 后人口比 90 后人口少 <strong>4700 万</strong>。00 后的父母基本是 80 后，80 后又属于正巧赶上房市的红利期，所以 00 后的父母每一方只少会有两套房(加上爷爷辈)。加之 4700 万的人口缺口，所以可以推测当 00 后考虑买房时，其购房需求和压力将明显小于 90 后。此外，人均住房面积已从几十年前的 5 平方米增至目前的 37 平方米，需求量早已满足实际要求。(但这是全国的数据,具体到一二线仍要实际分析)</p></li></ol><p>综上，无论从政治和民生的角度来分析，上层意愿一定是不愿意看到房价继续暴涨。因为如果 gov 想继续让房价上涨, 而基于居民收入增长缓慢，实体经济低迷的背景，只能通过大量超发货币来维持。而如果想让物品的价值与价格完全不匹配，就只有通过超发货币来实现账面上的高价格。但这将引起通货膨胀，人民币购买力下降，这将是引起政权不稳定的重要因素。但不可忽略的一点是地方政府土地财政的特性，作为地方政府当然是希望在不引起中央注意的情况下地价拍的越高越好，因为这给早已入不敷出的地方财政带来可观的财政收入。</p><p>但由于我国经济地区发展的不平衡，一二线与三四线之间的房价不可相提并论，所以接下来我以二线城市成都为例，谈谈对成都房价的看法。</p><h2 id="成都数据"><a href="#成都数据" class="headerlink" title="成都数据"></a>成都数据</h2><ol><li><p><strong>高净流入人口</strong></p><p>人口净流入量是观察城市房价是否坚挺有力的重要指标。 成都 2018 年人口净流入为 <strong>23 万</strong>, 2019 年为 <strong>49 万</strong>。其中 <strong>73%</strong> 的流入人口为省内周边城市。作为西南地区的省会城市，其经济实力和发展前景远强于其他周边县市，并且由于人才落户的新政，使得近几年流入人口成明显增加态势。比外，城市的虹吸效应增强，成都不可避免地将形成大都市圈。如此之多的人口流入, 必将带来大量的购房刚需。</p></li><li><p><strong>租金回报率和房价收入比</strong></p><p>根据今年的数据，成都的租金回报率为 **2.4%**，一般租金回报比在 5% 左右说明该房有较大投资价值。成都的房价收入比为 <strong>10.3</strong>，世界银行提出发达国家正常的房价收入比一般在 1.8-1.5 之间，而发展中国家合理的房价收入比则在 3~6 之间，比值越大，说明居民家庭对住房的支付能力越低。虽然在数据与正常范围相差较远，但由于中国情况的特殊性，此时类比于同段位的二线城市就显得很有必要了。但无论是租金回报率和房价收入比，都和其他强二线城市存在差距，如杭州、南京等，所以笔者认为成都房价仍有一定上升空间。</p></li><li><p><strong>高二手房存量</strong></p><p>由于新房房价收限购等因素，其价格往往不能反映实际的市场价格，所以二手行情是很好的判断房市的标准。根据链家网数据，成都 2020 年第二季度的二手房存量为 <strong>13 万套</strong>，和全国二手房存量最高的重庆基本齐平。并且这其中有 75% 的房源产权没有满 2 年，也就是交房未满两年的小区或者两年内发生过产权交易。再从 17 年成都限购政策（成都市住房限购区域内新购买的住房（含商品住房和二手住房），须取得不动产权证满 3 年后方可转让）出台以来看，2022 年恐将有一批炒房客对房屋进行抛售。因为刚好是两年后交房+三年不动产权证的时间节点。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，基于成都城市定位以及其他因素，笔者认为成都房价依旧会稳步上涨，预估近五年涨幅应该会被控制在 50% 以内，在整体房价不会达到南京、杭州等强二线城市的水平。</p><p>对于购房抵御通胀的观点，笔者也不为赞同。首先买房子实质上就看空人名币，但在房价不会大幅度上涨且极有可能征收房产空置税的情况下，其抵御通胀的属性已经被削弱。对于普通工薪阶层家庭来说，在大城市购房极有可能掏空六个钱包，并背上沉重的负债，这势必会降低生活质和丧失机会成本。此外，房产作为流动属性极差的资产来说，很难快速变现，使得整个家庭低于风险的能力下降。</p><p>在此引用一句话表达我的观点：</p><blockquote><p> “与大多数人做相同的选择，虽然风险更小，但也永远没有办法赚取超额财富。房地产就是一个击鼓传花的游戏，用脚趾头都能稳赚不赔的买卖，是令人心惊肉跳。”</p></blockquote><p>房地产已经不能作为一个很好的投资产品了。在满足刚需的情况下，兴许可以将资产配置到泰国 or 换成美刀（毕竟数字货币的概念已经开始试点了，以后资本外逃会越来越困难），考虑以后移居泰国养老，或者 xxx。</p>]]></content>
    
    
    <categories>
      
      <category>生活派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CS50 | pset 2</title>
    <link href="/posts/bea6.html"/>
    <url>/posts/bea6.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文仅记录笔者在 CS50 Problem Set 2 (Fall 2020) 中的解题思路和过程。如有错误或疏漏欢迎留言指正！</p>          </div><h2 id="Readability"><a href="#Readability" class="headerlink" title="Readability"></a>Readability</h2><p>设计一个程序，计算理解某些文本所需的大致等级，如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">$ ./readability<br>Text: Congratulations! Today <span class="hljs-keyword">is</span> your day. Yo<span class="hljs-string">u&#x27;re off to Great Places! You&#x27;</span>re off <span class="hljs-keyword">and</span> away!<br>Grade <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>根据 <a href="https://www.scholastic.com/teachers/teaching-tools/collections/guided-reading-book-lists-for-every-level.html">Scholastic </a>的说法，<a href="https://www.scholastic.com/teachers/teaching-tools/collections/guided-reading-book-lists-for-every-level.html">艾伯特·怀特</a>（EB White）的“夏洛特之网”介于二年级和四年级之间，而洛依·劳瑞（Lois Lowry）的“赐予者”介于八年级和十二年级之间。但是，一本书达到“四年级阅读水平”是什么意思？</p><p>好吧，在许多情况下，人类专家可能会读一本书，并决定他们认为该书最适合的等级。但是您也可以想象有一种算法试图弄清楚什么是文本阅读水平。</p><p>那么，较高的阅读水平具有哪些特征呢？好吧，更长的单词可能与更高的阅读水平相关。同样，较长的句子也可能与较高的阅读水平相关。多年来，已经开发了许多“可读性测试”，以提供一种公式化的过程来计算文本的阅读水平。</p><p>文本的阅读等级由 Coleman-Liau 索引来判断。其公式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">index</span> = <span class="hljs-number">0</span>.<span class="hljs-number">0588</span> * L - <span class="hljs-number">0</span>.<span class="hljs-number">296</span> * S - <span class="hljs-number">15</span>.<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>此处，<code>L</code> 是文本中每100个单词的平均字母数，也是文本中每100个单词 <code>S</code> 的平均句子数。</p><h3 id="Puprose"><a href="#Puprose" class="headerlink" title="Puprose"></a>Puprose</h3><p>设计并实现一个程序，该程序 <code>readability</code> 可计算文本的Coleman-Liau 索引。</p><ul><li>在一个名为文件实现程序 <code>readability.c</code> 的<code>~/pset2/readability</code> 目录。</li><li>您的程序必须提示用户输入 <code>string</code> 文字（使用<code>get_string</code>）。</li><li>您的程序应计算文本中字母，单词和句子的数量。你可以假设一个字母是任何小写字符 <code>a </code>来 <code>z</code> 或从任何大写字符 <code>A</code> 到 <code>Z</code>，任何字符序列分离用空格应该算作一个字，并经过一段时间的任何事件，感叹号或问号表示结束一句话。</li><li>您的程序应打印为输出 <code>&quot;Grade X&quot;</code>，其中 <code>X</code> 是由 Coleman-Liau 公式计算的等级级别，四舍五入到最接近的整数。</li><li>如果得到的索引号是16或更高（等于或大于高年级本科生的阅读水平），则程序应输出 <code>&quot;Grade 16+&quot;</code> 而不是给出确切的索引号。如果索引号小于1，则程序应输出 <code>&quot;Before Grade 1&quot;</code>。</li></ul><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><ul><li>让用户输入一串文本。</li><li>计算字母（letters）数量，计算方法为：判断所输入字符串的范围是否在 ‘a’ ~ ‘z’ 或者 ‘A’ ~ ‘Z’ 中。计算在范围内的所有字母数量。</li><li>计算单词（words）数量，计算方法为：判断字符串的值为 <code>空格</code> 时则记为一个单词，单词数+1。等于是计算文本中有多少个空格（默认文本中只会出现一个空格的情况），就求出有多少个单词数。</li><li>计算句子（sentences）的数量，计算方法为：判断字符串的值为 <code>!</code> , <code>.</code> 或 <code>?</code> 时则记作一个句子。</li><li>将上述结果带入 index 的公式中求的阅读等级。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822113122.png" alt="Snipaste_2020-08-21_12-47-37"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822113124.png" alt="Snipaste_2020-08-21_12-48-11"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822150.png" alt="Snipaste_2020-08-21_12-48-54"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822113123.png"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/2020082251.png" alt="Snipaste_2020-08-21_12-49-08"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">*   This is a simple C program that computes the        *</span><br><span class="hljs-comment">*   approximate grade level needed to comprehend        *</span><br><span class="hljs-comment">*   some text.                                          *</span><br><span class="hljs-comment">*                                                       *</span><br><span class="hljs-comment">*   Eren Lu                                             *</span><br><span class="hljs-comment">*   Fall 2020 CS50  pSet2 Readability                   *</span><br><span class="hljs-comment">*********************************************************/</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cs50.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> letterscount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> wordscount = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sentscount = <span class="hljs-number">0</span>;<br>    string text = <span class="hljs-built_in">get_string</span>(<span class="hljs-string">&quot;Text: &quot;</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(text); i++)<br>    <br>        <span class="hljs-comment">//要用单引号，不要用双引号！，是把字符括起来</span><br>        <span class="hljs-keyword">if</span>((text[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; text[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) || (text[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; text[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>))<br>        &#123;<br>            letterscount++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(text[i] == <span class="hljs-string">&#x27; &#x27;</span>)<br>        &#123;<br>            wordscount++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(text[i] == <span class="hljs-string">&#x27;.&#x27;</span> || text[i] == <span class="hljs-string">&#x27;!&#x27;</span> || text[i] == <span class="hljs-string">&#x27;?&#x27;</span>)<br>        &#123;<br>            sentscount++;<br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d letter(s);\n%d word(s);\n%d sentence(s);\n&quot;</span>, letterscount, wordscount, sentscount);<br>    <br>    <span class="hljs-comment">//letterscount 等要用 float 强制转换,不然会计算错误</span><br>    <span class="hljs-type">float</span> L = ((<span class="hljs-type">float</span>)letterscount / (<span class="hljs-type">float</span>)wordscount) * <span class="hljs-number">100</span>, S = ((<span class="hljs-type">float</span>)sentscount / (<span class="hljs-type">float</span>)wordscount) * <span class="hljs-number">100</span>;<br>    <span class="hljs-type">float</span> grade = <span class="hljs-number">0.0588</span> * L - <span class="hljs-number">0.296</span> * S <span class="hljs-number">-15.8</span>;<br><br>    <span class="hljs-keyword">if</span>(grade &lt;= <span class="hljs-number">16</span> &amp;&amp; grade &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Grade %i\n&quot;</span>, (<span class="hljs-type">int</span>) <span class="hljs-built_in">round</span>(grade));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grade &gt; <span class="hljs-number">16</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Grade 16+\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grade &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before Grade 1\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li>要对数组的概念有一定的认识。把数组想成一串箱子，每个箱子里面放了对应的一个字符。</li><li>在使用 ASCII 码进行比较时使用 ‘a’ 单引号。</li><li>在类型不同的变量进行计算式应该使用强制类型转换。否则导致虽然编译不会报错，但最后的计算结果会出错。</li></ul><h2 id="Caesar"><a href="#Caesar" class="headerlink" title="Caesar"></a>Caesar</h2><p>根据以下内容，实现一个使用 Caesar 密码对消息进行加密的程序。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ ./caesar <span class="hljs-number">13</span><br><span class="hljs-symbol">plaintext:</span>  HELLO<br><span class="hljs-symbol">ciphertext:</span> URYYB<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822122019.png" alt="Snipaste_2020-08-21_19-09-57"></p><p>Caesar的算法（即密码）通过将每个字母 “旋转”  <em>k</em> 个位置来加密消息。更正式地，如果 <em>pi</em> 是一些明文（即，未加密的消息），那么每个字母 <em>ci</em> 在密文中计算为：</p><p><em><strong>ci &#x3D; (pi + k) % 26</strong></em></p><p>其中的 <code>% 26</code> 意思是“除以26时的余数”。这个公式可能使密码看起来比实际更复杂，但这实际上只是精确表达算法的一种简洁方法。实际上，为了讨论起见，将A（或a）视为0，将B（或b）视为1，…，将H（或h）视为7，将I（或i）视为8，…，以及Z（或z）的值为25。</p><h3 id="Puprose-1"><a href="#Puprose-1" class="headerlink" title="Puprose"></a>Puprose</h3><p>设计并实现一个程序，该程序 <code>caesar</code> 使用 Caesar 的密码对消息进行加密。</p><ul><li>在一个名为文件实现程序 <code>caesar.c</code>的 <code>~/pset2/caesar</code> 目录。</li><li>您的程序必须接受一个命令行参数，一个非负整数。为了讨论起见，我们将其称为 <em>k</em>。</li><li>如果您的程序在执行时没有任何命令行参数或带有多个命令行参数，则您的程序应打印您选择的错误消息（带有 <code>printf</code>），并立即从 <code>main</code> 值 <code>1</code>（通常表示错误）返回。</li><li>如果命令行参数的任何字符都不是十进制数字，则程序应打印该消息 <code>Usage: ./caesar key</code> 并从 <code>main</code> 值返回 <code>1</code>。</li><li>您的程序必须输出 <code>plaintext:</code>（没有换行符），然后提示用户输入 <code>string</code> 纯文本（使用<code>get_string</code>）。</li><li>您的程序必须输出 <code>ciphertext:</code>（没有换行符），再输出明文的相应密文，明文中的每个字母字符都“旋转”了<em>k个</em>位置；非字母字符应原样输出。</li><li>您的程序必须保留大小写：大写字母尽管可以旋转，但必须保持大写字母；小写字母尽管旋转，但必须保持小写字母。</li><li>输出密文后，应打印换行符。然后，您的程序应通过 <code>0</code> 从返回，退出 <code>main</code>。</li></ul><h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method"></a>Method</h3><ul><li>获取密钥</li><li>判断是否是有效的密钥；</li><li>用户输入明文</li><li>进行加密</li><li>输出密文</li></ul><p>伪代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822132445.png" alt="Snipaste_2020-08-21_19-16-13"></p><p><strong>argc &amp; argv</strong></p><p>argc: argument count </p><p>argv: argument vector</p><p>两者用于接受参数和记录参数信息。</p><p>我们经常用的 main 函数都是不带参数的。因此 main 后的括号都是空括号。实际上，main 函数可以带参数，这个参数可以认为是 main 函数的形式参数。Ｃ语言规定 main 函数的参数只能有两个，习惯上这两个参数写为 argc和 argv。因此，main 函数的函数头可写为： main (argc,argv)。Ｃ语言还规定 argc (第一个形参) 必须是整型变量, argv ( 第二个形参) 必须是指向字符串的指针数组。</p><p>由于 main 函数不能被其它函数调用，因此不可能在程序内部取得实际值。那么，在何处把实参值赋予 main 函数的形参呢? 实际上,main 函数的参数值是从操作系统命令行上获得的。当我们要运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数即可把这些实参传送到main的形参中去。 DOS提示符下命令行的一般形式为： C:&#x2F;&gt;可执行文件名 参数 参数……</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822132741.png" alt="Snipaste_2020-08-21_19-10-49"></p><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/202008221349876785646.png" alt="Snipaste_2020-08-21_19-12-08"></p><p>在本题中 main 里面的两个参数满足以下条件：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822133532.png" alt="Snipaste_2020-08-21_19-11-40"></p><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822133632.png" alt="Snipaste_2020-08-21_18-12-45"></p><p><strong>Key</strong></p><p>对输入的密钥进行检查，查看是否满足条件，否则输出相应提示。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822133956.png" alt="Snipaste_2020-08-21_23-04-58"></p><p><strong>Encipher</strong></p><ul><li><p>符合密钥条件之后，对明文进行加密；</p></li><li><p>只对大小写字母进行转换，不对其他符合或者数字进行转换；</p></li><li><p>其中用到了 <code>isupper</code> 和 <code>islower</code> 函数，对数组中的大写和小写字母进行判断并转换。</p></li><li><p>使用 <code>atoi</code> 函数对 <code>argv[1]</code> 中的数取整。</p><p><code>atoi()</code> 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时(‘\0’)才结束转换，并将结果返回。【返回值】返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822134309.png" alt="Snipaste_2020-08-21_23-05-18"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822134124.png" alt="Snipaste_2020-08-21_18-31-30"></p><p>先将 ASCII 码转化为字母表的顺序：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/202008221927524.png" alt="Snipaste_2020-08-21_19-26-18"></p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822134551.png" alt="Snipaste_2020-08-21_19-19-20"></p><p>再使用密文计算公式求出密文对应的字母表值，最后再加上 ASCII 码对应值转换为 ASCII 码的密文。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200822134610.png" alt="Snipaste_2020-08-21_19-19-37"></p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/***********************************************************</span><br><span class="hljs-comment">*   This is a simple C program that encrypts messages      *</span><br><span class="hljs-comment">*   using Caesar’s cipher. Your program must accept a      *</span><br><span class="hljs-comment">*   single command-line argument: a non-negative integer.  * </span><br><span class="hljs-comment">*   Let’s call it k for the sake of discussion. If your    * </span><br><span class="hljs-comment">*   program is executed without any command-line arguments * </span><br><span class="hljs-comment">*   or with more than one command-line argument, your      *</span><br><span class="hljs-comment">*   program should yell at the user and return a value of  *</span><br><span class="hljs-comment">*   1.                                                     *</span><br><span class="hljs-comment">*                                                          *</span><br><span class="hljs-comment">*   Eren Lu                                                *</span><br><span class="hljs-comment">*   Fall 2020 CS50  pSet2 Caesar                           *</span><br><span class="hljs-comment">***********************************************************/</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cs50.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><span class="hljs-comment">//argc: argument count; argv: argument vector。两者用于接受参数和记录参数信息。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, string argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: ./caesar key\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>；<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> k = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-keyword">if</span>(k &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: ./caesar key\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        string text = <span class="hljs-built_in">get_string</span>(<span class="hljs-string">&quot;plain text: &quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ciphertext: &quot;</span>);<br>        <span class="hljs-type">int</span> i;<br>        <br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(text); i++)<br>        &#123;<br>          <br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isupper</span>(text[i]))<br>            &#123;<br>                <span class="hljs-comment">//加密公式 c = （p + k）% 26</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, (text[i] - <span class="hljs-number">65</span> + k) % <span class="hljs-number">26</span> + <span class="hljs-number">65</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">islower</span>(text[i]))<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, (text[i] - <span class="hljs-number">97</span> + k) % <span class="hljs-number">26</span> + <span class="hljs-number">97</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, text[i]);<br>            &#125;<br>            <br>        &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><ul><li>了解到 <code>main</code> 函数也是可以带参数的形式，一般都为 <code>main（argc, argv[]）</code>的参数形式。</li><li>学习了<code>isupper</code> <code>islower</code> <code>atoi</code> 三个函数的使用。</li><li>对 ASCII 码有了进一步的理解。</li></ul><h2 id="Substitution-To-be-continued"><a href="#Substitution-To-be-continued" class="headerlink" title="Substitution (To be continued)"></a>Substitution (To be continued)</h2><p>根据以下内容，实现一个实现替代密码的程序。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ ./substitution JTREKYAVOGDXPSNCUIZLFBMWHQ<br><span class="hljs-symbol">plaintext:</span>  HELLO<br><span class="hljs-symbol">ciphertext:</span> VKXXN<br></code></pre></td></tr></table></figure><p>在替换密码中，我们通过将每个字母替换为另一个字母来“加密”（即，以可逆方式隐藏）一条消息。为此，我们使用一个<em>密钥</em>：在这种情况下，加密时，字母表中每个字母到它应该对应的字母的映射。要“解密”消息，消息的接收者需要知道密钥，以便他们可以逆转该过程：将加密文本（通常称为<em>ciphertext</em>）转换回原始消息（通常称为<em>明文</em>）。</p><p>例如，键可能是字符串 <code>NQXPOMAFTRHLZGECYJIUWSKDVB</code>。此26个字符的键表示 <code>A</code>（字母的第一个字母）应转换为 <code>N</code>（键的第一个字符），<code>B</code>（字母的第二个字母）应转换为 <code>Q</code>（键的第二个字符），并且等等。</p><p><code>HELLO</code> 然后，像这样的消息将被加密为 <code>FOLLE</code>，根据由密钥确定的映射替换每个字母。</p><h3 id="Puprose-2"><a href="#Puprose-2" class="headerlink" title="Puprose"></a>Puprose</h3><p>设计并实现一个程序，该程序 <code>substitution</code> 使用替换密码对消息进行加密。</p><ul><li>在一个名为文件实现程序 <code>substitution.c</code> 的 <code>~/pset2/substitution</code> 目录。</li><li>您的程序必须接受一个命令行参数，即用于替换的键。<strong>键本身应该不区分大小写，因此键中的任何字符都是大写还是小写都不会影响程序的行为</strong>。</li><li>如果您的程序在执行时没有任何命令行参数或带有多个命令行参数，则您的程序应打印您选择的错误消息（带有 <code>printf</code>），并立即从 <code>main</code> 值 <code>1</code>（通常表示错误）返回。</li><li>如果键无效（例如，不包含26个字符，包含不是字母字符的任何字符或不完全包含每个字母一次），则程序应打印您选择的错误消息（带有 <code>printf</code>）并从 <code>main</code> 值返回的<code>1</code>马上。</li><li>您的程序必须输出 <code>plaintext:</code>（没有换行符），然后提示用户输入 <code>string</code> 纯文本（使用 <code>get_string</code>）。</li><li>您的程序必须输出 <code>ciphertext:</code>（没有换行符），后跟明文的相应密文，并用明文中的每个字母字符替换密文中的相应字符；非字母字符应原样输出。</li><li><strong>您的程序必须保留大小写：大写字母必须保持为大写字母；小写字母必须保留为小写字母。</strong></li><li>输出密文后，应打印换行符。然后，您的程序应通过 <code>0</code> 从返回，退出 <code>main</code> 。</li></ul><h3 id="Method-2"><a href="#Method-2" class="headerlink" title="Method"></a>Method</h3><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.jianshu.com/p/ab21bfe6a5b2">int main(int argc, const char * argv[])</a></li><li><a href="https://gist.github.com/CraigRodrigues/100ab759b6b6722ba3ad8acf12e26371">My solution to CS50 pset2 - “Hail, Caesar!”</a></li><li><a href="https://gist.github.com/teeschorle/cc998f1ef47e270282d3d4fa3d217d31">CS50 Problem Set 2 (Fall 2019) - Substitution</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CS50 | Week 2 Arrays &amp; Sorts</title>
    <link href="/posts/3291.html"/>
    <url>/posts/3291.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>提示：在此只是将零散的、个人化的知识点记录下来，完整笔记查看官方 <a href="https://cs50.harvard.edu/x/2020/notes/2/">Notes</a> 即可。 </p>          </div> <h2 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h2><ul><li><p>CPU 只懂得低级别的汇编语言</p></li><li><p>C language → assembly language → machine language (zeros and ones)     </p></li><li><p>Compiling 包含以下过程：</p></li><li><p>preprocessing:  预处理，包括查看以 <code>#</code>开头的行，如 <code>#include</code>，然后再看其他所有的行；</p><p>​         ↓ </p></li><li><p>compiling:  将我们用C语言写的源代码转换为汇编代码；</p><p>​         ↓</p></li><li><p>assembling:  将汇编代码转换为二进制的代码（0和1）；</p><p>​         ↓</p></li><li><p>linking: 链接到以前编译的库里面的内容。如： <code>cs50.c</code>。</p></li><li><p>调试（Debugging）是发现和修复错误的过程。</p><p>可以使用一些计数、赋值的 <code>printf</code> 来查验代码的错误，最后再删除即可。也就是说如果存在疑问，就在这行或次行加上 printf，来打印出变量中的字符串就可以查出问题所在。    </p></li><li><p>注意代码的风格和美观。</p></li><li><p>CS50 常用的三个工具：</p><ul><li><code>help50</code>: 用于解释你不理解的报错信息；<code>help50 make buggy</code></li><li><code>printf</code>: 当程序出现bug无法正常运行，用 <code>printf</code> 检查；<code>printf(&quot;i is %i\n&quot;, i)</code></li><li><code>style50</code>: 代码格式检查。<code>style50 make buggy2</code></li></ul></li><li><p>RAM（Radom Access Memory）是比较短暂的，文件和应用放在 RAM 中会更加高效。</p></li><li><p><code>const int COUNT = 3</code>;</p></li><li><p>Encryption:</p><ul><li>明文（plaintext ）+密钥（key，a kind of algorithm）→ 【Black box】 → 密文（ciphertext）</li></ul></li><li><p>关于返回值：当不设置返回值时，main 自动返回 0。当程序变得复杂时，返回值变得非常有用，因为可以查看程序是否有错。e.g. 404 error，system error 29.</p></li></ul><h2 id="数据类型（Data-Types）"><a href="#数据类型（Data-Types）" class="headerlink" title="数据类型（Data Types）"></a>数据类型（Data Types）</h2><p>In C, we have different types of variables we can use for storing data:</p><ul><li>bool 1 byte</li><li>char 1 byte</li><li>int 4 bytes</li><li>float 4 bytes</li><li>long 8 bytes</li><li>double 8 bytes</li><li>string ? bytes</li></ul><h2 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cs50.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Scores</span><br>    <span class="hljs-type">int</span> scores[N];<br>    scores[<span class="hljs-number">0</span>] = <span class="hljs-number">72</span>;<br>    scores[<span class="hljs-number">1</span>] = <span class="hljs-number">73</span>;<br>    scores[<span class="hljs-number">2</span>] = <span class="hljs-number">33</span>;<br><br>    <span class="hljs-comment">// Print average</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Average: %i\n&quot;</span>, (scores[<span class="hljs-number">0</span>] + scores[<span class="hljs-number">1</span>] + scores[<span class="hljs-number">2</span>]) / N);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数组是连续储存的。在内存中，我们的数组现在是这样存储的，其中每个值占用的不是一个而是四个字节：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004016.png" alt="memory_with_array"></p><ul><li><p>你必须把数组长度告诉所有使用他的人，因为它没有 <code>length</code> 的属性。e.g. <code>int socres[N];</code></p></li><li><p>数组像美国高中学校里的大柜子，并且电脑一次只能打开一个柜子来看。</p></li></ul><h2 id="字符串（Strings）"><a href="#字符串（Strings）" class="headerlink" title="字符串（Strings）"></a>字符串（Strings）</h2><ul><li><p>字符串其实只是字符的数组。如果我们有一个字符串s，每个字符都可以用 <code>s[0]</code>、<code>s[1]</code> 来访问，以此类推。</p></li><li><p>而事实证明，一个字符串的结尾有一个特殊的字符，’&#x2F;0’，或者说是一个所有位都设置为0的字节，这个字符被称为空字符，或者说空终止字符。所以我们实际上需要四个字节来存储我们的字符串 “HI！”：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004033.png" alt="memory_with_string"></p><ul><li>现在让我们看看数组中的四个字符串可能是什么样子：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">string</span> names[<span class="hljs-number">4</span>];<br><span class="hljs-attribute">names</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;EMMA&quot;</span>;<br><span class="hljs-attribute">names</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;RODRIGO&quot;</span>;<br><span class="hljs-attribute">names</span>[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;BRIAN&quot;</span>;<br><span class="hljs-attribute">names</span>[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;DAVID&quot;</span>;<br><br><span class="hljs-attribute">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, names[<span class="hljs-number">0</span>]);<br><span class="hljs-attribute">printf</span>(<span class="hljs-string">&quot;%c%c%c%c\n&quot;</span>, names[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], names[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], names[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>], names[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><ul><li>我们可以将 <code>names</code> 中的第一个值打印成一个字符串，或者我们可以得到第一个字符串，并再次使用 <code>[]</code> 得到该字符串中的每一个字符。(我们可以把它看作是 <code>(names[0])[0]</code>，尽管我们不需要括号。)</li><li>虽然我们知道第一个名字有四个字符，但 <code>printf</code> 可能使用了一个循环来查看字符串中的每一个字符，每次打印一个，直到到达标志着字符串结束的空字符。而事实上，我们可以将 <code>names[0][4]</code> 作为 <code>int</code> 与 <code>%i</code> 一起打印，看到的是一个 <code>0</code> 被打印出来。</li><li>我们可以在记忆中直观地看到每个字符都有自己的标签:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004046.png" alt="memory_with_string_array"></p><ul><li><p>比较经典的小写字母变成大写字母的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cs50.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    string s = <span class="hljs-built_in">get_string</span>(<span class="hljs-string">&quot;Before: &quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After:  &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, n = <span class="hljs-built_in">strlen</span>(s); i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>        &#123;<br>        <span class="hljs-comment">//在ASCII码中，小写字母比大写字母大32，a = 97,A = 65</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, s[i] - <span class="hljs-number">32</span>); <br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, s[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以使用 <code>strlen(name)</code> 来得到字符串长度。e.g. strlen(“Erenlu”), 结果就是 6。</p><ul><li>要记得在顶部先引用 <code>#include &lt;string.h&gt;</code> 才能使用</li></ul></li></ul><h2 id="排序（Sort）"><a href="#排序（Sort）" class="headerlink" title="排序（Sort）"></a>排序（Sort）</h2><p>时时刻刻我们都应该问算法是否高效。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004059.png" alt="Snipaste_2020-07-13_16-50-47"></p><h3 id="冒泡排序（Bubble-sort）"><a href="#冒泡排序（Bubble-sort）" class="headerlink" title="冒泡排序（Bubble sort）"></a>冒泡排序（Bubble sort）</h3><ul><li><p>一种比较排序法。两两对比，将更小的交换到左边。每次解决一个小问题，但需要反反复复地去做。</p></li><li><p>伪代码（pseudocode）：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">repeat</span> <span class="hljs-keyword">until</span> no swaps<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">from</span> n-<span class="hljs-number">2</span>  <span class="hljs-comment">//倒数第二个，避免倒数第一个右边没有可比的</span><br><span class="hljs-keyword">if</span> i<span class="hljs-string">&#x27;th and i+1&#x27;</span>th elements <span class="hljs-keyword">out</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">order</span>  <span class="hljs-comment">//判断是否排序混乱</span><br>swap them<br></code></pre></td></tr></table></figure></li></ul><ul><li>假如有 8 个数字，由以下步骤进行排序：<ul><li>第一次：比较 7 次，[0,1] [1,2] [2,3]….[6,7]</li><li>第二次：比较 6 次，，[0,1]….[6,7]，（最后一个已经排序好了)</li><li>….</li><li>第七次：比较1 次，[0,1] （后面六个都排序好了）</li></ul></li><li>优点：最右边已经确定，每次比较都可以少一个。</li></ul><h3 id="选择排序（Selection-sort）"><a href="#选择排序（Selection-sort）" class="headerlink" title="选择排序（Selection sort）"></a>选择排序（Selection sort）</h3><ul><li><p>每一次都选择剩下中数字最小的人，丢到左边去交换，这样每一次排序后就不用管之前的情况。所以剩下的工作会原来越少。</p></li><li><p>伪代码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">For i <span class="hljs-keyword">from</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> n–<span class="hljs-number">1</span><br>    Find smallest <span class="hljs-built_in">item</span> <span class="hljs-keyword">between</span> i&#x27;th <span class="hljs-built_in">item</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">last</span> <span class="hljs-built_in">item</span><br>    Swap smallest <span class="hljs-built_in">item</span> <span class="hljs-keyword">with</span> i&#x27;th <span class="hljs-built_in">item</span><br></code></pre></td></tr></table></figure></li><li><p>进行的次数为: (n - 1) + (n - 2) + … + 1 &#x3D; n(n - 1) &#x2F; 2 &#x3D; n² &#x2F; 2 - n &#x2F; 2</p></li><li><p>假如有 8 个数字，由以下步骤进行排序：</p><ul><li>第一次：找出最小的数字，把 1 交换到最左边<br>第二次：找出剩下最小的数字，把 2 交换到左边<br>…<br>第七次：找出剩下最小的数字，把 7 交换到左边</li></ul></li><li><p>优点：最左边已经确定，每次比较都可以少一个人 缺点：每次都要搜寻一遍最小数，即使一开始顺序就是对的。</p></li></ul><h3 id="归并排序（Merge-sort）"><a href="#归并排序（Merge-sort）" class="headerlink" title="归并排序（Merge sort）"></a>归并排序（Merge sort）</h3><ul><li><p>不断地进行二等分，直到最小单位再开始进行比较，再最后进行合并比较。</p></li><li><p>伪代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">If <span class="hljs-keyword">only</span> <span class="hljs-keyword">one</span> item<br>  <span class="hljs-keyword">Return</span><br><span class="hljs-keyword">Else</span><br>    Sort <span class="hljs-keyword">left</span> half <span class="hljs-keyword">of</span> items<br>    Sort <span class="hljs-keyword">right</span> half <span class="hljs-keyword">of</span> items<br>    <span class="hljs-keyword">Merge</span> sorted halves<br></code></pre></td></tr></table></figure></li><li><p>假如有 8 个数字，由以下步骤进行排序：</p><ul><li><p>先一直二等分成最小数字，再进行合併</p><p>第一次：合併成 4 组 2 个数字<br>第二次：合併成 2 组 4 个数字<br>第三次：合併成 1 组 8 个数字</p></li></ul></li><li><p>优点：移动的次数比泡沫跟选择更有效率，每个数字只移动了 3 次，8 * 3 共 24 次 缺点：需要用到额外记忆体。</p></li></ul><h3 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h3><ul><li><p>由最高次幂决定。</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004124.png" alt="Snipaste_2020-07-14_18-50-49"></p><p>时间复杂度由最差 → 最优</p></li><li><p>由以下这张 gif 可以看出三种排序法明显的差别，以时间复杂度来说，Merge 优于 Bubble 优于 Selection：</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004137.gif" alt="WPxq5w6"></p></li><li><p>同时运行的具有大量输入的排序算法的 <a href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc">最终可视化</a> 视频。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://yakimhsu.com/cs50/CS50_week2.html">【筆記】CS50 - week 2 編譯、陣列、加密、排序法 ( 2019年更新 )</a></li><li><a href="https://medium.com/appworks-school/%E5%88%9D%E5%AD%B8%E8%80%85%E5%AD%B8%E6%BC%94%E7%AE%97%E6%B3%95-%E8%AB%87%E4%BB%80%E9%BA%BC%E6%98%AF%E6%BC%94%E7%AE%97%E6%B3%95%E5%92%8C%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6-b1f6908e4b80">初學者學演算法-談什麼是演算法和時間複雜度</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CS50 | pset 1</title>
    <link href="/posts/b465.html"/>
    <url>/posts/b465.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文仅记录笔者在 CS50 Problem Set 1 (Fall 2020) 中的解题思路和过程。如有错误或疏漏欢迎留言指正！</p>          </div><h1 id="CS50-IDE"><a href="#CS50-IDE" class="headerlink" title="CS50 IDE"></a>CS50 IDE</h1><p>CS50 的课后作业将使用 CS50 IDE 进行完成和提交。</p><p>CS50 IDE 常用命令：</p><ul><li><p>创建新文件夹。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mkdir ~<span class="hljs-regexp">/pset1/</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>eg: 在您的主目录中创建一个目录（即文件夹 pset1）。 <code>~</code> 表示您的home目录，<code>~/pset1</code> 表示一个名为<code>pset1</code> 的目录。</p></li><li><p>将自己移入（即打开）该目录。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">cd ~<span class="hljs-regexp">/pset1/</span><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li><li><p>clang 是一种编译程序，将源代码转换为机器代码。（clang 的操作可由 make xxx 代替）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">clang</span> xxx.cCopy<br></code></pre></td></tr></table></figure></li><li><p>编译代码。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">make xxxCopy</span><br></code></pre></td></tr></table></figure></li><li><p>运行代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./xxxCopy<br></code></pre></td></tr></table></figure></li></ul><h1 id="Mario-More"><a href="#Mario-More" class="headerlink" title="Mario More"></a>Mario More</h1><p>Toward the beginning of World 1-1 in Nintendo’s Super Mario Brothers, Mario must hop over adjacent pyramids of blocks, per the below.</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004352.png" alt="mario"></p><p>Let’s recreate those pyramids in C, albeit in text, using hashes (<code>#</code>) for bricks, a la the below. Each hash is a bit taller than it is wide, so the pyramids themselves are also be taller than they are wide.</p><h2 id="Puprose"><a href="#Puprose" class="headerlink" title="Puprose"></a>Puprose</h2><p>The program we’ll write will be called <code>mario</code>. And let’s allow the user to decide just how tall the pyramids should be by first prompting them for a positive integer between, say, 1 and 8, inclusive.</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">$ ./mario<br>Height: <span class="hljs-number">8</span><br>       #  #<br>      ##  ##<br>     ###  ###<br>    ####  ####<br>   #####  #####<br>  ######  ######<br> #######  #######<br>########  ########Copy<br></code></pre></td></tr></table></figure><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><a href="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004406.png"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004406.png" alt="Snipaste_2020-07-09_23-09-55"></a></p><p>首先是对左边金字塔进行完成，因为右边只需要行数个 #，而左边要对空格和 # 进行处理。</p><p>最后使用判断的方式进行 <strong>i+j&lt;h-1</strong> ，因为刚好在第四行的时候 “空格” 和 “#” 的数量是一个分水岭。其中i是行数，j 是列数，他们都是从 0 开始计数。</p><h2 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">*   This is a simple C program that allows you to       *</span><br><span class="hljs-comment">*   determine just how tall the pyramids should be      *</span><br><span class="hljs-comment">*   by first prompting them for a positive integer      *</span><br><span class="hljs-comment">*   between, say, 1 and 8, inclusive.                   *</span><br><span class="hljs-comment">*                                                       *</span><br><span class="hljs-comment">*   Eren Lu                                             *</span><br><span class="hljs-comment">*   Fall 2020 CS50  pSet1 Mario （more comfortable）     *</span><br><span class="hljs-comment">*********************************************************/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cs50.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> h;<br><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-comment">//告诉用户要输入1-8的整数，否则再次提醒输入</span><br>        h = <span class="hljs-built_in">get_int</span>(<span class="hljs-string">&quot;Please input the height:\n&quot;</span>); <br>    &#125;<br>    <span class="hljs-keyword">while</span>(h&lt;=<span class="hljs-number">0</span>||h&gt;<span class="hljs-number">8</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;h;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;h;j++)<br>        &#123;<br>            <span class="hljs-comment">//直接进行空格和#的判断</span><br>            <span class="hljs-keyword">if</span>(i+j&lt;h<span class="hljs-number">-1</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;#&quot;</span>);<br>            &#125;<br>          <br>        &#125; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  &quot;</span>);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;=i ; k++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;#&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h1 id="Crash"><a href="#Crash" class="headerlink" title="Crash"></a>Crash</h1><p>假设你是一位收营员，你手中只有 25 cent, 10 cent, 5 cent, 1 cent面值的纸币供你进行找零。 在你找零时要依据优先使用能用的最面值进行找零，这样才能使总共找零纸币数量最少，即全局最优解。</p><h2 id="Puprose-1"><a href="#Puprose-1" class="headerlink" title="Puprose"></a>Puprose</h2><p>请设计一个程序，已知应找顾客多少钱，在仅使用以上 4 种面值的纸币的情况下，求出找零多少张纸币的数量。输入为负数或字符时提示再次输入。</p><p>e.g.</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">$ ./cash<br><span class="hljs-built_in">Change</span> owed: -<span class="hljs-number">0.41</span><br><span class="hljs-built_in">Change</span> owed: foo<br><span class="hljs-built_in">Change</span> owed: <span class="hljs-number">0.41</span><br><span class="hljs-number">4</span>Copy<br></code></pre></td></tr></table></figure><h2 id="Method-1"><a href="#Method-1" class="headerlink" title="Method"></a>Method</h2><p><a href="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004424.png"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004424.png" alt="Snipaste_2020-07-10_11-34-13"></a></p><p>需将 9 dollar 先转换为 900 cent。</p><h2 id="The-Code-1"><a href="#The-Code-1" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cs50.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//m 是全局变量，不能在do-while里面去定义：float m = get_float();</span><br>    <span class="hljs-type">float</span> m;<br>    <br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        m = <span class="hljs-built_in">get_float</span>(<span class="hljs-string">&quot;How much do I owe you?\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m&lt;<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-type">int</span> cent = <span class="hljs-built_in">round</span>(m*<span class="hljs-number">100</span>);<br>    <br>    <span class="hljs-type">int</span> a,b,c,d,n;<br>    a = cent/<span class="hljs-number">25</span>;<br>    b = cent%<span class="hljs-number">25</span>/<span class="hljs-number">10</span>;<br>    c = cent%<span class="hljs-number">25</span>%<span class="hljs-number">10</span>/<span class="hljs-number">5</span>;<br>    d = cent%<span class="hljs-number">25</span>%<span class="hljs-number">10</span>%<span class="hljs-number">5</span>;<br>    <br>    n = a+b+c+d;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i\n&quot;</span>,n);<br>&#125;Copy<br></code></pre></td></tr></table></figure><h1 id="Credit"><a href="#Credit" class="headerlink" title="Credit"></a>Credit</h1><p>美国信用卡的卡号有相应的数学关系，可以通过其关系判断是否为合法的信用卡卡号。<a href="https://cs50.harvard.edu/x/2020/psets/1/credit/#luhns-algorithm">Luhn’s Algorithm</a> 算法就是一种判断信用卡卡号是否合法的一种算法。其定义为：</p><ol><li>从数字的第二位到最后一位开始，每隔一位数字乘以 2，然后将这些乘积的数字相加。</li><li>将总和加到没有乘以 2 的数字的总和上。</li><li>如果总和的最后一位数字是 0（或者，更正式地说，如果总和乘以10是与0同位的），那么这个数字就是有效的。</li></ol><p>e.g. That’s kind of confusing, so let’s try an example with David’s Visa: 4003600000000014.</p><ol><li><p>For the sake of discussion, let’s first underline every other digit, starting with the number’s second-to-last digit:</p><p>4003600000000014</p><p>Okay, let’s multiply each of the underlined digits by 2:</p><p>1•2 + 0•2 + 0•2 + 0•2 + 0•2 + 6•2 + 0•2 + 4•2</p><p>That gives us:</p><p>2 + 0 + 0 + 0 + 0 + 12 + 0 + 8</p><p>Now let’s add those products’ digits (i.e., not the products themselves) together:</p><p>2 + 0 + 0 + 0 + 0 + 1 + 2 + 0 + 8 &#x3D; 13</p></li><li><p>Now let’s add that sum (13) to the sum of the digits that weren’t multiplied by 2 (starting from the end):</p><p>13 + 4 + 0 + 0 + 0 + 0 + 0 + 3 + 0 &#x3D; 20</p></li><li><p>Yup, the last digit in that sum (20) is a 0, so David’s card is legit!</p><p><a href="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/202008120027.png"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/202008120027.png" alt="Snipaste_2020-07-10_12-27-47"></a></p></li></ol><h2 id="Puprose-2"><a href="#Puprose-2" class="headerlink" title="Puprose"></a>Puprose</h2><p>write a program that prompts the user for a credit card number and then reports (via <code>printf</code>) whether it is a valid American Express, MasterCard, or Visa card number, per the definitions of each’s format herein. So that we can automate some tests of your code, we ask that your program’s last line of output be <code>AMEX\n</code> or <code>MASTERCARD\n</code> or <code>VISA\n</code> or <code>INVALID\n</code>, nothing more, nothing less.</p><h2 id="Method-2"><a href="#Method-2" class="headerlink" title="Method"></a>Method</h2><p><a href="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004740.png"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004740.png" alt="Snipaste_2020-07-10_12-26-16"></a></p><p><a href="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004804.png"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004804.png" alt="Snipaste_2020-07-10_12-27-07"></a></p><p><a href="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004836.png"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004836.png" alt="Snipaste_2020-07-10_12-49-45"></a></p><p><a href="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812005831.png"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812005831.png" alt="Snipaste_2020-07-10_12-50-27"></a></p><p><a href="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004933.png"><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812004933.png" alt="Snipaste_2020-07-10_12-52-25"></a></p><p>重点在于对奇数和偶数部分的求和。奇数部分 for 循环使用 <code>i / 100</code> 来获得下一次奇数位(间隔两位)，使用 <code>oddsum % 10</code> 获得当前奇数位的数值。</p><p>偶数部分 for 循环，先 <code>x2 = i / 10</code> 让卡号从偶数位开始。由于偶数位需要 ×2 再相加，并且如果乘机为十位还需要拆开分别数字相加（e.g. 2×6&#x3D;12，相加时是 1+2。此时在 for 循环中嵌套if判断，若乘机两位数则进行分解相加，否则直接相加，再同理求得偶数位和。</p><h2 id="The-Code-2"><a href="#The-Code-2" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/********************************************************</span><br><span class="hljs-comment">*   This is a simple C program that allows you to       *</span><br><span class="hljs-comment">*   determine whether a given credit card number        *</span><br><span class="hljs-comment">*   is a Visa, American Express, or MasterCard.         *</span><br><span class="hljs-comment">*                                                       *</span><br><span class="hljs-comment">*   Eren Lu                                             *</span><br><span class="hljs-comment">*   Fall 2020 CS50  pset 1                              *</span><br><span class="hljs-comment">*********************************************************/</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cs50.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> i,cd, x2even;  <br>    <span class="hljs-type">int</span> sum, oddsum, evensum;<br>    <br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        i = <span class="hljs-built_in">get_long</span>(<span class="hljs-string">&quot;Please input your Credit Card number:\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">while</span>( i &lt; <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">//奇数位求和</span><br>    <span class="hljs-keyword">for</span>(cd = i, oddsum = <span class="hljs-number">0</span>; cd &gt; <span class="hljs-number">0</span>; cd /= <span class="hljs-number">100</span>)<br>    &#123;<br>        oddsum = oddsum + cd % <span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//偶数位求和</span><br>    <span class="hljs-keyword">for</span>(x2even = i / <span class="hljs-number">10</span>, evensum = <span class="hljs-number">0</span>; x2even &gt; <span class="hljs-number">0</span>; x2even /= <span class="hljs-number">100</span> )<br>    &#123;<br>        <span class="hljs-comment">//判断×2以后是否为两位数，若是则需要再次分离相加</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span> * (x2even % <span class="hljs-number">10</span>)&gt; <span class="hljs-number">9</span> )<br>        &#123;<br>            evensum = evensum + <span class="hljs-number">2</span>*(x2even % <span class="hljs-number">10</span>) / <span class="hljs-number">10</span>;  <span class="hljs-comment">//分离十位数并相加</span><br>            evensum = evensum + <span class="hljs-number">2</span>*(x2even % <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>;  <span class="hljs-comment">//分离个位数并相加</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>            evensum = evensum + <span class="hljs-number">2</span>*(x2even % <span class="hljs-number">10</span>);<br>    &#125;<br>    <br>    sum = oddsum + evensum;<br>        <br>    <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>((i &gt;= <span class="hljs-number">340000000000000</span> &amp;&amp; i &lt; <span class="hljs-number">350000000000000</span>) || (i &gt;= <span class="hljs-number">370000000000000</span> &amp;&amp; i &lt; <span class="hljs-number">380000000000000</span>))<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AMEX\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">5100000000000000</span> &amp;&amp; i &lt; <span class="hljs-number">5600000000000000</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MASTERCARD\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((i &gt;= <span class="hljs-number">4000000000000</span> &amp;&amp; i &lt; <span class="hljs-number">5000000000000</span>) || (i &gt;= <span class="hljs-number">4000000000000000</span> &amp;&amp; i &lt; <span class="hljs-number">5000000000000000</span>))<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;VISA\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;INVALID\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;INVALID\n&quot;</span>);<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>把 pset1做完整体下来陆陆续续花了小两天的时间。看似题数不多，可每一题都很扎实。最后一题在做的时候硬是想不出来，最后还是去网上搜寻了思路。虽然才第一次作业，但作为一名 C 很垃圾并且很久没用 C 的我，也不得不开始感叹 CS50 的课程设计真的名不虚传。</p>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CS50 | Week 1 C</title>
    <link href="/posts/1cf2.html"/>
    <url>/posts/1cf2.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>提示：在此只是将零散的、个人化的知识点记录下来，完整笔记查看官方 <a href="https://cs50.harvard.edu/x/2020/weeks/1/">Notes</a> 即可。 </p>          </div><h2 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h2><ul><li><p>语法糖</p><p>e.g. <code>count ++</code></p></li><li><p>单个等号是从右向左赋值</p></li><li><p>布尔值：true or false</p></li><li><p>三种循环</p><p>while loop</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">50</span>) <span class="hljs-comment">//布尔表达式</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, world\n&quot;</span>);<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>​for loop: <code>for(初始值; 布尔表达式; 执行)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; ; i *= <span class="hljs-number">2</span>)  <span class="hljs-comment">//无限循环 or true，因为没有布尔表达式</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i\n&quot;</span>, i);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        do-while loop (至少执行一次)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cs50.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_positive_int</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">get_positive_int</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i\n&quot;</span>, i);<br>&#125;<br><br><span class="hljs-comment">// Prompt user for positive integer</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_positive_int</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        n = <span class="hljs-built_in">get_int</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;Positive Integer: &quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (n &lt; <span class="hljs-number">1</span>);  <span class="hljs-comment">// 布尔表达式</span><br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>#include &lt;CS50.h&gt;</code> 表示进入库，库只是一个代码代码文件。别人写的，我们来用，</li></ul><p>  <code>#include &lt;stdio.h&gt;</code> 访问标准 I&#x2F;O 库，包含 printf 等函数。</p><ul><li><p>在可以 copy code 时应该抵制这种诱惑，这会让代码复杂冗长。</p></li><li><p>主要的 <code>  main</code> 程序部分应该在最前面，读代码更方便。所以定义的其他函数可以放在底部。但是 C 执行时是从上往下依次执行，会遇到不认识的新函数。此时则把 <code> void xxx(void);</code> 复制到前面去， 去欺骗 C，让它以为曾经见过，只是不完全知道这个函数。（这个解释太棒了！）</p></li><li><p><code>void xxx(void)</code>   第一个位置表示输出类型（type of output），第二个位置表示输入类型（type of input）</p><p>e.g. 第一个 void 表示不返回任何输出，第二个 void 表示不接受任何输入。    </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">cough</span>(int n)  <span class="hljs-comment">//cough函数接受输入n</span><br><span class="hljs-built_in">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(&quot;cough\n&quot;);<br><span class="hljs-selector-tag">i</span>++<br>&#125;<br><br>在主函数中就可以为：<br>int <span class="hljs-selector-tag">main</span>(void)<br>&#123;<br><span class="hljs-built_in">cough</span>(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="类型、格式、运算符"><a href="#类型、格式、运算符" class="headerlink" title="类型、格式、运算符"></a>类型、格式、运算符</h2><p>There are other types we can use for our variables</p><ul><li><code>bool</code>, a Boolean expression of either <code>true</code> or <code>false</code></li><li><code>char</code>, a single character like <code>a</code> or <code>2</code></li><li><code>double</code>, a floating-point value with even more digits</li><li><code>float</code>, a floating-point value, or real number with a decimal value</li><li><code>int</code>, integers up to a certain size, or number of bits</li><li><code>long</code>, integers with more bits, so they can count higher</li><li><code>string</code>, a string of characters</li></ul><p>And the CS50 library has corresponding functions to get input of various types:</p><ul><li><code>get_char</code></li><li><code>get_double</code></li><li><code>get_float</code></li><li><code>get_int</code></li><li><code>get_long</code></li><li><code>get_string</code></li></ul><p>for printf, too, there are different placeholders for each type:</p><ul><li><code>%c</code> for chars</li><li><code>%f</code> for floats, doubles</li><li><code>%i</code> for ints</li><li><code>%li</code> for longs</li><li><code>%s</code> for strings</li></ul><p>And there are some mathematical operators we can use:</p><ul><li><code>+</code> for addition</li><li><code>-</code> for subtraction</li><li><code>*</code> for multiplication</li><li><code>/</code> for division</li><li><code>%</code> for remainder</li></ul><h2 id="浮点的不精确-amp-整数的溢出"><a href="#浮点的不精确-amp-整数的溢出" class="headerlink" title="浮点的不精确 &amp; 整数的溢出"></a>浮点的不精确 &amp; 整数的溢出</h2><p>我们的电脑有内存，在硬件芯片称为随机存取存储器。我们的程序在运行时使用 RAM 来存储数据，但是内存是有限的。因此，对于有限的比特数，我们不能代表所有可能的数（其中有无限个数）。所以我们的计算机对每个浮点和整型都有一定数量的位，并且必须在某一点四舍五入到最接近的十进制值。</p><p>RAM 硬件自身限制，使用不当时会造成浮点的不精确 （floating-point imprecision）或整数溢出（inerger overflow）。</p><ul><li>e.g. floating-point imprecision</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&#123;<br>    // Prompt <span class="hljs-keyword">user</span> <span class="hljs-keyword">for</span> x<br>    <span class="hljs-type">float</span> x = get_float(&quot;x: &quot;);<br><br>    // Prompt <span class="hljs-keyword">user</span> <span class="hljs-keyword">for</span> y<br>    <span class="hljs-type">float</span> y = get_float(&quot;y: &quot;);<br><br>    // <span class="hljs-keyword">Perform</span> division<br>    printf(&quot;x / y = %.50f\n&quot;, x / y);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>With <code>%50f</code>, we can specify the number of decimal places displayed.</p></li><li><p>Hmm, now we get …</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">y</span>: <span class="hljs-number">10</span><br><span class="hljs-attribute">x</span> / y = <span class="hljs-number">0</span>.<span class="hljs-number">10000000149011611938476562500000000000000000000000</span><br></code></pre></td></tr></table></figure></li><li><p>It turns out that this is called <strong>floating-point imprecision</strong>, where we don’t have enough bits to store all possible values, so the computer has to store the closest value it can to 1 divided by 10.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实时操作系统（RTOS）</title>
    <link href="/posts/2cde.html"/>
    <url>/posts/2cde.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近要学习 TI 家的 CC2640R2F 板子，许多嵌入式知识都要恶补一通了。在此记录，以作梳理也便日后查阅。</p></blockquote><h2 id="RTOS-的定义"><a href="#RTOS-的定义" class="headerlink" title="RTOS 的定义"></a>RTOS 的定义</h2><p>RTOS (Real Time Operating Sysytem)，又称实时操作系统。一般而言，操作系统的任务就是管理计算机的硬件资源和应用程序。<strong>实时操作系统（RTOS）是为实时应用提供服务，为需要执行的各种任务分配处理时间并按计划执行。</strong>即当外界事件或数据产生时，能够在预定时间之内接受并予以处理，是控制所有实时任务协调一致运行的操作系统。因而，提供<strong>及时响应</strong>和<strong>高可靠性</strong>是其主要特点。</p><p>RTOS 按照实时性分为：硬 RTOS（必须使所有任务在规定时间内完成）和软 RTOS（能让大多数任务在确定时间内完成）。硬 RTOS 主要应用在对实时要求极高的工业领域，当然软硬 RTOS 之分又是不完全确定的，主要要根据具体项目需求进行设计。</p><p>构成：RTOS 由<strong>“ kernel 内核”+“扩展模块”</strong> 构成。其中 kernel 内核应满足实时系统的要求，扩展模块包含文件系统，网络协议栈，应用，设备服务驱动等。</p><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812002227.png" alt="Real-time-Operating-System"></p><h2 id="实时操作系统-vs-分时操作系统"><a href="#实时操作系统-vs-分时操作系统" class="headerlink" title="实时操作系统 vs 分时操作系统"></a>实时操作系统 vs 分时操作系统</h2><p>与实时操作系统相对应的是分时操作系统（Time-sharing Operating System，TSOS）。分时操作系统是把 <a href="https://wiki.mbalib.com/wiki/CPU">CPU</a> 的时间划分成长短基本相同的时间区间，即“时间片”，通过操作系统的管理，把这些时间片依次轮流地分配给各个用户使用。分时操作系统的特点是能有效增加资源的使用率，专注最短时间尽可能地多进行计算。我们常见的 PC 电脑中 windows，macOs，Linux 都属于分时操作系统。</p><table><thead><tr><th>实时操作系统（RTOS）</th><th align="left">分时操作系统（TSOS）</th></tr></thead><tbody><tr><td>专注于快速响应时间</td><td align="left">专注于计算吞吐量</td></tr><tr><td>只嵌入需要实时响应的设备中</td><td align="left">应用广泛</td></tr><tr><td>使用分时段或事件驱动的设计</td><td align="left">使用分时段设计以允许多个任务同时运行</td></tr><tr><td>与 TSOS 相比，RTOS 的编码更加严格</td><td align="left"></td></tr></tbody></table><h2 id="RTOS带来的优势"><a href="#RTOS带来的优势" class="headerlink" title="RTOS带来的优势"></a>RTOS带来的优势</h2><ul><li>降低开发难度，直接使用系统API，即可完成系统资源的申请、多任务的配合（基于优先级的实时抢占调度，同优先级的时间片调度)，以及任务间的通信等（如锁、事件等机制）。</li><li>系统划分为功能明确的任务，不依赖其他任务，增加代码可读性，易于维护和管理。</li><li>提升可移植性，对接不同芯片的工作由操作系统完成，应用开发者只需要关注 OS 层接口。</li><li>密集集成的中间件：中间件组件以任务和驱动的方式增加。他们使用 RTOS 提供的资源与其他任务通信。基于事件被 RTOS 调度。（中间件是位于嵌入式系统软件与应用程序直接的软件）</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RTOS 是运行在 MUC（Mirco Controller Unit）&#x2F; MPU（Micro Processor Unit）之上的，RTOS 是为确保确定性行为和及时响应时间及中断提供调度保证的一种操作系统。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://liteos.github.io/quick-start/intro/why-use-the-rtos.html#rtos-%E6%A6%82%E5%BF%B5">什么是 RTOS ，为什么使用 RTOS</a></li><li><a href="https://www.ni.com/zh-cn/innovations/white-papers/07/what-is-a-real-time-operating-system--rtos--.html">什么是实时操作系统 (RTOS)？</a></li><li><a href="https://strongerhuang.blog.csdn.net/article/details/104853088">嵌入式学RTOS到底有哪些作用？</a></li><li><a href="">RTOS系统与Linux系统的区别.</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>今晚关于普鲁斯特</title>
    <link href="/posts/110d.html"/>
    <url>/posts/110d.html</url>
    
    <content type="html"><![CDATA[<p>昨天听播客偶然听到普鲁斯特问卷，觉得蛮有意思的，打算找时间去了解一下这位作家。今晚和朋友谈论起还不存在围墙的年代曾发过的 ins 照片时，偶然看到朋友曾发过一条普鲁斯特的书摘，于是就普鲁斯特我们便开始聊了起来。</p><hr><p>朋友谈到：</p><blockquote><p>“普鲁斯特像醇厚的大提琴，他的作品会给人一种得以拥抱的亲切感，那种亲昵感就像是自己和主人公融为一体。如果也是很敏感的小孩，就会像找到容身之所。”</p></blockquote><hr><p>这时我想到之前在书上看到过的一句话，大致是“每个读者都能读到他内心自己的光影。”</p><p>因为忽然想不起原话是什么，故而翻开相册查找当时拍的照片。结果惊奇地发现这句话作者便是普鲁斯特。</p><blockquote><p>“ 每个读者只能读到依然存在于他内心的东西，书籍只不过是一种光学仪器，帮助读者发现自己的内心。 —— 马塞尔-普鲁斯特 ”</p></blockquote><hr><p>当发现自己17年的截图时，内心是惊奇而又充满喜悦的，原来在三年前我就已和普鲁斯特见过面，只是那时的我还不认识他。</p><p>今晚的体验是无比美妙和惬意的，那种思维上的巧合刺激着我大脑的神经。和朋友已经约定好待我读完《追忆似水年华：在斯万家那边》便交换问卷。</p><p>等等，为何不用你问我答的播客形式去记录这有趣的过程呢？</p><hr><p><img src="https://cdn.jsdelivr.net/gh/erenlu/PicGo/img/20200812002037.jpg" alt="p2-1"></p>]]></content>
    
    
    <categories>
      
      <category>人文派</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>生活的远航号</title>
    <link href="/posts/640.html"/>
    <url>/posts/640.html</url>
    
    <content type="html"><![CDATA[<p>自己总想抓住生活中零散和琐碎，再把思考和感受记录下来，这对我来说算是一种仪式感。</p><p>Eren‘s Spaceship 将成为我远航号，乘坐着它探索生活的乐趣或远离世俗的沉闷。</p><p>希望今后的某一天，我们隔着窗户望向那深邃又静谧的星际，不说话，就十分美好。  </p>]]></content>
    
    
    <categories>
      
      <category>生活派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
